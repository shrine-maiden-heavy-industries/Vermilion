(* SPDX-License-Identifier: BSD-3-Clause *)
(* EBNF grammar for VHDL 2023 (IEC 61691-1-1:2023) *)

absolute_pathname =
	".", partial_pathname
	;

abstract_literal =
	decimal_literal |
	based_literal
	;

access_incomplete_type_definition =
	"access", access_incomplete_type_indication
	;

access_type_definition =
	"access", subtype_indication
	;

actual_designator =
	[ "inertial" ], conditional_expression |
	signal_name |
	variable_name |
	file_name |
	subtype_indication |
	subprogram_name |
	instantiated_package_name |
	"open"
	;

actual_part =
	actual_designator |
	function_name, "(", actual_designator, ")" |
	type_mark, "(", actual_designator, ")"
	;

adding_operator =
	"+" | "-" | "&"
	;

aggregate =
	"(", element_association, { ",", element_association }, ")"
	;

alias_declaration =
	"alias", alias_designator, [ ":", subtype_indication, subtype_indication ], "is", name, [ signature ], ";"
	;

alias_designator =
	identifier |
	character_literal |
	operator_symbol
	;

allocator =
	"new", subtype_indication |
	"new", qualified_expression
	;

architecture_body =
	"architecture", identifier, "of", entity_name, "is", architecture_declarative_part,
		"begin", architecture_statement_part, "end", [ "architecture" ], [ architecture_simple_name ], ";"
	;

architecture_declarative_part =
	{ block_declarative_item }
	;

architecture_statement_part =
	{ concurrent_statement }
	;

array_constraint =
	index_constraint, [ array_element_constraint ] |
	"(", "open", ")", [ array_element_constraint ]
	;

array_element_constraint =
	element_constraint
	;

array_element_resolution =
	resolution_indication
	;

array_incomplete_type_definition =
	"array", "(", array_index_incomplete_type_list, ")", "of", element_incomplete_subtype_indication
	;

array_index_incomplete_type =
	index_subtype_definition |
	index_constraint |
	unspecified_type_indication
	;

array_index_incomplete_type_list =
	array_index_incomplete_type, { ",", array_index_incomplete_type }
	;

array_mode_view_indication =
	"view", "(", mode_view_name, ")", [ "of", unresolved_array_subtype_indication ]
	;

array_type_definition =
	unbounded_array_definition |
	constrained_array_definition
	;

assertion =
	"assert", condition, [ "report", expression ], [ "severity", expression ]
	;

assertion_statement =
	[ label, ":" ], assertion, ";"
	;

association_element =
	[ formal_part, "=>" ], actual_part
	;

association_list =
	association_element, { ",", association_element }
	;

attribute_declaration =
	"attribute", identifier, ":", type_mark, ";"
	;

attribute_designator =
	attribute_simple_name
	;

attribute_name =
	prefix, [ signature ], "'", attribute_designator, [ "(", expression, ")" ]
	;

attribute_specification =
	"attribute", attribute_designator, "of", entity_specification, "is", expression, ";"
	;

base =
	integer
	;

base_specifier =
	"B" | "O" | "X" | "UB" | "UO" | "UX" | "SB" | "SO" | "SX" | "D"
	;

based_integer =
	extended_digit, { [ underline ], extended_digit }
	;

based_literal =
	base, "#", based_integer, [ ".", based_integer ], "#", [ exponent ]
	;

basic_character =
	basic_graphic_character |
	format_effector
	;

basic_graphic_character =
	upper_case_letter |
	digit |
	special_character |
	space_character
	;

basic_identifier =
	letter, { [ underline ], letter_or_digit }
	;

binding_indication =
	[ "use", entity_aspect ], [ generic_map_aspect ], [ port_map_aspect ]
	;

bit_string_literal =
	[ integer ], base_specifier, '"', [ bit_value ], '"'
	;

bit_value =
	graphic_character, { [ underline ], graphic_character }
	;

block_configuration =
	"for", block_specification, { use_clause }, { configuration_item }, "end", "for", ";"
	;

block_declarative_item =
	subprogram_declaration |
	subprogram_body |
	subprogram_instantiation_declaration |
	package_declaration |
	package_body |
	package_instantiation_declaration |
	type_declaration |
	subtype_declaration |
	mode_view_declaration |
	constant_declaration |
	signal_declaration |
	shared_variable_declaration |
	file_declaration |
	alias_declaration |
	component_declaration |
	attribute_declaration |
	attribute_specification |
	configuration_specification |
	disconnection_specification |
	use_clause |
	group_template_declaration |
	group_declaration |
	psl_property_declaration |
	psl_sequence_declaration |
	psl_clock_declaration
	;

block_declarative_part =
	{ block_declarative_item }
	;

block_header =
	[ generic_clause, [ generic_map_aspect, ";" ] ], [ port_clause, [ port_map_aspect, ";" ] ]
	;

block_specification =
	architecture_name |
	block_statement_label |
	generate_statement_label, [ "(", index_specification, ")" ]
	;

block_statement =
	block_label, ":", "block", [ "(", guard_expression, ")" ], [ "is" ],
		block_header, block_declarative_part, "begin", block_statement_part,
		"end", "block", [ block_label ], ";"
	;

block_statement_part =
	{ concurrent_statement }, concurrent_statement
	;

case_generate_alternative =
	"when", [ alternative_label, ":" ], choices, "=>", generate_statement_body
	;

case_generate_statement =
	generate_label, ":", "case", expression, "generate", case_generate_alternative,
		{ case_generate_alternative }, "end", "generate", [ generate_label ], ";"
	;

case_statement =
	[ case_label, ":" ], "case", [ "?" ], expression, "is", case_statement_alternative,
		{ case_statement_alternative }, "end", "case", [ "?" ], [ case_label ], ";"
	;

case_statement_alternative =
	"when", choices, "=>", sequence_of_statements
	;

character_literal =
	"'", graphic_character, "'"
	;

choice =
	simple_expression |
	discrete_range |
	element_simple_name |
	"others"
	;

choices =
	choice, { "|", choice }
	;

component_configuration =
	"for", component_specification, [ binding_indication, ";" ],
		{ verification_unit_binding_indication, ";" }, [ block_configuration ], "end","for", ";"
	;

component_declaration =
	"component", identifier, [ "is" ], [ local_generic_clause ], [ local_port_clause ],
		"end", "component", [ component_simple_name ], ";"
	;

component_instantiation_statement =
	instantiation_label, ":", instantiated_unit, [ generic_map_aspect ], [ port_map_aspect ], ";"
	;

component_specification =
	instantiation_list, ":", component_name
	;

composite_type_definition =
	array_type_definition |
	record_type_definition
	;

compound_configuration_specification =
	"for", component_specification, binding_indication, ";", verification_unit_binding_indication, ";",
		{ verification_unit_binding_indication, ";" }, "end", "for", ";"
	;

concurrent_assertion_statement =
	[ label, ":" ], [ "postponed" ], assertion, ";"
	;

concurrent_conditional_signal_assignment =
	target, "<=", [ "guarded" ], [ delay_mechanism ], conditional_waveforms, ";"
	;

concurrent_procedure_call_statement =
	[ label, ":" ], [ "postponed" ], procedure_call, ";"
	;

concurrent_selected_signal_assignment =
	"with", expression, "select", [ "?" ],
		target, "<=", [ "guarded" ], [ delay_mechanism ], selected_waveforms, ";"
	;

concurrent_signal_assignment_statement =
	[ label, ":" ], [ "postponed" ], concurrent_simple_signal_assignment |
	[ label, ":" ], [ "postponed" ], concurrent_conditional_signal_assignment |
	[ label, ":" ], [ "postponed" ], concurrent_selected_signal_assignment
	;

concurrent_simple_signal_assignment =
	target, "<=", [ "guarded" ], [ delay_mechanism ], waveform, ";"
	;

concurrent_statement =
	block_statement |
	process_statement |
	concurrent_procedure_call_statement |
	concurrent_assertion_statement |
	concurrent_signal_assignment_statement |
	component_instantiation_statement |
	generate_statement |
	psl_psl_directive
	;

condition =
	expression
	;

condition_clause =
	"until", condition
	;

condition_operator =
	"??"
	;

conditional_expression =
	expression, { "when", condition, "else", expression }
	;

conditional_or_unaffected_expression =
	expression_or_unaffected, { "when", condition, "else", expression_or_unaffected },
		[ "when", condition ]
	;

conditional_signal_assignment =
	target, "<=", [ delay_mechanism ], conditional_waveforms, ";"
	;

conditional_waveforms =
	waveform, "when", condition, { "else", waveform, "when", condition },
		[ "else", waveform ]
	;

configuration_declaration =
	"configuration", identifier, "of", entity_name, "is", configuration_declarative_part,
		{ verification_unit_binding_indication, ";" }, block_configuration,
		"end", [ "configuration" ], [ configuration_simple_name ], ";"
	;

configuration_declarative_item =
	use_clause |
	attribute_specification |
	group_declaration
	;

configuration_declarative_part =
	{ configuration_declarative_item }
	;

configuration_item =
	block_configuration |
	component_configuration
	;

configuration_specification =
	simple_configuration_specification |
	compound_configuration_specification
	;

constant_declaration =
	"constant", identifier_list, ":", subtype_indication, [ ":=", conditional_expression ], ";"
	;

constrained_array_definition =
	"array", index_constraint, "of", element_subtype_indication
	;

constraint =
	range_constraint |
	array_constraint |
	record_constraint
	;

context_clause =
	{ context_item }
	;

context_declaration =
	"context", identifier, "is", context_clause, "end", [ "context" ], [ context_simple_name ], ";"
	;

context_item =
	library_item |
	use_clause |
	context_reference
	;

context_reference =
	"context", select_name, { ",", select_name }, ";"
	;

decimal_literal =
	integer, [ ".", integer ], [ exponent ]
	;

delay_mechanism =
	"transport" |
	| [ "reject", time_expression ], "inertial"
	;

design_file =
	design_unit, { design_unit }
	;

design_unit =
	context_clause, library_unit
	;

designation =
	identifier |
	operator_symbol
	;

direction =
	"to" | "downto"
	;

disconnection_specification =
	"disconnect", guarded_signal_specification, "after", time_expression, ";"
	;

discrete_range =
	discrete_subtype_indication |
	range
	;

discrete_incomplete_type_definition =
	"(", "<>", ")"
	;

element_array_mode_view_indication =
	"view", "(", mode_view_name, ")"
	;

element_association =
	[ choices, "=>" ], expression
	;

element_declaration =
	array_constraint |
	record_constraint
	;

element_declaration =
	identifier_list, ":", element_subtype_definition, ";"
	;

element_mode_indication =
	mode |
	element_mode_view_indication
	;

element_mode_view_indication =
	element_record_mode_view_indication |
	element_array_mode_view_indication
	;

element_record_mode_view_indication =
	"view", mode_view_name
	;

element_resolution =
	array_element_resolution |
	record_resolution
	;

element_subtype_definition =
	subtype_definition
	;

entity_aspect =
	"entity", entity_name, [ "(", architecture_identifier, ")" ] |
	"configuration", configuration_name |
	"open"
	;

entity_class =
	"entity" |
	"architecture" |
	"configuration" |
	"procedure" |
	"function" |
	"package" |
	"type" |
	"subtype" |
	"constant" |
	"signal" |
	"variable" |
	"component" |
	"label" |
	"literal" |
	"units" |
	"group" |
	"file" |
	"property" |
	"sequence" |
	"view"
	;

entity_class_entry =
	entity_class, [ "<>" ]
	;

entity_class_entry_list =
	entity_class_entry, { ",", entity_class_entry }
	;

entity_declaration =
	"entity", identifier, "is", entity_header, entity_declarative_part,
		[ "begin", entity_statement_part ], "end", [ "entity" ], [ entity_simple_name ], ";"
	;

entity_declarative_item =
	subprogram_declaration |
	subprogram_body |
	subprogram_instantiation_declaration |
	package_declaration |
	package_body |
	package_instantiation_declaration |
	type_declaration |
	subtype_declaration |
	mode_view_declaration |
	constant_declaration |
	signal_declaration |
	shared_variable_declaration |
	file_declaration |
	alias_declaration |
	attribute_declaration |
	attribute_specification |
	disconnection_specification |
	use_clause |
	group_template_declaration |
	group_declaration |
	psl_property_declaration |
	psl_sequence_declaration |
	psl_clock_declaration
	;

entity_declarative_part =
	{ entity_declarative_item }
	;

entity_designation =
	entity_tag, [ signature ]
	;

entity_header =
	[ formal_generic_clause ], [ formal_port_clause ]
	;

entity_name_list =
	entity_designator, { ",", entity_designator } |
	"others" |
	"all"
	;

entity_specification =
	entity_name_list, ":", entity_class
	;

entity_statement =
	concurrent_assertion_statement |
	passive_concurrent_procedure_call_statement |
	passive_process_statement |
	psl_psl_directive
	;

entity_statement_part =
	{ entity_statement }
	;

entity_tag =
	simple_name |
	character_literal |
	operator_symbol
	;

enumeration_literal =
	identifier |
	character_literal
	;

enumeration_type_definition =
	"(", enumeration_literal, { ",", enumeration_literal }, ")"
	;

exit_statement =
	[ label, ":" ], "exit", [ loop_label ], [ "when", condition ], ";"
	;

exponent =
	"E", [ "+" ], integer |
	"E", "-", integer
	;

expression =
	condition_operator, primary |
	logical_expression
	;

expression_or_unaffected =
	expression |
	"unaffected"
	;

extended_digit =
	digit |
	letter
	;

extended_identifier =
	"\\", graphic_character, { graphic_character }, "\\"
	;

external_name =
	external_constant_name |
	external_signal_name |
	external_variable_name
	;

external_constant_name =
	"<<", "constant", external_pathname, ":", subtype_indication, ">>"
	;

external_signal_name =
	"<<", "signal", external_pathname, ":", subtype_indication, ">>"
	;

external_variable_name =
	"<<", "variable", external_pathname, ":", subtype_indication, ">>"
	;

external_pathname =
	package_pathname |
	absolute_pathname |
	relative_pathname
	;

factor =
	unary_expression, [ "**", unary_expression ]
	;

file_declaration =
	"file", identifier_list, ":", subtype_indication, [ file_open_information ], ";"
	;

file_incomplete_type_definition =
	"file", "of", file_incomplete_type_mark
	;

file_logical_name =
	string_expression
	;

file_open_information =
	[ "open", file_open_kind_expression ], "is", file_logical_name
	;

file_type_definition =
	"file", "of", type_mark
	;

floating_incomplete_type_definition =
	"range", "<>", ".", "<>"
	;

floating_type_definition =
	range_constraint
	;

for_generate_statement =
	generate_label, ":", "for", generate_parameter_statement, "generate", generate_statement_body,
		"end", "generate", [ generate_label ], ";"
	;

force_mode =
	"in" | "out"
	;

formal_designator =
	generic_name, [ signature ] |
	port_name |
	parameter_name
	;

formal_parameter_list =
	parameter_interface_list
	;

formal_part =
	formal_designator |
	function_name, "(", formal_designator, ")" |
	type_mark, "(", formal_designator, ")"
	;

full_type_declaration =
	"type", identifier, "is", type_definition, ";"
	;

function_call =
	function_name, [ generic_map_aspect ], [ parameter_map_aspect ]
	;

function_specification =
	[ "pure" | "impure" ], "function", designator, subprogram_header,
		[ [ "parameter" ], "(", formal_parameter_list, ")" ], "return",
		[ return_identifier, "of" ], type_mark
	;

generate_specification =
	static_discrete_range |
	static_expression |
	alternative_label
	;

generate_statement =
	for_generate_statement |
	if_generate_statement |
	case_generate_statement
	;

generate_statement_body =
	[ block_declarative_part, "begin" ], { concurrent_statement },
		[ "end", [ alternative_label ], ";" ]
	;

generic_clause =
	"generic", "(", generic_list, ")", ";"
	;

generic_list =
	generic_interface_list
	;

generic_map_aspect =
	"generic", "map", "(", generic_interface_list, ")"
	;

graphic_character =
	basic_graphic_character |
	lower_case_letter |
	other_special_character
	;

group_constituent =
	name |
	character_literal
	;

group_constituent_list =
	group_constituent, { ",", group_constituent }
	;

group_declaration =
	"group", identifier, ":", group_template_name, "(", group_constituent_list, ")", ";"
	;

group_template_declaration =
	"group", identifier, "is", "(", entity_class_entry_list, ")", ";"
	;

guarded_signal_specification =
	guarded_signal_list, ":", type_mark
	;

identifier =
	basic_identifier |
	extended_identifier
	;

identifier_list =
	identifier, { ",", identifier }
	;

if_generate_statement =
	generate_label, ":", "if", [ alternative_label, ":" ], condition, "generate", generate_statement_body,
		{ "elsif", [ alternative_label, ":" ], condition, "generate", generate_statement_body },
		[ "else", [ alternative_label, ":" ], "generate", generate_statement_body ],
		"end", "generate", [ generate_label ], ";"
	;

if_statement =
	[ if_label, ":" ], "if", condition, "then", sequence_of_statements,
		{ "elsif", condition, "then", sequence_of_statements },
		[ "else", sequence_of_statements ], "end", "if", [ if_label ], ";"
	;

incomplete_subtype_indication =
	subtype_indication |
	unspecified_type_indication
	;

incomplete_type_declaration =
	"type", identifier, ";"
	;

incomplete_type_declaration =
	private_incomplete_type_definition |
	scalar_incomplete_type_definition |
	discrete_incomplete_type_definition |
	integer_incomplete_type_definition |
	physical_incomplete_type_definition |
	floating_incomplete_type_definition |
	array_incomplete_type_definition |
	access_incomplete_type_definition |
	file_incomplete_type_definition
	;

incomplete_type_mark =
	type_mark |
	unspecified_type_indication
	;

index_constraint =
	"(", discrete_range, { ",", discrete_range }, ")"
	;

index_subtype_definition =
	type_mark, "range", "<>"
	;

indexed_name =
	prefix, "(", expression, { ",", expression }, ")"
	;

instantiated_unit =
	[ "component" ], component_name |
	"entity", entity_name, [ "(", architecture_identifier, ")" ] |
	"configuration", configuration_name
	;

instantiation_list =
	instantiation_label, { instantiation_label } |
	"others" |
	"all"
	;

integer =
	digit, { [ underline ], digit }
	;

integer_incomplete_type_definition =
	"range", "<>"
	;

integer_type_definition =
	range_constraint
	;

interface_constant_declaration =
	[ "constant" ], identifier_list, ":", [ "in" ], interface_type_indication,
		[ ":=", static_conditional_expression ]
	;

interface_declaration =
	interface_object_declaration |
	interface_type_declaration |
	interface_subprogram_declaration |
	interface_package_declaration
	;

interface_element =
	interface_declaration
	;

interface_file_declaration =
	"file", identifier_list, ":", subtype_indication
	;

interface_function_specification =
	[ "pure" | "impure" ], "function", designator,
		[ [ "parameter" ], "(", formal_parameter_list, ")" ], "return", type_mark
	;

interface_list =
	interface_element, { ";", interface_element }
	;

interface_object_declaration =
	interface_constant_declaration |
	interface_signal_declaration |
	interface_variable_declaration |
	interface_file_declaration
	;

interface_package_declaration =
	"package", identifier, "is", "new", uninstantiated_package_name, interface_package_generic_map_aspect
	;

interface_package_generic_map_aspect =
	generic_map_aspect |
	"generic", "map", "(", "<>", ")" |
	"generic", "map", "(", "default", ")"
	;

interface_procedure_specification =
	"procedure", identifier, [ [ "parameter" ], "(", formal_parameter_list, ")" ]
	;

interface_signal_declaration =
	[ "signal" ], identifier_list, ":", signal_mode_indication
	;

interface_subprogram_declaration =
	interface_subprogram_specification, [ "is", interface_subprogram_default ]
	;

interface_subprogram_default =
	subprogram_name |
	"<>"
	;

interface_subprogram_specification =
	interface_procedure_specification |
	interface_function_specification
	;

interface_type_declaration =
	"type", identifier, [ "is", incomplete_type_definition ]
	;

interface_type_indication =
	subtype_indication |
	unspecified_type_indication
	;

interface_variable_declaration =
	[ "variable" ], identifier_list, ":", [ mode ], interface_type_declaration,
		[ ":=", static_expression ]
	;

iteration_scheme =
	"while", condition |
	"for", loop_parameter_specification
	;

label =
	identifier
	;

letter =
	upper_case_letter |
	lower_case_letter
	;

letter_or_digit =
	letter |
	digit
	;

library_clause =
	"library", logical_name_list, ";"
	;

library_unit =
	primary_unit |
	secondary_unit
	;

literal =
	numeric_literal |
	enumeration_literal |
	string_literal |
	bit_string_literal |
	"null"
	;

logical_expression =
	relation, { "and", relation } |
	relation, { "or", relation } |
	relation, { "xor", relation } |
	relation, [ "nand", relation ] |
	relation, [ "nor", relation ] |
	relation, { "xor", relation }
	;

logical_name =
	identifier
	;

logical_name_list =
	logical_name, { ",", logical_name }
	;

logical_operator =
	"and" | "or" | "nand" | "nor" | "xor" | "xnor"
	;

loop_statement =
	[ loop_label, ":" ], [ iteration_scheme ], "loop", sequence_of_statements,
		"end", "loop", [ loop_label ], ";"
	;

miscellaneous_operator =
	"**" | "abs" | "not"
	;

mode =
	"in" | "out" | "inout" | "buffer" | "linkage"
	;

mode_indication =
	simple_mode_indication |
	record_mode_view_indication
	;

mode_view_declaration =
	"view", identifier, "of", unresolved_record_subtype_indication, "is", { mode_view_element_definition },
		"end", "view", [ mode_view_simple_name ], ";"
	;

mode_view_element_definition =
	record_mode_view_indication |
	array_mode_view_indication
	;

multiplying_operator =
	"*" | "/" | "mod" | "rem"
	;

name =
	simple_name |
	operator_symbol |
	character_literal |
	selected_name |
	indexed_name |
	slice_name |
	attribute_name |
	external_name
	;

next_statement =
	[ label, ":" ], "next", [ loop_label ], [ "when", condition ], ";"
	;

null_statement =
	[ label, ":" ], "null", ";"
	;

numeric_literal =
	abstract_literal |
	physical_literal
	;

object_declaration =
	constant_declaration |
	signal_declaration |
	variable_declaration |
	file_declaration
	;

operator_symbol =
	string_literal
	;

package_body =
	"package", "body", package_simple_name, "is", package_body_declarative_part, "end",
		[ "package", "body" ], [ package_simple_name ], ";"
	;

package_body_declarative_item =
	subprogram_declaration |
	subprogram_body |
	subprogram_instantiation_declaration |
	package_declaration |
	package_body |
	package_instantiation_declaration |
	type_declaration |
	subtype_declaration |
	constant_declaration |
	variable_declaration |
	file_declaration |
	alias_declaration |
	attribute_declaration |
	attribute_specification |
	use_clause |
	group_template_declaration |
	group_declaration
	;

package_body_declarative_part =
	{ package_body_declarative_item }
	;

package_declaration =
	"package", identifier, "is", package_header, package_declarative_part, "end",
		[ "package" ], [ package_simple_name ], ";"
	;

package_declarative_item =
	subprogram_declaration |
	subprogram_instantiation_declaration |
	package_declaration |
	package_instantiation_declaration |
	type_declaration |
	subtype_declaration |
	mode_view_declaration |
	constant_declaration |
	signal_declaration |
	variable_declaration |
	file_declaration |
	alias_declaration |
	component_declaration |
	attribute_declaration |
	attribute_specification |
	disconnection_specification |
	use_clause |
	group_template_declaration |
	group_declaration |
	psl_property_declaration |
	psl_sequence_declaration
	;

package_declarative_part =
	{ package_declarative_item }
	;

package_header =
	[ generic_clause, [ generic_map_aspect, ";" ] ]
	;

package_instantiation_declaration =
	"package", identifier, "is", "new", uninstantiated_package_name, [ generic_map_aspect ], ";"
	;

package_pathname =
	"@", library_logical_name, ".", { package_simple_name, "." }, object_simple_name
	;

parameter_specification =
	identifier, "in", discrete_range
	;

partial_pathname =
	{ pathname_element, "." }, object_simple_name
	;

pathname_element =
	entity_simple_name |
	component_instantiation_label |
	block_label |
	generate_statement_label, [ "(", static_expression, ")" ] |
	package_simple_name
	;

physical_literal =
	[ abstract_literal ], unit_name
	;

physical_type_definition =
	range_constraint, "units", primary_unit_declaration, { secondary_unit_declaration },
		"end", "units", [ physical_type_simple_name ]
	;

plain_return_statement =
	[ label, ":" ], "return", [ "when", condition ], ";"
	;

port_clause =
	"port", "(", port_list, ")", ";"
	;

port_list =
	port_interface_list
	;

port_map_aspect =
	"port", "map", "(", port_association_list, ")"
	;

prefix =
	name |
	function_call
	;

primary =
	name |
	literal |
	aggregate |
	function_call |
	qualified_expression |
	type_conversion |
	allocator |
	"(", expression, ")"
	;

primary_unit =
	entity_declaration |
	configuration_declaration |
	package_declaration |
	package_instantiation_declaration |
	context_declaration |
	psl_verification_unit
	;

primary_unit_declaration =
	identifier, ";"
	;

private_variable_declaration =
	"private", variable_declaration
	;

private_incomplete_type_definition =
	"private"
	;

procedure_call =
	procedure_name, [ generic_map_aspect ], [ parameter_map_aspect ]
	;

procedure_call_statement =
	[ label, ":" ], procedure_call, ";"
	;

procedure_specification =
	"procedure", identifier, subprogram_header, [ [ "parameter" ], "(", formal_parameter_list, ")" ]
	;

process_declarative_item =
	subprogram_declaration |
	subprogram_body |
	subprogram_instantiation_declaration |
	package_declaration |
	package_body |
	package_instantiation_declaration |
	type_declaration |
	subtype_declaration |
	constant_declaration |
	variable_declaration |
	file_declaration |
	alias_declaration |
	attribute_declaration |
	attribute_specification |
	use_clause |
	group_template_declaration |
	group_declaration
	;

process_declarative_part =
	{ process_declarative_item }
	;

process_sensitivity_list =
	"all" |
	sensitivity_list
	;

process_statement =
	[ process_label, ":" ], [ "postponed" ], "process", [ "(", process_sensitivity_list, ")" ], [ "is" ],
		process_declarative_part, "begin", process_statement_part, "end",
		[ "postponed" ], "process", [ process_label ], ";"
	;

process_statement_part =
	{ sequential_statement }
	;

protected_type_body =
	"protected", "body", protected_type_body_declarative_part, "end", "protected", "body",
		[ protected_type_simple_name ]
	;

protected_type_body_declarative_item =
	subprogram_declaration |
	subprogram_body |
	subprogram_instantiation_declaration |
	package_declaration |
	package_body |
	package_instantiation_declaration |
	type_declaration |
	subtype_declaration |
	constant_declaration |
	variable_declaration |
	file_declaration |
	alias_declaration |
	attribute_declaration |
	attribute_specification |
	use_clause |
	group_template_declaration |
	group_declaration
	;

protected_type_body_declarative_part =
	{ protected_type_body_declarative_item }
	;

protected_type_declaration =
	"protected", protected_type_header, protected_type_declarative_part,
		"end", "protected", [ protected_type_simple_name ]
	;

protected_type_declarative_item =
	subprogram_specification |
	subprogram_instantiation_declaration |
	attribute_specification |
	use_clause |
	private_variable_declaration |
	alias_declaration
	;

protected_type_declarative_part =
	{ protected_type_declarative_item }
	;

protected_type_definition =
	protected_type_declaration |
	protected_type_body
	;

protected_type_header =
	[ generic_clause, [ generic_map_aspect, ";" ] ]
	;

protected_type_instantiation_definition =
	"new", uninstantiated_protected_type_name, [ generic_map_aspect ]
	;

qualified_expression =
	type_mark, "'", "(", expression, ")" |
	type_mark, "'", aggregate |
	type_mark, "'", "(", ")"
	;

range =
	range_attribute_name |
	simple_range |
	range_expression
	;

range_constraint =
	"range", range
	;

record_constraint =
	"(", record_element_constraint, { ",", record_element_constraint }, ")"
	;

record_element_constraint =
	record_element_simple_name, element_constraint
	;

record_element_resolution =
	record_element_simple_name, resolution_indication
	;

record_resolution =
	record_element_resolution, { ",", record_element_resolution }
	;

record_type_definition =
	"record", { element_declaration }, "end", "record", [ record_type_simple_name ]
	;

record_mode_view_indication =
	"view", mode_view_name, [ "of", unresolved_record_subtype_indication ]
	;

relation =
	shift_expression, [ relational_operator, shift_expression ]
	;

relational_operator =
	"=" | "/=" | "<" | "<=" | ">" | ">=" | "?=" | "?/=" | "?<" | "?<=" | "?>" | "?>="
	;

relative_pathname =
	{ "^", "." }, partial_pathname
	;

report_statement =
	[ label, ":" ], "report", expression, [ "severity", expression ], ";"
	;

resolution_indication =
	resolution_function_name |
	"(", element_resolution, ")"
	;

return_statement =
	plain_return_statement |
	value_return_statement
	;

scalar_incomplete_type_definition =
	"<>"
	;

scalar_type_definition =
	enumeration_type_definition |
	integer_type_definition |
	floating_type_definition |
	physical_type_definition
	;

secondary_unit =
	architecture_body |
	package_body
	;

secondary_unit_declaration =
	identifier, "=", physical_literal, ";"
	;

selected_expressions =
	{ expression, "when", choices, "," }, expression, "when", choices
	;

selected_force_assignment =
	"with", expression, "select", [ "?" ],
		target, "<=", "force", [ force_mode ], selected_expressions, ";"
	;

selected_name =
	prefix, ".", suffix
	;

selected_signal_assignment =
	selected_waveform_assignment |
	selected_force_assignment
	;

selected_variable_assignment =
	"with", expression, "select", [ "?" ],
		target, ":=", selected_expressions, ";"
	;

selected_waveform_assignment =
	"with", expression, "select", [ "?" ],
		target, "<=", [ delay_mechanism ], selected_waveforms, ";"
	;

selected_waveforms =
	{ waveform, "when", choices, "," }, waveform, "when", choices
	;

sensitivity_clause =
	"on", sensitivity_list
	;

sensitivity_list =
	signal_name, { ",", signal_name }
	;

sequence_of_statements =
	{ sequential_statement }
	;

sequential_block_statement =
	[ sequential_block_label, ":" ], "block", [ "is" ], sequential_block_declarative_part, "begin",
		sequential_block_statement_part, "end", [ "block" ], [ sequential_block_label ], ";"
	;

sequential_block_declarative_part =
	{ process_declarative_item }
	;

sequential_block_statement_part =
	{ sequential_statement }
	;

sequential_statement =
	wait_statement |
	assertion_statement |
	report_statement |
	signal_assignment_statement |
	variable_assignment_statement |
	procedure_call_statement |
	if_statement |
	case_statement |
	loop_statement |
	next_statement |
	exit_statement |
	return_statement |
	null_statement |
	sequential_block_statement
	;

shift_expression =
	simple_expression, [ shift_operator, simple_expression ]
	;

shift_operator =
	"sll" | "slr" | "sla" | "sra" | "rol" | "ror"
	;

sign =
	"+" | "-"
	;

signal_assignment_statement =
	[ label, ":" ], simple_signal_assignment |
	[ label, ":" ], conditional_signal_assignment |
	[ label, ":" ], selected_signal_assignment
	;

signal_declaration =
	"signal", identifier_list, ":", subtype_indication, [ signal_kind ], [ ":=", expression ], ";"
	;

signal_kind =
	"register" | "bus"
	;

signal_list =
	signal_name, { ",", signal_name } |
	"others" |
	"all"
	;

signature =
	[ [ type_mark, { ",", type_mark } ], [ "return", type_mark ] ]
	;

simple_configuration_specification =
	"for", component_specification, binding_indication, ";", [ "end", "for", ";" ]
	;

simple_expression =
	[ sign ], term, { adding_operator, term }
	;

simple_force_assignment =
	target, "<=", "force", [ force_mode ], expression, ";"
	;

simple_mode_indication =
	[ mode ], interface_type_indication, [ "bus" ], [ ":=", static_conditional_expression ]
	;

simple_name =
	identifier
	;

simple_range =
	simple_expression, direction, simple_expression
	;

simple_release_assignment =
	target, "<=", "release", [ force_mode ], ";"
	;

simple_signal_assignment =
	simple_waveform_assignment |
	simple_force_assignment |
	simple_release_assignment
	;

simple_waveform_assignment =
	target, "<=", [ delay_mechanism ], waveform, ";"
	;

simple_variable_assignment =
	target, ":=", expression, ";"
	;

slice_name =
	prefix, "(", discrete_range, ")"
	;

string_literal =
	'"', { graphic_character }, '"'
	;

subprogram_body =
	subprogram_specification, "is", subprogram_declarative_part, "begin", subprogram_statement_part,
		"end", [ subprogram_kind ], [ designator ], ";"
	;

subprogram_declaration =
	subprogram_specification, ";"
	;

subprogram_declarative_item =
	subprogram_declaration |
	subprogram_body |
	subprogram_instantiation_declaration |
	package_declaration |
	package_body |
	package_instantiation_declaration |
	type_declaration |
	subtype_declaration |
	constant_declaration |
	variable_declaration |
	file_declaration |
	alias_declaration |
	attribute_declaration |
	attribute_specification |
	use_clause |
	group_template_declaration |
	group_declaration
	;

subprogram_declarative_part =
	{ subprogram_declarative_item }
	;

subprogram_header =
	[ "generic", "(", generic_list, ")", [ generic_map_aspect ] ]
	;

subprogram_instantiation_declaration =
	subprogram_kind, identifier, "is", "new", uninstantiated_subprogram_name, [ signature ],
		[ generic_map_aspect ], ";"
	;

subprogram_kind =
	"procedure" | "function"
	;

subprogram_specification =
	procedure_specification |
	function_specification
	;

subprogram_statement_part =
	{ sequential_statement }
	;

subtype_declaration =
	"subtype", identifier, "is", subtype_indication, ";"
	;

subtype_indication =
	[ resolution_indication ], type_mark, [ constraint ]
	;

suffix =
	simple_name |
	character_literal |
	operator_symbol |
	"all"
	;

target =
	name |
	aggregate
	;

term =
	factor, { multiplying_operator, factor }
	;

timeout_clause =
	"for", time_expression
	;

tool_directive =
	"`", identifier, { graphic_character }
	;

type_conversion =
	type_mark, "(", expression, ")"
	;

type_declaration =
	full_type_declaration |
	incomplete_type_declaration
	;

type_definition =
	scalar_type_definition |
	composite_type_definition |
	access_type_definition |
	file_type_definition |
	protected_type_definition |
	protected_type_instantiation_definition
	;

type_mark =
	type_name |
	subtype_name
	;

unary_expression =
	primary |
	"abs", primary |
	"not", primary |
	unary_logical_operator, primary
	;

unary_miscellaneous_operator =
	"abs" |
	"not" |
	unary_logical_operator
	;

unbounded_array_definition =
	"array", "(", index_subtype_definition, { ",", index_subtype_definition }, ")",
		"of", element_subtype_indication
	;

unspecified_type_indication =
	"type", "is", incomplete_type_definition
	;

use_clause =
	"use", selected_name, { ",", selected_name }, ";"
	;

variable_assignment_statement =
	[ label, ":" ], simple_variable_assignment |
	[ label, ":" ], selected_variable_assignment
	;

variable_declaration =
	[ "shared" ], "variable", identifier_list, ":", subtype_indication, [ generic_map_aspect ],
		[ ":=", expression ], ";"
	;

verification_unit_binding_indication =
	"use", "vunit", verification_unit_list
	;

verification_unit_list =
	verification_unit_name, { ",", verification_unit_name }
	;

wait_statement =
	[ label, ":" ], "wait", [ sensitivity_clause ], [ condition_clause ], [ timeout_clause ], ";"
	;

waveform =
	waveform_element, { ",", waveform_element } |
	"unaffected"
	;

waveform_element =
	value_expression, [ "after", time_expression ] |
	"null", [ "after", time_expression ]
	;

(*
	Keywords:
		abs
		access
		after
		alias
		all
		and
		architecture
		array
		assert
		assume
		attribute
		begin
		block
		body
		buffer
		bus
		case
		component
		configuration
		constant
		context
		cover
		default
		disconnect
		downto
		else
		elsif
		end
		entity
		exit
		fairness
		file
		for
		force
		function
		generate
		generic
		group
		guarded
		if
		impure
		in
		inertial
		inout
		is
		label
		library
		linkage
		literal
		loop
		map
		mod
		nand
		new
		next
		nor
		not
		null
		of
		on
		open
		or
		others
		out
		package
		parameter
		port
		postponed
		private
		procedure
		process
		property
		protected
		pure
		range
		record
		register
		reject
		release
		rem
		report
		restrict
		return
		rol
		ror
		select
		sequence
		severity
		shared
		signal
		sla
		sll
		sra
		srl
		strong
		subtype
		then
		to
		transport
		type
		unaffected
		units
		until
		use
		variable
		view
		vmode
		vpkg
		vprop
		vunit
		wait
		when
		while
		with
		xnor
		xor
*)
