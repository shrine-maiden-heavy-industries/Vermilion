(* SPDX-License-Identifier: BSD-3-Clause *)
(* EBNF grammar for VHDL 1987 (IEEE 1076-1987) *)

abstract_literal =
	decimal_literal |
	based_literal
	;

access_type_definition =
	"access", subtype_indication
	;

actual_designator =
	expression |
	signal_name |
	variable_name |
	"open"
	;

actual_parameter_part =
	parameter_association_list
	;

actual_part =
	actual_designator |
	function_name, "(", actual_designator, ")" |
	;

adding_operator =
	"+" | "-" | "&"
	;

aggregate =
	"(", element_association, { ",", element_association }, ")"
	;

alias_declaration =
	"alias", identifier, ":", subtype_indication , "is", name, ";"
	;

allocator =
	"new", subtype_indication |
	"new", qualified_expression
	;

architecture_body =
	"architecture", identifier, "of", entity_name, "is", architecture_declarative_part,
		"begin", architecture_statement_part, "end", [ architecture_simple_name ], ";"
	;

architecture_declarative_part =
	{ block_declarative_item }
	;

architecture_statement_part =
	{ concurrent_statement }
	;

array_type_definition =
	unconstrained_array_definition |
	constrained_array_definition
	;

assertion_statement =
	"assert", condition, [ "report", expression ], [ "severity", expression ], ";"
	;

association_element =
	[ formal_part, "=>" ], actual_part
	;

association_list =
	association_element, { ",", association_element }
	;

attribute_declaration =
	"attribute", identifier, ":", type_mark, ";"
	;

attribute_designator =
	attribute_simple_name
	;

attribute_name =
	prefix, "'", attribute_designator, [ "(", expression, ")" ]
	;

attribute_specification =
	"attribute", attribute_designator, "of", entity_specification, "is", expression, ";"
	;

base =
	integer
	;

base_specifier =
	"B" | "O" | "X"
	;

base_unit_declaration =
	identifier, ";"
	;

based_integer =
	extended_digit, { [ underline ], extended_digit }
	;

based_literal =
	base, "#", based_integer, [ ".", based_integer ], "#", [ exponent ]
	;

basic_character =
	basic_graphic_character |
	format_effector
	;

basic_graphic_character =
	upper_case_letter |
	digit |
	special_character |
	space_character
	;

binding_indication =
	entity_aspect, [ generic_map_aspect ], [ port_map_aspect ]
	;

bit_string_literal =
	base_specifier, '"', bit_value, '"'
	;

bit_value =
	extended_digit, { [ underline ], extended_digit }
	;

block_configuration =
	"for", block_specification, { use_clause }, { configuration_item }, "end", "for", ";"
	;

block_declarative_item =
	subprogram_declaration |
	subprogram_body |
	type_declaration |
	subtype_declaration |
	constant_declaration |
	signal_declaration |
	file_declaration |
	alias_declaration |
	component_declaration |
	attribute_declaration |
	attribute_specification |
	configuration_specification |
	disconnection_specification |
	use_clause
	;

block_declarative_part =
	{ block_declarative_item }
	;

block_header =
	[ generic_clause, [ generic_map_aspect, ";" ] ], [ port_clause, [ port_map_aspect, ";" ] ]
	;

block_specification =
	architecture_name |
	block_statement_label |
	generate_statement_label, [ "(", index_specification, ")" ]
	;

block_statement =
	block_label, ":", "block", [ "(", guard_expression, ")" ],
		block_header, block_declarative_part, "begin", block_statement_part,
		"end", "block", [ block_label ], ";"
	;

block_statement_part =
	{ concurrent_statement }
	;

case_statement =
	"case", expression, "is", case_statement_alternative,
		{ case_statement_alternative }, "end", "case", ";"
	;

case_statement_alternative =
	"when", choices, "=>", sequence_of_statements
	;

character_literal =
	"'", graphic_character, "'"
	;

choice =
	simple_expression |
	discrete_range |
	element_simple_name |
	"others"
	;

choices =
	choice, { "|", choice }
	;

component_configuration =
	"for", component_specification, [ "use", binding_indication, ";" ], [ block_configuration ],
		"end","for", ";"
	;

component_declaration =
	"component", identifier, [ local_generic_clause ], [ local_port_clause ],
		"end", "component", ";"
	;

component_instantiation_statement =
	instantiation_label, ":", component_name, [ generic_map_aspect ], [ port_map_aspect ], ";"
	;

component_specification =
	instantiation_list, ":", component_name
	;

composite_type_definition =
	array_type_definition |
	record_type_definition
	;

concurrent_assertion_statement =
	[ label, ":" ], assertion_statement, ";"
	;

concurrent_procedure_call =
	[ label, ":" ], procedure_call_statement, ";"
	;

concurrent_signal_assignment_statement =
	[ label, ":" ], conditional_signal_assignment |
	[ label, ":" ], select_signal_assignment
	;

concurrent_statement =
	block_statement |
	process_statement |
	concurrent_procedure_call |
	concurrent_assertion_statement |
	concurrent_signal_assignment_statement |
	component_instantiation_statement |
	generate_statement
	;

condition =
	boolean_expression
	;

condition_clause =
	"until", condition
	;

conditional_signal_assignment =
	target, "<=", options, conditional_waveforms, ";"
	;

conditional_waveforms =
	{ waveform, "when", condition, "else" }, waveform
	;

configuration_declaration =
	"configuration", identifier, "of", entity_name, "is", configuration_declarative_part,
		block_configuration, "end", [ configuration_simple_name ], ";"
	;

configuration_declarative_item =
	use_clause |
	attribute_specification
	;

configuration_declarative_part =
	{ configuration_declarative_item }
	;

configuration_item =
	block_configuration |
	component_configuration
	;

configuration_specification =
	"for", component_specification, binding_indication, ";"
	;

constant_declaration =
	"constant", identifier_list, ":", subtype_indication, [ ":=", expression ], ";"
	;

constrained_array_definition =
	"array", index_constraint, "of", element_subtype_indication
	;

constraint =
	range_constraint |
	index_constraint
	;

context_clause =
	{ context_item }
	;

context_item =
	library_item |
	use_clause
	;

decimal_literal =
	integer, [ ".", integer ], [ exponent ]
	;

declaration =
	type_declaration |
	subtype_declaration |
	object_declaration |
	file_declaration |
	interface_declaration |
	alias_declaration |
	attribute_declaration |
	component_declaration |
	entity_declaration |
	configuration_declaration |
	subprogram_declaration |
	package_declaration
	;

design_file =
	design_unit, { design_unit }
	;

design_unit =
	context_clause, library_unit
	;

designation =
	identifier |
	operator_symbol
	;

direction =
	"to" | "downto"
	;

disconnection_specification =
	"disconnect", guarded_signal_specification, "after", time_expression, ";"
	;

discrete_range =
	discrete_subtype_indication |
	range
	;

element_association =
	[ choices, "=>" ], expression
	;

element_declaration =
	identifier_list, ":", element_subtype_definition, ";"
	;

element_subtype_definition =
	subtype_definition
	;

entity_aspect =
	"entity", entity_name, [ "(", architecture_identifier, ")" ] |
	"configuration", configuration_name |
	"open"
	;

entity_class =
	"entity" |
	"architecture" |
	"configuration" |
	"procedure" |
	"function" |
	"package" |
	"type" |
	"subtype" |
	"constant" |
	"signal" |
	"variable" |
	"component" |
	"label"
	;

entity_declaration =
	"entity", identifier, "is", entity_header, entity_declarative_part,
		[ "begin", entity_statement_part ], "end", [ entity_simple_name ], ";"
	;

entity_declarative_item =
	subprogram_declaration |
	subprogram_body |
	type_declaration |
	subtype_declaration |
	constant_declaration |
	signal_declaration |
	shared_variable_declaration |
	file_declaration |
	alias_declaration |
	attribute_declaration |
	attribute_specification |
	disconnection_specification |
	use_clause
	;

entity_declarative_part =
	{ entity_declarative_item }
	;

entity_designation =
	simple_name |
	operator_symbol
	;

entity_header =
	[ formal_generic_clause ], [ formal_port_clause ]
	;

entity_name_list =
	entity_designator, { ",", entity_designator } |
	"others" |
	"all"
	;

entity_specification =
	entity_name_list, ":", entity_class
	;

entity_statement =
	concurrent_assertion_statement |
	passive_concurrent_procedure_call |
	passive_process_statement
	;

entity_statement_part =
	{ entity_statement }
	;

enumeration_literal =
	identifier |
	character_literal
	;

enumeration_type_definition =
	"(", enumeration_literal, { ",", enumeration_literal }, ")"
	;

exit_statement =
	"exit", [ loop_label ], [ "when", condition ], ";"
	;

exponent =
	"E", [ "+" ], integer |
	"E", "-", integer
	;

expression =
	relation, { "and", relation } |
	relation, { "or", relation } |
	relation, { "xor", relation } |
	relation, [ "nand", relation ] |
	relation, [ "nor", relation ]
	;


extended_digit =
	digit |
	letter
	;

factor =
	primary, [ "**", primary ] |
	"abs", primary |
	"not", primary
	;

file_declaration =
	"file", identifier, ":", subtype_indication, "is", [ mode ], file_logical_name, ";"
	;

file_logical_name =
	string_expression
	;

file_type_definition =
	"file", "of", type_mark
	;

floating_type_definition =
	range_constraint
	;

formal_designator =
	generic_name |
	port_name |
	parameter_name
	;

formal_parameter_list =
	parameter_interface_list
	;

formal_part =
	formal_designator |
	function_name, "(", formal_designator, ")"
	;

full_type_declaration =
	"type", identifier, "is", type_definition, ";"
	;

function_call =
	function_name, [ "(", actual_parameter_part, ")" ]
	;

generate_statement =
	generate_label, ":", generation_scheme, "generate",
		{ concurrent_statement }, "end", "generate", [ generate_label ], ";"
	;

generation_scheme =
	"for", generate_parameter_statement |
	"if", condition
	;

generic_clause =
	"generic", "(", generic_list, ")", ";"
	;


generic_list =
	generic_interface_list
	;

generic_map_aspect =
	"generic", "map", "(", generic_interface_list, ")"
	;

graphic_character =
	basic_graphic_character |
	lower_case_letter |
	other_special_character
	;

guarded_signal_specification =
	guarded_signal_list, ":", type_mark
	;

identifier =
	letter, { [ underline ], letter_or_digit }
	;

identifier_list =
	identifier, { ",", identifier }
	;

if_statement =
	"if", condition, "then", sequence_of_statements,
		{ "elsif", condition, "then", sequence_of_statements },
		[ "else", sequence_of_statements ], "end", "if", ";"
	;

incomplete_type_declaration =
	"type", identifier, ";"
	;

index_constraint =
	"(", discrete_range, { ",", discrete_range }, ")"
	;

index_specification =
	discrete_range |
	static_expression
	;

index_subtype_definition =
	type_mark, "range", "<>"
	;

indexed_name =
	prefix, "(", expression, { ",", expression }, ")"
	;

instantiation_list =
	instantiation_label, { instantiation_label } |
	"others" |
	"all"
	;

integer =
	digit, { [ underline ], digit }
	;

integer_type_definition =
	range_constraint
	;

interface_constant_declaration =
	[ "constant" ], identifier_list, ":", [ "in" ], subtype_indication, [ ":=", static_expression ]
	;

interface_declaration =
	interface_constant_declaration |
	interface_signal_declaration |
	interface_variable_declaration
	;

interface_element =
	interface_declaration
	;

interface_list =
	interface_element, { ";", interface_element }
	;

interface_signal_declaration =
	[ "signal" ], identifier_list, ":", [ mode ], subtype_indication, [ "bus" ], [ ":=", static_expression ]
	;

interface_variable_declaration =
	[ "variable" ], identifier_list, ":", [ mode ], subtype_indication, [ ":=", static_expression ]
	;

iteration_scheme =
	"while", condition |
	"for", loop_parameter_specification
	;

label =
	identifier
	;

letter =
	upper_case_letter |
	lower_case_letter
	;

letter_or_digit =
	letter |
	digit
	;

library_clause =
	"library", logical_name_list, ";"
	;

library_unit =
	primary_unit |
	secondary_unit
	;

literal =
	numeric_literal |
	enumeration_literal |
	string_literal |
	bit_string_literal |
	"null"
	;

logical_name =
	identifier
	;

logical_name_list =
	logical_name, { ",", logical_name }
	;

logical_operator =
	"and" | "or" | "nand" | "nor" | "xor"
	;

loop_statement =
	[ loop_label, ":" ], [ iteration_scheme ], "loop", sequence_of_statements,
		"end", "loop", [ loop_label ], ";"
	;

miscellaneous_operator =
	"**" | "abs" | "not"
	;

mode =
	"in" | "out" | "inout" | "buffer" | "linkage"
	;

multiplying_operator =
	"*" | "/" | "mod" | "rem"
	;

name =
	simple_name |
	operator_symbol |
	selected_name |
	indexed_name |
	slice_name |
	attribute_name
	;

next_statement =
	"next", [ loop_label ], [ "when", condition ], ";"
	;

null_statement =
	"null", ";"
	;

numeric_literal =
	abstract_literal |
	physical_literal
	;

object_declaration =
	constant_declaration |
	signal_declaration |
	variable_declaration
	;

operator_symbol =
	string_literal
	;

options =
	[ "guarded" ], [ "transport" ]
	;

package_body =
	"package", "body", package_simple_name, "is", package_body_declarative_part, "end",
		[ package_simple_name ], ";"
	;

package_body_declarative_item =
	subprogram_declaration |
	subprogram_body |
	type_declaration |
	subtype_declaration |
	constant_declaration |
	file_declaration |
	alias_declaration |
	use_clause
	;

package_body_declarative_part =
	{ package_body_declarative_item }
	;

package_declaration =
	"package", identifier, "is", package_declarative_part, "end",
		[ package_simple_name ], ";"
	;

package_declarative_item =
	subprogram_declaration |
	type_declaration |
	subtype_declaration |
	constant_declaration |
	signal_declaration |
	file_declaration |
	alias_declaration |
	component_declaration |
	attribute_declaration |
	attribute_specification |
	disconnection_specification |
	use_clause
	;

package_declarative_part =
	{ package_declarative_item }
	;

parameter_specification =
	identifier, "in", discrete_range
	;

physical_literal =
	[ abstract_literal ], unit_name
	;

physical_type_definition =
	range_constraint, "units", base_unit_declaration, { secondary_unit_declaration },
		"end", "units"
	;

port_clause =
	"port", "(", port_list, ")", ";"
	;

port_list =
	port_interface_list
	;

port_map_aspect =
	"port", "map", "(", port_association_list, ")"
	;

prefix =
	name |
	function_call
	;

primary =
	name |
	literal |
	aggregate |
	function_call |
	qualified_expression |
	type_conversion |
	allocator |
	"(", expression, ")"
	;

primary_unit =
	entity_declaration |
	configuration_declaration |
	package_declaration
	;

procedure_call_statement =
	procedure_name, [ "(", actual_parameter_part, ")" ], ";"
	;

process_declarative_item =
	subprogram_declaration |
	subprogram_body |
	type_declaration |
	subtype_declaration |
	constant_declaration |
	variable_declaration |
	file_declaration |
	alias_declaration |
	attribute_declaration |
	attribute_specification |
	use_clause
	;

process_declarative_part =
	{ process_declarative_item }
	;

process_statement =
	[ process_label, ":" ], "process", [ "(", sensitivity_list, ")" ],
		process_declarative_part, "begin", process_statement_part, "end",
		"process", [ process_label ], ";"
	;

process_statement_part =
	{ sequential_statement }
	;

qualified_expression =
	type_mark, "'", "(", expression, ")" |
	type_mark, "'", aggregate
	;

range =
	range_attribute_name |
	simple_expression, direction, simple_expression
	;

range_constraint =
	"range", range
	;

record_type_definition =
	"record", element_declaration, { element_declaration }, "end", "record"
	;

relation =
	simple_expression, [ relational_operator, simple_expression ]
	;

relational_operator =
	"=" | "/=" | "<" | "<=" | ">" | ">="
	;

return_statement =
	"return", [ expression ], ";"
	;

scalar_type_definition =
	enumeration_type_definition |
	integer_type_definition |
	floating_type_definition |
	physical_type_definition
	;

secondary_unit =
	architecture_body |
	package_body
	;

secondary_unit_declaration =
	identifier, "=", physical_literal, ";"
	;

selected_name =
	prefix, ".", suffix
	;

selected_signal_assignment =
	"with", expression, "select", target, "<=", options, selected_waveforms, ";"
	;

selected_waveforms =
	{ waveform, "when", choices, "," }, waveform, "when", choices
	;

sensitivity_clause =
	"on", sensitivity_list
	;

sensitivity_list =
	signal_name, { ",", signal_name }
	;

sequence_of_statements =
	{ sequential_statement }
	;

sequential_statement =
	wait_statement |
	assertion_statement |
	signal_assignment_statement |
	variable_assignment_statement |
	procedure_call_statement |
	if_statement |
	case_statement |
	loop_statement |
	next_statement |
	exit_statement |
	return_statement |
	null_statement
	;

sign =
	"+" | "-"
	;

signal_assignment_statement =
	target, "<=", [ transport ], waveform, ";"
	;

signal_declaration =
	"signal", identifier_list, ":", subtype_indication, [ signal_kind ], [ ":=", expression ], ";"
	;

signal_kind =
	"register" | "bus"
	;

signal_list =
	signal_name, { ",", signal_name } |
	"others" |
	"all"
	;

simple_expression =
	[ sign ], term, { adding_operator, term }
	;

simple_name =
	identifier
	;

slice_name =
	prefix, "(", discrete_range, ")"
	;

string_literal =
	'"', { graphic_character }, '"'
	;

subprogram_body =
	subprogram_specification, "is", subprogram_declarative_part, "begin", subprogram_statement_part,
		"end", [ designator ], ";"
	;

subprogram_declaration =
	subprogram_specification, ";"
	;

subprogram_declarative_item =
	subprogram_declaration |
	subprogram_body |
	type_declaration |
	subtype_declaration |
	constant_declaration |
	variable_declaration |
	file_declaration |
	alias_declaration |
	attribute_declaration |
	attribute_specification |
	use_clause
	;

subprogram_declarative_part =
	{ subprogram_declarative_item }
	;


subprogram_specification =
	"procedure", designator, [ "(", formal_parameter_list, ")" ] |
	"function", designator, [ "(", formal_parameter_list, ")" ], "return", type_mark
	;

subprogram_statement_part =
	{ sequential_statement }
	;

subtype_declaration =
	"subtype", identifier, "is", subtype_indication, ";"
	;

subtype_indication =
	[ resolution_function_name ], type_mark, [ constraint ]
	;

suffix =
	simple_name |
	character_literal |
	operator_symbol |
	"all"
	;

target =
	name |
	aggregate
	;

term =
	factor, { multiplying_operator, factor }
	;

timeout_clause =
	"for", time_expression
	;

type_conversion =
	type_mark, "(", expression, ")"
	;

type_declaration =
	full_type_declaration |
	incomplete_type_declaration
	;

type_definition =
	scalar_type_definition |
	composite_type_definition |
	access_type_definition |
	file_type_definition
	;

type_mark =
	type_name |
	subtype_name
	;

unconstrained_array_definition =
	"array", "(", index_subtype_definition, { ",", index_subtype_definition }, ")",
		"of", element_subtype_indication
	;

use_clause =
	"use", selected_name, { ",", selected_name }, ";"
	;

variable_assignment_statement =
	target, ":=", expression, ";"
	;

variable_declaration =
	"variable", identifier_list, ":", subtype_indication, [ ":=", expression ], ";"
	;

wait_statement =
	"wait", [ sensitivity_clause ], [ condition_clause ], [ timeout_clause ], ";"
	;

waveform =
	waveform_element, { ",", waveform_element }
	;

waveform_element =
	value_expression, [ "after", time_expression ] |
	"null", [ "after", time_expression ]
	;

(*
	Keywords:
		abs
		access
		after
		alias
		all
		and
		architecture
		array
		assert
		attribute
		begin
		block
		body
		buffer
		bus
		case
		component
		configuration
		constant
		disconnect
		downto
		else
		elsif
		end
		entity
		exit
		file
		for
		function
		generate
		generic
		guarded
		if
		in
		inout
		is
		label
		library
		linkage
		loop
		map
		mod
		nand
		new
		next
		nor
		not
		null
		of
		on
		open
		or
		others
		out
		package
		port
		procedure
		process
		range
		record
		register
		rem
		report
		return
		select
		severity
		signal
		subtype
		then
		to
		transport
		type
		units
		until
		use
		variable
		wait
		when
		while
		with
		xor
*)
