(* SPDX-License-Identifier: BSD-3-Clause *)
(* EBNF grammar for Verilog-AMS 2009 *)
(*
	Verilog-AMS 2009 is based on IEEE 1364-2005 (Verilog 2005)

	NOTE 1: Function statements are limited by the rules of ยง4.7.1.
	NOTE 2: Embedded spaces are illegal.
	NOTE 3: A `simple_identifier` shall start with [a-zA-Z_], shall have at least one character,
			and shall not have any spaces.
	NOTE 4: The dollar (`$`) character in a `system_function_identifier` or `system_task_identifier`
			shall not be followed by `white_space`. A `system_function_identifier` or
			`system_task_identifier` shall not be escaped.
	NOTE 5: EOF (End Of File) is valid white space
*)

white_space =
	" " | "\t" | "\n"
	;

variable_identifier =
	identifier
	;

udp_instance_identifier =
	identifier
	;

udp_identifier =
	identifier
	;

topmodule_identifier =
	identifier
	;

text_macro_identifier =
	identifier |
	"__VAMS_ENABLE__" |
	"__VAMS_COMPACT_MODELING__"
	;

terminal_identifier =
	identifier
	;

task_identifier =
	identifier
	;

(* See NOTE 4 *)
system_task_identifier =
	"$", a-zA-Z0-9_$, { a-zA-Z0-9_$ }
	;

system_parameter_identifier =
	"$", a-zA-Z0-9_$, { a-zA-Z0-9_$ }
	;

(* See NOTE 4 *)
system_function_identifier =
	"$", a-zA-Z0-9_$, { a-zA-Z0-9_$ }
	;

specparam_identifier =
	identifier
	;

(* See NOTE 3 *)
simple_identifier =
	a-zA-Z_, { a-zA-Z0-9_$ }
	;

real_identifier =
	identifier
	;

port_identifier =
	identifier
	;

paramset_identifier =
	identifier
	;

parameter_identifier =
	identifier
	;

output_port_identifier =
	identifier
	;

net_identifier =
	identifier
	;

nature_attribute_identifier =
	"abstol" | "access" | "ddt_nature" | "idt_nature" | "units" | identifier
	;

nature_access_identifier =
	identifier
	;

nature_identifier =
	identifier
	;

module_parameter_identifier =
	identifier
	;

module_or_paramset_identifier =
	module_identifier |
	paramset_identifier
	;

module_instance_identifier =
	identifier
	;

module_identifier =
	identifier
	;

library_identifier =
	identifier
	;

instance_identifier =
	identifier
	;

input_port_identifier =
	identifier
	;

inout_port_identifier =
	identifier
	;

identifier =
	simple_identifier |
	escaped_identifier
	;

hierarchical_task_identifier =
	hierarchical_identifier
	;

hierarchical_variable_identifier =
	hierarchical_identifier
	;

hierarchial_port_identifier =
	hierarchical_identifier
	;

hierarchical_parameter_identifier =
	hierarchical_identifier
	;

hierarchical_net_identifier =
	hierarchical_identifier
	;

hierarchical_identifier =
	{ identifier, [ "[", constant_expression, "]" ], "." }, identifier
	;

hierarchical_function_identifier =
	hierarchical_identifier
	;

hierarchical_event_identifier =
	hierarchical_identifier
	;

hierarchical_branch_identifier =
	hierarchical_identifier
	;

hierarchical_block_identifier =
	hierarchical_identifier
	;

genvar_identifier =
	identifier
	;

generate_block_identifier =
	identifier
	;

gate_instance_identifier =
	identifier
	;

function_identifier =
	identifier
	;

event_identifier =
	identifier
	;

escaped_identifier =
	"\\", { ? Any_ASCII_character_except_white_space ? }, white_space
	;

discipline_identifier =
	identifier
	;

connectrules_identifier =
	identifier
	;

connectmodule_identifier =
	module_identifier
	;

config_identifier =
	identifier
	;

cell_identifier =
	identifier
	;

branch_identifier =
	identifier
	;

block_identifier =
	identifier
	;

analysis_identifier =
	identifier
	;

analog_system_function_identifier =
	system_function_identifier
	;

analog_system_task_identifier =
	system_task_identifier
	;

analog_function_identifier =
	identifier
	;

analog_block_identifier =
	block_identifier
	;

comment_text =
	{ ? Any_ASCII_character ? }
	;

block_comment =
	"/*", comment_text, "*/"
 	;

one_line_comment =
	"//", comment_text, "\n"
	;

comment =
	one_line_comment |
	block_comment
	;

attr_name =
	identifier
	;

attr_spec =
	attr_name, [ "=", constant_expression ]
	;

attribute_instance =
	"(*", attr_spec, { ",", attr_spec }, "*)"
	;

net_reference =
	hierarchical_net_identifier |
	hierarchical_net_identifier, "[", analog_range_expression, "]" |
	hierarchical_port_identifier |
	hierarchical_port_identifier, "[", analog_range_expression, "]"
	;

variable_reference =
	variable_identifier |
	variable_identifier, "[", analog_expression, "]", { "[", analog_expression, "]" } |
	real_identifier |
	real_identifier, "[", analog_expression, "]", { "[", analog_expression, "]" }
	;

parameter_reference =
	parameter_identifier |
	parameter_identifier, "[", analog_expression, "]"
	;

branch_reference =
	hierarchical_branch_identifier |
	hierarchical_branch_identifier, "[", constant_expression, "]"
	;

analog_net_reference =
	port_identifier |
	port_identifier, "[", constant_expression, "]" |
	net_identifier |
	net_identifier, "[", constant_expression, "]"
	;

analog_port_reference =
	port_identifier |
	port_identifier, "[", constant_expression, "]"
	;

nature_attribute_reference =
	net_identifier, ".", potential_or_flow, ".", nature_access_identifier
	;

string =
	'"', { ? Any_ASCII_Characters ? }, '"'
	;

z_digit =
	"z" | "Z" | "?"
	;

x_digit =
	"x" | "X"
	;

hex_digit =
	x_digit | z_digit | "0" | "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9" |
	"a" | "b" | "c" | "d" | "e" | "f" |
	"A" | "B" | "C" | "D" | "E" | "F"
	;

octal_digit =
	x_digit | z_digit | "0" | "1" | "2" | "3" | "4" | "5" | "6" | "7"
	;

binary_digit =
	x_digit | z_digit | "0" | "1"
	;

decimal_digit =
	"0" | "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9"
	;

non_zero_decimal_digit =
	"1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9"
	;

(* See NOTE 2 *)
hex_base =
	"'", [ "s" | "S" ], "h" |
	"'", [ "s" | "S" ], "H"
	;

(* See NOTE 2 *)
octal_base =
	"'", [ "s" | "S" ], "o" |
	"'", [ "s" | "S" ], "O"
	;

(* See NOTE 2 *)
binary_base =
	"'", [ "s" | "S" ], "b" |
	"'", [ "s" | "S" ], "B"
	;

(* See NOTE 2 *)
decimal_base =
	"'", [ "s" | "S" ], "d" |
	"'", [ "s" | "S" ], "D"
	;

(* See NOTE 2 *)
hex_value =
	hex_digit, { "_" | hex_digit }
	;

(* See NOTE 2 *)
octal_value =
	octal_digit, { "_" | octal_digit }
	;

(* See NOTE 2 *)
binary_value =
	binary_digit, { "_" | binary_digit }
	;

(* See NOTE 2 *)
unsigned_number =
	decimal_digit, { "_" | decimal_digit }
	;

(* See NOTE 2 *)
non_zero_unsigned_number =
	non_zero_decimal_digit, { "_" | decimal_digit }
	;

size =
	non_zero_unsigned_number
	;

sign =
	"+" | "-"
	;

hex_number =
	[ size ], hex_base, hex_value
	;

octal_number =
	[ size ], octal_base, octal_value
	;

binary_number =
	[ size ], binary_base, binary_value
	;

decimal_number =
	unsigned_number |
	[ size ], decimal_base, unsigned_number |
	[ size ], decimal_base, x_digit, { "_" } |
	[ size ], decimal_base, z_digit, { "_" }
	;

scale_factor =
	"T" | "G" | "M" | "K" | "k" | "m" | "u" | "n" | "p" | "f" | "a"
	;

exp =
	"e" | "E"
	;

(* See NOTE 2 *)
real_number =
	unsigned_number, ".", unsigned_number |
	unsigned_number, [ ".", unsigned_number ], exp, [ sign ], unsigned_number |
	unsigned_number, [ ".", unsigned_number ], scale_factor
	;

number =
	decimal_number |
	octal_number |
	binary_number |
	hex_number |
	real_number
	;

binary_module_path_operator =
	"==" | "!=" | "&&" | "||" | "&" | "|" | "^" | "^~" | "~^"
	;

unary_module_path_operator =
	"!" | "~" | "&" | "~&" | "|" | "~|" | "^" | "~^" | "^~"
	;

binary_operator =
	"+" | "-" | "*" | "/" | "%" | "==" | "!=" | "===" | "!== "| "&&" | "||" | "**" |
	"<" | "<=" | ">" | ">=" | "&" | "|" | "^" | "^~" | "~^" | ">>" | "<<" | ">>>" | "<<<"
	;

unary_operator =
	"+" | "-" | "!" | "~" | "&" | "~&" | "|" | "~|" | "^" | "~^" | "^~"
	;

variable_lvalue =
	hierarchical_variable_identifier, [ { "[", expression, "]" }, "[", range_expression, "]" ] |
	"{", variable_lvalue, { ",", variable_lvalue }, "}"
	;

net_lvalue =
	hierarchical_net_identifier, [ { "[", constant_expression, "]" }, "[", constant_range_expression, "]" ] |
	"{", net_lvalue, { ",", net_lvalue }, "}"
	;

branch_lvalue =
	branch_probe_function_call
	;

analog_variable_lvalue =
	variable_identifier |
	variable_identifier, "[", analog_expression, "]", { "[", analog_expression, "]" }
	;

primary =
	number |
	hierarchical_identifier, [ { "[", expression, "]" }, "[", range_expression, "]" ] |
	concatenation |
	multiple_concatenation |
	function_call |
	system_function_call |
	"(", mintypmax_expression, ")" |
	string |
	branch_probe_function_call |
	port_probe_function_call |
	nature_attribute_reference |
	analog_function_call |
	analog_built_in_function_call
	;

module_path_primary =
	number |
	identifier |
	module_path_concatenation |
	module_path_multiple_concatenation |
	function_call |
	system_function_call |
	"(", module_path_mintypmax_expression, ")"
	;

constant_primary =
	number |
	parameter_identifier, [ "[", constant_range_expression, "]" ] |
	specparam_identifier, [ "[", constant_range_expression, "]" ] |
	constant_concatenation |
	constant_multiple_concatenation |
	constant_function_call |
	constant_system_function_call |
	constant_analog_built_in_function_call |
	"(", constant_mintypmax_expression, ")" |
	string |
	system_parameter_identifier |
	nature_attribute_reference |
	constant_analog_function_call
	;

analog_primary =
	number |
	analog_concatenation |
	analog_multiple_concatenation |
	variable_reference |
	net_reference |
	genvar_identifier |
	parameter_reference |
	nature_attribute_reference |
	branch_probe_function_call |
	port_probe_function_call |
	analog_function_call |
	analog_system_function_call |
	analog_built_in_function_call |
	analog_filter_function_call |
	analog_small_signal_function_call |
	analysis_function_call |
	"(", analog_expression, ")"
	;

width_constant_expression =
	constant_expression
	;

range_expression =
	expression |
	msb_constant_expression, ":", lsb_constant_expression |
	base_expression, "+:", width_constant_expression |
	base_expression, "-:", width_constant_expression
	;

nature_attribute_expression =
	constant_expression	|
	nature_identifier |
	nature_access_identifier
	;

msb_constant_expression =
	constant_expression
	;

module_path_mintypmax_expression =
	module_path_expression |
	module_path_expression, ":", module_path_expression, ":", module_path_expression
	;

module_path_expression =
	module_path_primary |
	unary_module_path_operator, { attribute_instance }, module_path_primary |
	module_path_expression, binary_module_path_operator, { attribute_instance }, module_path_expression |
	module_path_conditional_expression
	;

module_path_conditional_expression =
	module_path_expression, "?", { attribute_instance }, module_path_expression, ":", module_path_expression
	;

mintypmax_expression =
	expression |
	expression, ":", expression, ":", expression
	;

lsb_constant_expression =
	constant_expression
	;

indirect_expression =
	branch_probe_function_call |
	port_probe_function_call |
	"ddt", "(", branch_probe_function_call, [ ",", abstol_expression ], ")" |
	"ddt", "(", port_probe_function_call, [ ",", abstol_expression ], ")" |
	"idt", "(", branch_probe_function_call, [ ",", analog_expression, [ ",", analog_expression, [ ",", abstol_expression ] ] ], ")" |
	"idt", "(", port_probe_function_call, [ ",", analog_expression, [ ",", analog_expression, [ ",", abstol_expression ] ] ], ")" |
	"idtmod", "(", branch_probe_function_call, [ ",", analog_expression, [ ",", analog_expression, [ ",", analog_expression, [ ",", abstol_expression ] ] ] ], ")" |
	"idtmod", "(", port_probe_function_call, [ ",", analog_expression, [ ",", analog_expression, [ ",", analog_expression, [ ",", abstol_expression ] ] ] ], ")"
	;

expression3 =
	expression
	;

expression2 =
	expression
	;

expression1 =
	expression
	;

expression =
	primary |
	unary_operator, { attribute_instance }, primary |
	expression, binary_operator, { attribute_instance }, expression |
	conditional_expression
	;

dimension_constant_expression =
	constant_expression
	;

constant_range_expression =
	constant_expression |
	msb_constant_expression, ":", lsb_constant_expression |
	constant_base_expression, "+:", width_constant_expression |
	constant_base_expression, "-:", width_constant_expression
	;

constant_mintypmax_expression =
	constant_expression |
	constant_expression, ":", constant_expression, ":", constant_expression
	;

analysis_or_constant_expression =
	constant_primary |
	analysis_function_call |
	unary_operator, { attribute_instance }, analysis_or_constant_primary |
	analysis_or_constant_expression, binary_operator, { attribute_instance }, analysis_constant_expression |
	analysis_or_constant_expression, "?", { attribute_instance }, analysis_or_constant_expression, ":", analysis_or_constant_expression
	;

constant_expression =
	constant_primary |
	unary_operator, { attribute_instance }, constant_primary |
	constant_expression, binary_operator, { attribute_instance }, constant_expression |
	constant_expression, "?", { attribute_instance }, constant_expression, ":", constant_expression
	;

constant_expression_or_null =
	[ constant_expression ]
	;

constant_base_expression =
	constant_expression
	;

conditional_expression =
	expression1, "?", { attribute_instance }, expression2, ":", expression3
	;

base_expression =
	expression
	;

analog_expression =
	analog_primary |
	unary_operator, { attribute_instance }, analog_primary |
	analog_expression, binary_operator, { attribute_instance }, analog_expression |
	analog_conditional_expression |
	string
	;

analog_expression_or_null =
	[ analog_expression ]
	;

analog_range_expression =
	analog_expression |
	msb_constant_expression, ":", lsb_constant_expression
	;

analog_conditional_statement =
	analog_expression, "?", { attribute_instance }, analog_expression, ":", analog_expression
	;

abstol_expression =
	constant_expression |
	nature_identifier
	;

system_function_call =
	system_function_identifier, "(", expression, { ",", expression }, ")"
	;

function_call =
	hierarchical_function_identifier, { attribute_instance }, "(", expression, { ",", expression }, ")"
	;

constant_analog_built_in_function_call =
	analog_built_in_function_name, "(", constant_expression, [ ",", constant_expression ], ")"
	;

constant_system_function_call =
	system_function_identifier, "(", constant_expression, { ",", constant_expression }, ")"
	;

constant_function_call =
	function_identifier, { attribute_instance }, "(", constant_expression, { ",", constant_expression }, ")"
	;

constant_analog_function_call =
	function_identifier, { attribute_instance }, "(", constant_expression, { ",", constant_expression }, ")"
	;

constant_analog_function_call =
	analog_function_identifier, { attribute_instance }, "(", constant_expression, { ",", constant_expression }, ")"
	;

port_probe_function_call =
	nature_attribute_identifier, "(", "<", analog_port_reference, ">", ")"
	;

branch_probe_function_call =
	nature_attribute_identifier, "(", branch_reference, ")" |
	nature_attribute_identifier, "(", analog_net_reference, [ ",", analog_net_reference ], ")"
	;

zi_filter_name =
	"zi_zp" | "zi_zd" | "zi_np" | "zi_nd"
	;

laplace_filter_name =
	"laplace_zd" | "laplace_zp" | "laplace_np" | "laplace_nd"
	;

noise_table_input_arg =
	parameter_identifier |
	parameter_identifier, "[", msb_constant_expression, ":", lsb_constant_expression, "]" |
	string |
	constant_arrayinit
	;

analog_small_signal_function_call =
	"ac_stim", "(", [ '"', analysis_identifier, '"', [ ",", analog_expression, [ ",", analog_expression ] ] ], ")" |
	"white_noise", "(", analog_expression, [ ",", string ], ")" |
	"flicker_noise", "(", analog_expression, ",", analog_expression, [ ",", string ], ")" |
	"noise_table", "(", noise_table_input_arg, [ ",", string ], ")"
	;

analog_filter_function_call =
	"ddt", "(", analog_expression, [ ",", abstol_expression, ], ")" |
	"ddx", "(", analog_expression, ",", branch_probe_function_call, ")" |
	"idt", "(", analog_expression, [ ",", analog_expression, [ ",", analog_expression, [ ",", abstol_expression ] ] ], ")" |
	"idtmod", "(", analog_expression, [ ",", analog_expression, [ ",", analog_expression, [ ",", analog_expression, [ ",", abstol_expression ] ] ] ], ")" |
	"absdelay", "(", analog_expression, ",", analog_expression, [ ",", constant_expression ], ")" |
	"transition", "(", analog_expression, [ ",", analog_expression, [ ",", analog_expression, [ ",", analog_expression, [ ",", constant_expression ] ] ] ], ")" |
	"slew", "(", analog_expression, [ ",", analog_expression, [ ",", analog_expression ] ], ")" |
	"last_crossing", "(", analog_expression, [ ",", analog_expression ], ")" |
	"limexp", "(", analog_expression, ")" |
	laplace_filter_name, "(", analog_expression, ",", [ analog_filter_function_arg ], ",", [ analog_filter_function_arg ], [ ",", constant_expression ], ")" |
	zi_filter_name, "(", analog_expression, ",", [ analog_filter_function_arg ], ",", [ analog_filter_function_arg ], ",", constant_expression, [ ",", analog_expression, [ ",", constant_expression ] ], ")"
	;

analysis_function_call =
	"analysis", "(", '"', analysis_identifier, '"', { ",", '"', analysis_identifier, '"' }, ")"
	;

analog_built_in_function_name =
	"ln" | "log" | "exp" | "sqrt" | "min" | "max" | "abs" | "pow" | "floor" | "ceil" |
	"sin" | "cos" | "tan" | "asin" | "acos" | "atan" | "atan2" |
	"hylpot" | "sinh" | "cosh" | "tanh" | "asinh" | "acosh" | "atanh"
	;

analog_built_in_function_call =
	analog_built_in_function_name, "(", analog_expression, [ ",", analog_expression ], ")"
	;

analog_system_function_call =
	analog_system_function_identifier, [ "(", [ analog_expression ], { ",", [ analog_expression ] }, ")" ]
	;

analog_function_call =
	analog_function_identifier, { attribute_instance }, "(", analog_expression, { ",", analog_expression }, ")"
	;

constant_optional_arrayinit =
	"'", "{", [ constant_expression ], { ",", [ constant_expression ] }, "}"
	;

constant_arrayinit =
	"'", "{", constant_expression, { ",", constant_expression }, "}"
	;

multiple_concatenation =
	"{", constant_expression, concatenation, "}"
	;

module_path_multiple_concatenation =
	"{", constant_expression, module_path_concatenation, "}"
	;

module_path_concatenation =
	"{", module_path_expression, { ",", module_path_expression }, "}"
	;

constant_multiple_concatenation =
	"{", constant_expression, constant_concatenation, "}"
	;

constant_concatenation =
	"{", constant_expression, { ",", constant_expression }, "}"
	;

concatenation =
	"{", expression, { ",", expression }, "}"
	;

analog_filter_function_arg =
	parameter_identifier |
	parameter_identifier, "[", msb_constant_expression, ":", lsb_constant_expression, "]" |
	constant_optional_arrayinit
	;

analog_multiple_concatenation =
	"{", constant_expression, analog_concatenation, "}"
	;

analog_concatenation =
	"{", analog_expression, { ",", analog_expression }, "}"
	;

scalar_constant =
	"1'b0" | "1'b1" | "1'B0" | "1'B1" | "'b0" | "'b1" | "'B0" | "'B1" | "1" | "0"
	;

scalar_timing_check_condition =
	expression |
	"~", expression |
	expression, "==", scalar_constant |
	expression, "!=", scalar_constant |
	expression, "===", scalar_constant |
	expression, "!==", scalar_constant
	;

timing_check_condition =
	scalar_timing_check_condition |
	"(", scalar_timing_check_condition, ")"
	;

z_or_x =
	"x" | "X" | "z" | "Z"
	;

zero_or_one =
	"0" | "1"
	;

(* See NOTE 2 *)
edge_descriptor =
	"01" |
	"10" |
	z_or_x, zero_or_one |
	zero_or_one, z_or_x
	;

edge_control_specifier =
	"edge", "[", edge_descriptor, { ",", edge_descriptor }, "]"
	;

specify_terminal_descriptor =
	specify_input_terminal_descriptor |
	specify_output_terminal_descriptor
	;

timing_check_event_control =
	"posedge" |
	"negedge" |
	edge_control_specifier
	;

controlled_timing_check_event =
	timing_check_event_control, specify_terminal_descriptor, [ "&&&", timing_check_condition ]
	;

timing_check_event =
	[ timing_check_event_control ], specify_terminal_descriptor, [ "&&&", timing_check_condition ]
	;

end_edge_offset =
	mintypmax_expression
	;

event_based_flag =
	constant_expression
	;

notifier =
	variable_identifier
	;

reference_event =
	timing_check_event
	;

remain_active_flag =
	constant_expression
	;

stamptime_condition =
	mintypmax_expression
	;

start_edge_offset =
	mintypmax_expression
	;

threshold =
	constant_expression
	;

timing_check_limit =
	expression
	;

delayed_reference =
	terminal_identifier |
	terminal_identifier, "[", constant_mintypmax_expression, "]"
	;

delayed_data =
	terminal_identifier |
	terminal_identifier, "[", constant_mintypmax_expression, "]"
	;

data_event =
	timing_check_event
	;

controlled_reference_event =
	controlled_timing_check_event
	;

checktime_condition =
	mintypmax_expression
	;

setup_timing_check =
	"$setup", "(", data_event, ",", reference_event, ",", timing_check_limit, [ ",", [ notifier ] ], ")", ";"
	;

hold_timing_check =
	"$hold", "(", reference_event, ",", data_event, ",", timing_check_limit, [ ",", [ notifier ] ], ")", ";"
	;

setuphold_timing_check =
	"$setuphold", "(", reference_event, ",", data_event, ",", timing_check_limit, ",", timing_check_limit, [ ",", [ notifier ], [ ",", [ stamptime_condition ], [ ",", [ checktime_condition ], [ ",", [ delayed_reference ], [ ",", [ delayed_data ] ] ] ] ] ], ")", ";"
	;

recovery_timing_check =
	"$recovery", "(", reference_event, ",", data_event, ",", timing_check_limit, [ ",", [ notifier ] ], ")", ";"
	;

removal_timing_check =
	"$removal", "(", reference_event, ",", data_event, ",", timing_check_limit, [ ",", [ notifier ] ], ")", ";"
	;

recrem_timing_check =
	"$recrem", "(", reference_event, ",", data_event, ",", timing_check_limit, ",", timing_check_limit, [ ",", [ notifier ], [ ",", [ stamptime_condition ], [ ",", [ checktime_condition ], [ ",", [ delayed_reference ], [ ",", [ delayed_data ] ] ] ] ] ], ")", ";"
	;

skew_timing_check =
	"$skew", "(", reference_event, ",", data_event, ",", timing_check_limit, [ ",", [ notifier ] ], ")", ";"
	;

timeskew_timing_check =
	"$timeskew", "(", reference_event, ",", data_event, ",", timing_check_limit, [ ",", [ notifier ], [ ",", [ event_based_flag ], [ ",", [ remain_active_flag ] ] ] ], ")", ";"
	;

fullskew_timing_check =
	"$fullskew", "(", reference_event, ",", data_event, ",", timing_check_limit, [ ",", [ notifier ], [ ",", [ event_based_flag ], [ ",", [ remain_active_flag ] ] ] ], ")", ";"
	;

period_timing_check =
	"$period", "(", controlled_reference_event, ",", timing_check_limit, [ ",", [ notifier ] ], ")", ";"
	;

width_timing_check =
	"$width", "(", controlled_reference_event, ",", timing_check_limit, [ ",", threshold, [ ",", notifier ] ], ")", ";"
	;

nochange_timing_check =
	"$nochange", "(", reference_event, ",", data_event, ",", start_edge_offset, ",", end_edge_offset, [ ",", [ notifier ] ], ")", ";"
	;

system_timing_check =
	setup_timing_check |
	hold_timing_check |
	setuphold_timing_check |
	recovery_timing_check |
	removal_timing_check |
	recrem_timing_check |
	skew_timing_check |
	timeskew_timing_check |
	fullskew_timing_check |
	period_timing_check |
	width_timing_check |
	nochange_timing_check
	;

polarity_operator =
	"+" | "-"
	;

state_dependent_path_declaration =
	"if", "(", module_path_expression, ")", simple_path_declaration |
	"if", "(", module_path_expression, ")", edge_sensitive_path_declaration |
	"ifnone", simple_path_declaration
	;

edge_identifier =
	"posedge" | "negedge"
	;

data_source_expression =
	expression
	;

full_edge_sensitive_path_description =
	"(", [ edge_identifier ], list_of_path_inputs, "*>", "(", list_of_path_outputs, [ polarity_operator ], ":", data_source_expression, ")", ")"
	;

parallel_edge_sensitive_path_description =
	"(", [ edge_identifier ], specify_input_terminal_descriptor, "=>", "(", specify_output_terminal_descriptor, [ polarity_operator ], ":", data_source_expression, ")", ")"
	;

edge_sensitive_path_declaration =
	parallel_edge_sensitive_path_description, "=", path_delay_value |
	full_edge_sensitive_path_description, "=", path_delay_value
	;

path_delay_expression =
	constant_mintypmax_expression
	;

t_path_delay_expression =
	path_delay_expression
	;

trise_path_delay_expression =
	path_delay_expression
	;

tfall_path_delay_expression =
	path_delay_expression
	;

tz_path_delay_expression =
	path_delay_expression
	;

t01_path_delay_expression =
	path_delay_expression
	;

t10_path_delay_expression =
	path_delay_expression
	;

t0z_path_delay_expression =
	path_delay_expression
	;

tz1_path_delay_expression =
	path_delay_expression
	;

t1z_path_delay_expression =
	path_delay_expression
	;

tz0_path_delay_expression =
	path_delay_expression
	;

t0x_path_delay_expression =
	path_delay_expression
	;

tx1_path_delay_expression =
	path_delay_expression
	;

t1x_path_delay_expression =
	path_delay_expression
	;

tx0_path_delay_expression =
	path_delay_expression
	;

txz_path_delay_expression =
	path_delay_expression
	;

tzx_path_delay_expression =
	path_delay_expression
	;

list_of_path_delay_expressions =
	t_path_delay_expression |
	trise_path_delay_expression, ",", tfall_path_delay_expression |
	trise_path_delay_expression, ",", tfall_path_delay_expression, ",", tz_path_delay_expression |
	t01_path_delay_expression, ",", t10_path_delay_expression, ",", t0z_path_delay_expression, ",",
	tz1_path_delay_expression, ",", t1z_path_delay_expression, ",", tz0_path_delay_expression |
	t01_path_delay_expression, ",", t10_path_delay_expression, ",", t0z_path_delay_expression, ",",
	tz1_path_delay_expression, ",", t1z_path_delay_expression, ",", tz0_path_delay_expression, ",",
	t0x_path_delay_expression, ",", tx1_path_delay_expression, ",", t1x_path_delay_expression, ",",
	tx0_path_delay_expression, ",", txz_path_delay_expression, ",", tzx_path_delay_expression
	;

path_delay_value =
	list_of_path_delay_expressions |
	"(", list_of_path_delay_expressions, ")"
	;

output_identifier =
	output_port_identifier |
	inout_port_identifier
	;

input_identifier =
	input_port_identifier |
	inout_port_identifier
	;

specify_output_terminal_descriptor =
	output_identifier, [ "[", constant_range_expression, "]" ]
	;

specify_input_terminal_descriptor =
	input_identifier, [ "[", constant_range_expression, "]" ]
	;

list_of_path_outputs =
	specify_output_terminal_descriptor, { ",", specify_output_terminal_descriptor }
	;

list_of_path_inputs =
	specify_input_terminal_descriptor, { ",", specify_input_terminal_descriptor }
	;

full_path_description =
	"(", list_of_path_inputs, [ polarity_operator ], "*>", list_of_path_outputs, ")"
	;

parallel_path_description =
	"(", specify_input_terminal_descriptor, [ polarity_operator ], "=>", specify_output_terminal_descriptor, ")"
	;

simple_path_declaration =
	parallel_path_description, "=", path_delay_value |
	full_path_description, "=", path_delay_value
	;

path_declaration =
	simple_path_declaration, ";" |
	edge_sensitive_path_declaration, ";" |
	state_dependent_path_declaration, ";"
	;

showcancelled_declaration =
	"showcancelled", list_of_path_outputs, ";" |
	"noshowcancelled", list_of_path_outputs, ";"
	;

pulsestyle_declaration =
	"pulsestyle_onevent", list_of_path_outputs, ";" |
	"pulsestyle_ondetect", list_of_path_outputs, ";"
	;

specify_item =
	specparam_declaration |
	pulsestyle_declaration |
	showcancelled_declaration |
	path_declaration |
	system_timing_check
	;

specify_block =
	"specify", { specify_item }, "endspecify"
	;

indirect_contribution_statement =
	branch_lvalue, ":", indirect_expression, "==", analog_expression, ";"
	;

contribution_statement =
	branch_lvalue, "<+", analog_expression, ";"
	;

task_enable =
	hierarchical_task_identifier, [ "(", [ expression ], { ",", [ expression ] }, ")" ], ";"
	;

system_task_enable =
	system_task_identifier, [ "(", [ expression ], { ",", [ expression ] }, ")" ], ";"
	;

analog_system_task_enable =
	analog_system_task_identifier, [ "(", [ analog_expression ], { ",", [ analog_expression ] }, ")" ], ";"
	;

loop_statement =
	"forever", statement |
	"repeat", "(", expression, ")", statement |
	"while", "(", expression, ")", statement |
	"for", "(", variable_assignment, ";", expression, ";", variable_assignment, ")", statement
	;

analog_function_loop_statement =
	"repeat", "(", analog_expression, ")", analog_function_statement |
	"while", "(", analog_expression, ")", analog_function_statement |
	"for", "(", analog_variable_assignment, ";", analog_expression, ";", analog_variable_assignment, ")", analog_function_statement
	;

analog_loop_statement =
	"repeat", "(", analog_expression, ")", analog_statement |
	"while", "(", analog_expression, ")", analog_statement |
	"for", "(", analog_variable_assignment, ";", analog_expression, ";", analog_variable_assignment, ")", analog_statement
	;

case_item =
	expression, { expression }, ":", statement_or_null |
	"default", [ ":" ], statement_or_null
	;

case_statement =
	"case", "(", expression, ")", case_item, { case_item }, "endcase" |
	"casex", "(", expression, ")", case_item, { case_item }, "endcase" |
	"casez", "(", expression, ")", case_item, { case_item }, "endcase"
	;

analog_function_case_item =
	analog_expression, { analog_expression }, ":", analog_function_statement_or_null |
	"default", [ ":" ], analog_function_statement_or_null
	;

analog_function_case_statement =
	"case", "(", analog_expression, ")", analog_function_case_item, { analog_function_case_item }, "endcase"
	;

analog_case_item =
	analog_expression, { ",", analog_expression }, ":", analog_statement_or_null |
	"default", [ ":" ], analog_statement_or_null
	;

analog_case_statement =
	"case", "(", analog_expression, ")", analog_case_item, { analog_case_item }, "endcase" |
	"casex", "(", analog_expression, ")", analog_case_item, { analog_case_item }, "endcase" |
	"casez", "(", analog_expression, ")", analog_case_item, { analog_case_item }, "endcase"
	;

if_else_if_statement =
	"if", "(", expression, ")", statement_or_null, { "else", "if", "(", expression, ")", statement_or_null }, [ "else", statement_or_null ]
	;

conditional_statement =
	"if", "(", expression, ")", statement_or_null, [ "else", statement_or_null ] |
	if_else_if_statement
	;

analog_function_conditional_statement =
	"if", "(", analog_expression, ")", analog_function_statement_or_null, { "else", "if", "(", analog_expression, ")", analog_function_statement_or_null }, [ "else", analog_function_statement_or_null ]
	;

analog_conditional_statement =
	"if", "(", analog_expression, ")", analog_statement_or_null, { "else", "if", "(", analog_expression, ")", analog_statement_or_null }, [ "else", analog_statement_or_null ]
	;

wait_statement =
	"wait", "(", expression, ")", statement_or_null
	;

procedural_timing_control_statement =
	procedural_timing_control, statement_or_null
	;

procedural_timing_control =
	delay_control |
	event_control
	;

event_expression =
	expression |
	"posedge", expression |
	"negedge", expression |
	hierarchical_event_identifier |
	event_expression, "or", event_expression |
	event_expression, ",", event_expression |
	analog_event_functions |
	"driver_update", expression |
	analog_variable_lvalue
	;

event_trigger =
	"->", hierarchical_event_identifier, { "[", expression, "]" }, ";"
	;

event_control =
	"@", hierarchical_event_identifier |
	"@", "(", event_expression, ")" |
	"@", "*" |
	"@", "(", "*", ")"
	;

disable_statement =
	"disable", hierarchical_task_identifier, ";" |
	"disable", hierarchical_block_identifier, ";"
	;

delay_or_event_control =
	delay_control |
	event_control |
	"repeat", "(", expression, ")", event_control
	;

delay_control =
	"#", delay_value |
	"#", "(", mintypmax_expression, ")"
	;

analog_event_functions =
	"cross", "(", analog_expression, [ ",", analog_expression_or_null, [ ",", constant_expression_or_null, [ ",", constant_expression_or_null, [ ",", analog_expression ] ] ] ], ")" |
	"above", "(", analog_expression, [ ",", constant_expression_or_null, [ ",", constant_expression_or_null, [ ",", analog_expression ] ] ], ")" |
	"timer", "(", analog_expression, [ ",", analog_expression, [ ",", constant_expression_or_null, [ ",", analog_expression ] ] ], ")"
	;

analog_event_expression =
	expression |
	"posedge", expression |
	"negedge", expression |
	hierarchical_event_identifier |
	"initial_step", [ "(", '"', analysis_identifier, '"', { ",", '"', analysis_identifier, '"' }, ")" ] |
	"final_step", [ "(", '"', analysis_identifier, '"', { ",", '"', analysis_identifier, '"' }, ")" ] |
	analog_event_functions |
	analog_event_expression, "or", analog_event_expression |
	analog_event_expression, ",", analog_event_expression
	;

analog_event_control =
	"@", hierarchical_event_identifier |
	"@", "(", analog_event_expression, ")"
	;

analog_event_control_statement =
	analog_event_control, analog_event_statement
	;

(* See NOTE 1 *)
function_statement =
	statement
	;

statement_or_null =
	statement |
	{ attribute_instance }, ";"
	;

statement =
	{ attribute_instance }, blocking_assignment, ";" |
	{ attribute_instance }, case_statement |
	{ attribute_instance }, conditional_statement |
	{ attribute_instance }, disable_statement |
	{ attribute_instance }, event_trigger |
	{ attribute_instance }, loop_statement |
	{ attribute_instance }, nonblocking_assignment, ";" |
	{ attribute_instance }, par_block |
	{ attribute_instance }, procedural_continuous_assignments, ";" |
	{ attribute_instance }, procedural_timing_control_statement |
	{ attribute_instance }, seq_block |
	{ attribute_instance }, system_task_enable |
	{ attribute_instance }, task_enable |
	{ attribute_instance }, wait_statement
	;

analog_function_statement_or_null =
	analog_function_statement |
	{ attribute_instance }, ";"
	;

analog_function_statement =
	{ attribute_instance }, analog_function_case_statement |
	{ attribute_instance }, analog_function_conditional_statement |
	{ attribute_instance }, analog_function_loop_statement |
	{ attribute_instance }, analog_function_seq_block |
	{ attribute_instance }, analog_procedural_assignment |
	{ attribute_instance }, analog_system_task_enable
	;

analog_event_statement =
	{ attribute_instance }, analog_loop_statement |
	{ attribute_instance }, analog_case_statement |
	{ attribute_instance }, analog_conditional_statement |
	{ attribute_instance }, analog_procedural_assignment |
	{ attribute_instance }, analog_event_seq_block |
	{ attribute_instance }, analog_system_task_enable |
	{ attribute_instance }, disable_statement |
	{ attribute_instance }, event_trigger |
	{ attribute_instance }, ";"
	;

analog_statement_or_null =
	analog_statement | { attribute_instance }, ";"
	;

analog_statement =
	{ attribute_instance }, analog_loop_generate_statement |
	{ attribute_instance }, analog_loop_statement |
	{ attribute_instance }, analog_case_statement |
	{ attribute_instance }, analog_conditional_statement |
	{ attribute_instance }, analog_procedural_assignment |
	{ attribute_instance }, analog_seq_block |
	{ attribute_instance }, analog_system_task_enable |
	{ attribute_instance }, contribution_statement |
	{ attribute_instance }, indirect_contribution_statement |
	{ attribute_instance }, analog_event_control_statement
	;

seq_block =
	"begin", [ ":", block_identifier, { block_item_declaration } ], { statement }, "end"
	;

par_block =
	"fork", [ ":", block_identifier, { block_item_declaration } ], { statement }, "join"
	;

analog_function_seq_block =
	"begin", [ ":", analog_block_identifier, { analog_block_item_declaration } ], { analog_function_statement }, "end"
	;

analog_event_seq_block =
	"begin", [ ":", analog_block_identifier, { analog_block_item_declaration } ], { analog_event_statement }, "end"
	;

analog_seq_block =
	"begin", [ ":", analog_block_identifier, { analog_block_item_declaration } ], { analog_statement }, "end"
	;

variable_assignment =
	variable_lvalue, "=", expression
	;

procedural_continuous_assignments =
	"assign", variable_assignment |
	"deassign", variable_lvalue |
	"force", variable_assignment |
	"force", net_assignment |
	"release", variable_lvalue |
	"release", net_lvalue
	;

nonblocking_assignment =
	variable_lvalue, "<=", [ delay_or_event_control ], expression
	;

blocking_assignment =
	variable_lvalue, "=", [ delay_or_event_control ], expression
	;

always_construct =
	"always", statement
	;

initial_construct =
	"initial", statement
	;

analog_variable_assignment =
	analog_variable_lvalue, "=", analog_expression
	;

analog_procedural_assignment =
	analog_variable_assignment, ";"
	;

analog_construct =
	"analog", analog_statement |
	"analog", "initial", analog_function_statement
	;

net_assignment =
	net_lvalue, "=", expression
	;

list_of_net_assignments =
	net_assignment, { ",", net_assignment }
	;

continuous_assign =
	"assign", [ drive_strength ], [ delay3 ], list_of_net_assignments, ";"
	;

name_of_udp_instance =
	udp_instance_identifier, [ range ]
	;

udp_instance =
	[ name_of_udp_instance ], "(", output_terminal, ",", input_terminal, { ",", input_terminal }, ")"
	;

udp_instantiation =
	udp_identifier, [ drive_strength ], [ delay2 ], upd_instance, { ",", upd_instance }, ";"
	;

edge_symbol =
	"r" | "R" | "f" | "F" | "p" | "P" | "n" | "N" | "*"
	;

level_symbol =
	"0" | "1" | "x" | "X" | "?" | "b" | "B"
	;

output_symbol =
	"0" | "1" | "x" | "X"
	;

next_state =
	output_symbol | "-"
	;

current_state =
	level_symbol
	;

edge_indicator =
	"(", level_symbol, level_symbol, ")" |
	edge_symbol
	;

edge_input_list =
	{ level_symbol }, edge_indicator, { level_symbol }
	;

level_input_list =
	level_symbol, { level_symbol }
	;

seq_input_list =
	level_input_list |
	edge_input_list
	;

sequential_entry =
	seq_input_list, ":", current_state, ":", next_state, ";"
	;

init_val =
	"1'b0" | "1'b1" | "1'bx" | "1'bX" | "1'B0" | "1'B1" | "1'Bx" | "1'BX" | "1" | "0"
	;

udp_initial_statement =
	"initial", output_port_identifier, "=", init_val, ";"
	;

sequential_body =
	[ udp_initial_statement ], "table", sequential_entry, { sequential_entry }, "endtable"
	;

combinatorial_entry =
	level_input_list, ":", output_symbol, ";"
	;

combinatorial_body =
	"table", combinatorial_entry, { combinatorial_entry }, "endtable"
	;

udp_body =
	combinatorial_body |
	sequential_body
	;

udp_reg_declaration =
	{ attribute_instance }, "reg", [ discipline_identifier ], variable_identifier
	;

udp_input_declaration =
	{ attribute_instance }, "input", list_of_port_identifiers
	;

udp_output_declaration =
	{ attribute_instance }, "output", port_identifier |
	{ attribute_instance }, "output", [ discipline_identifier ], "reg", port_identifier, [ "=", constant_expression ]
	;

udp_port_declaration =
	udp_output_declaration, ";" |
	udp_input_declaration, ";" |
	udp_reg_declaration, ";"
	;

udp_declaration_port_list =
	udp_output_declaration, ",", udp_input_declaration, { ",", udp_input_declaration }
	;

udp_port_list =
	output_port_identifier, ",", input_port_identifier, { ",", input_port_identifier }
	;

udp_declaration =
	{ attribute_instance }, "primitive", udp_identifier, "(", udp_port_list, ")", ";", udp_port_declaration, { udp_port_declaration }, udp_body, "endprimitive" |
	{ attribute_instance }, "primitive", udp_identifier, "(", udp_declaration_port_list, ")", ";", udp_body, "endprimitive"
	;

generate_block_or_null =
	generate_block | ";"
	;

generate_block =
	module_or_generate_item |
	"begin", [ ":", generate_block_identifier ], { module_or_generate_item }, "end"
	;

case_generate_item =
	constant_expression, { ",", constant_expression }, ":", generate_block_or_null |
	"default", [ ":" ], generate_block_or_null
	;

case_generate_construct =
	"case", "(", constant_expression, ")", case_generate_item, { case_generate_item }, "endcase"
	;

if_generate_construct =
	"if", "(", constant_expression, ")", generate_block_or_null, [ "else", generate_block_or_null ]
	;

conditional_generate_construct =
	if_generate_construct |
	case_generate_construct
	;

genvar_primary =
	constant_primary |
	genvar_identifier
	;

genvar_iteration =
	genvar_identifier, "=", genvar_expression
	;

genvar_expression =
	genvar_primary |
	unary_operator, { attribute_instance }, genvar_primary |
	genvar_expression, binary_operator, { attribute_instance }, genvar_expression |
	genvar_expression, "?", { attribute_instance }, genvar_expression, ":", genvar_expression
	;

genvar_initialization =
	genvar_identifier, "=", constant_expression
	;

loop_generate_construct =
	"for", "(", genvar_initialization, ";", genvar_expression, ";", genvar_iteration, ")", generate_block
	;

analog_loop_generate_statement =
	"for", "(", genvar_initialization, ";", genvar_expression, ";", genvar_iteration, ")", analog_statement
	;

list_of_genvar_identifiers =
	genvar_identifier, { ",", genvar_identifier }
	;

genvar_declaration =
	"genvar", list_of_genvar_identifiers, ";"
	;

generate_region =
	"generate", { module_or_generate_item }, "endgenerate"
	;

named_port_connection =
	{ attribute_instance }, ".", port_identifier, "(", [ expression ], ")"
	;

ordered_port_connection =
	{ attribute_instance }, [ expression ]
	;

list_of_port_connections =
	ordered_port_connection, { ",", ordered_port_connection } |
	named_port_connection, { ",", named_port_connection }
	;

name_of_module_instance =
	module_instance_identifier, [ range ]
	;

module_instance =
	name_of_module_instance, "(", [ list_of_port_connections ], ")"
	;

named_parameter_assignment =
	".", parameter_identifier, "(", [ mintypmax_expression ], ")" |
	".", system_parameter_identifier, "(", [ constant_expression ], ")"
	;

ordered_parameter_assignment =
	expression
	;

list_of_parameter_assignments =
	ordered_parameter_assignment, { ",", ordered_parameter_assignment } |
	named_parameter_assignment, { ",", named_parameter_assignment }
	;

parameter_value_assignment =
	"#", "(", list_of_parameter_assignments, ")"
	;

module_instantiation =
	module_or_paramset_identifier, [ parameter_value_assignment ], module_instance, { ",", module_instance }, ";"
	;

pass_en_switchtype =
	"tran" | "rtran"
	;

pass_en_switchtype =
	"tranif0" | "tranif1" | "rtranif1" | "rtranif0"
	;

n_output_gate_instance =
	"buf" | "not"
	;

n_input_gate_instance =
	"and" | "nand" | "or" | "nor" | "xor" | "xnor"
	;

mos_switchtype =
	"nmos" | "pmos" | "rnmos" | "rpmos"
	;

enable_gatetype =
	"bufif0" | "bufif1" | "notif0" | "notif1"
	;

cmos_switchtype =
	"cmos" | "rcmos"
	;

pcontrol_terminal =
	expression
	;

output_terminal =
	net_lvalue
	;

ncontrol_terminal =
	expression
	;

input_terminal =
	expression
	;

inout_terminal =
	net_lvalue
	;

enable_terminal =
	expression
	;

pullup_strength =
	"(", strength0, strength1, ")" |
	"(", strength1, strength0, ")" |
	"(", strength1, ")"
	;

pulldown_strength =
	"(", strength0, strength1, ")" |
	"(", strength1, strength0, ")" |
	"(", strength0, ")"
	;

name_of_gate_instance =
	gate_instance_identifier, [ range ]
	;

pull_gate_instance =
	[ name_of_gate_instance ], "(", output_terminal, ")"
	;

pass_enable_switch_instance =
	[ name_of_gate_instance ], "(", inout_terminal, ",", inout_terminal, ",", enable_terminal, ")"
	;

pass_switch_instance =
	[ name_of_gate_instance ], "(", inout_terminal, ",", inout_terminal, ")"
	;

n_output_gate_instance =
	[ name_of_gate_instance ], "(", output_terminal, { ",", output_terminal }, ",", input_terminal, ")"
	;

n_input_gate_instance =
	[ name_of_gate_instance ], "(", output_terminal, ",", input_terminal, { ",", input_terminal }, ")"
	;

mos_switch_instance =
	[ name_of_gate_instance ], "(", output_terminal, ",", input_terminal, ",", enable_terminal, ")"
	;

enable_gate_instance =
	[ name_of_gate_instance ], "(", output_terminal, ",", input_terminal, ",", enable_terminal, ")"
	;

cmos_switch_instance =
	[ name_of_gate_instance ], "(", output_terminal, ",", input_terminal, ",", ncontrol_terminal, ",", pcontrol_terminal, ")"
	;

gate_instantiation =
	cmos_switchtype, [ delay3 ], cmos_switch_instance, { ",", cmos_switch_instance }, ";" |
	enable_gatetype, [ drive_strength ], [ delay3 ], enable_gate_instance, { ",", enable_gate_instance }, ";" |
	mos_switchtype, [ delay3 ], mos_switch_instance, { ",", mos_switch_instance }, ";" |
	n_input_gatetype, [ drive_strength ], [ delay2 ], n_input_gate_instance, { ",", n_input_gate_instance }, ";" |
	n_output_gatetype, [ drive_strength ], [ delay2 ], n_output_gate_instance, { ",", n_output_gate_instance }, ";" |
	pass_en_switchtype, [ delay2 ], pass_enable_switch_instance, { ",", pass_enable_switch_instance }, ";" |
	pass_switchtype, pass_switch_instance, { ",", pass_switch_instance }, ";" |
	"pulldown", [ pulldown_strength ], pull_gate_instance, { ",", pull_gate_instance }, ";" |
	"pullup", [ pullup_strength ], pull_gate_instance, { ",", pull_gate_instance }, ";"
	;

block_real_type =
	real_identifier, { dimension }
	;

block_variable_type =
	variable_identifier, { dimension }
	;

list_of_block_real_identifiers =
	block_real_type, { ",", block_real_type }
	;

list_of_block_variable_identifiers =
	block_variable_type, { ",", block_variable_type }
	;

block_item_declaration =
	{ attribute_instance }, "reg", [ discipline_identifier ], [ "signed" ], [ range ], list_of_block_variable_identifiers, ";" |
	{ attribute_instance }, "integer", list_of_block_variable_identifiers, ";" |
	{ attribute_instance }, "time", list_of_block_variable_identifiers, ";" |
	{ attribute_instance }, "real", list_of_block_real_identifiers, ";" |
	{ attribute_instance }, "realtime", list_of_block_real_identifiers, ";" |
	{ attribute_instance }, event_declaration |
	{ attribute_instance }, local_parameter_declaration, ";" |
	{ attribute_instance }, parameter_declaration, ";"
	;

analog_block_item_declaration =
	{ attribute_instance }, parameter_declaration, ";" |
	{ attribute_instance }, integer_declaration |
	{ attribute_instance }, real_declaration
	;

task_port_type =
	"integer" | "real" | "realtime" | "time"
	;

tf_inout_declaration =
	"inout", [ discipline_identifier ], [ "reg" ], [ "signed" ], [ range ], list_of_port_identifiers |
	"inout", task_port_type, list_of_port_identifiers
	;

tf_output_declaration =
	"output", [ discipline_identifier ], [ "reg" ], [ "signed" ], [ range ], list_of_port_identifiers |
	"output", task_port_list, list_of_port_identifiers
	;

tf_input_declaration =
	"input", [ discipline_identifier ], [ "reg" ], [ "signed" ], [ range ], list_of_port_identifiers |
	"input", task_port_type, list_of_port_identifiers
	;

task_port_item =
	{ attribute_instance }, tf_input_declaration |
	{ attribute_instance }, tf_output_declaration |
	{ attribute_instance }, tf_inout_declaration
	;

task_port_list =
	task_port_item, { ",", task_port_item }
	;

task_item_declaration =
	block_item_declaration |
	{ attribute_instance }, tf_input_declaration, ";" |
	{ attribute_instance }, tf_output_declaration, ";" |
	{ attribute_instance }, tf_inout_declaration, ";" |
	;

task_declaration =
	"task", [ "automatic" ], task_identifier, ";", { task_item_declaration }, statement_or_null, "endtask" |
	"task", [ "automatic" ], task_identifier, "(", [ task_port_list ], ")", ";", { block_item_declaration }, statement_or_null, "endtask"
	;

function_range_or_type =
	[ "signed" ], [ range ] |
	"integer" |
	"real" |
	"realtime" |
	"time"
	;

function_port_list =
	{ attribute_instance }, tf_input_declaration, { ",", { attribute_instance }, tf_input_declaration }
	;

function_item_declaration =
	block_item_declaration |
	{ attribute_instance }, tf_input_declaration, ";"
	;

function_declaration =
	"function", [ "automatic" ], [ function_range_or_type ], function_identifier, ";", function_item_declaration, { function_item_declaration }, function_statement, "endfunction" |
	"function", [ "automatic" ], [ function_range_or_type ], function_identifier, "(", function_port_list, ")", ";", { block_item_declaration }, function_statement, "endfunction"
	;

analog_function_item_declaration =
	analog_block_item_declaration |
	input_declaration, ";" |
	output_declaration, ";" |
	inout_declaration, ";"
	;

analog_function_type =
	"integer" | "real"
	;

analog_function_declaration =
	"analog", "function", [ analog_function_type ], analog_function_identifier, ";", analog_function_item_declaration, { analog_function_item_declaration }, analog_function_statement, "endfunction"
	;

value_range_expression =
	constant_expression |
	"-inf" |
	"inf"
	;

value_range_type =
	"from" | "exclude"
	;

value_range =
	value_range_type, "(", value_range_expression, ":", value_range_expression, ")" |
	value_range_type, "(", value_range_expression, ":", value_range_expression, "]" |
	value_range_type, "[", value_range_expression, ":", value_range_expression, ")" |
	value_range_type, "[", value_range_expression, ":", value_range_expression, "]" |
	value_range_type, "'", "{", string, { ",", string }, "}" |
	"exclude", constant_expression
	;

range =
	"[", msb_constant_expression, ":", lsb_constant_expression, "]"
	;

dimension =
	"[", dimension_constant_expression, ":", dimension_constant_expression, "]"
	;

limit_value =
	constant_mintypmax_expression
	;

reject_limit_value =
	limit_value
	;

error_limit_value =
	limit_value
	;

pulse_control_specparam =
	"PATHPULSE$", "=", "(", reject_limit_value, [ ",", error_limit_value ], ")" |
	"PATHPULSE$", specify_input_terminal_descriptor, "$", specify_output_terminal_descriptor, "=", "(", reject_limit_value, [ ",", error_limit_value ], ")"
	;

specparam_assignment =
	specparam_identifier, "=", constant_mintypmax_expression |
	pulse_control_specparam
	;

param_assignment =
	parameter_identifier, "=", constant_mintypmax_expression, { value_range } |
	parameter_identifier, range, "=", constant_arrayinit, { value_range }
	;

ams_net_identifier =
	net_identifier, { dimension } |
	hierarchical_net_identifier
	;

net_decl_assignment =
	net_identifier, "=", expression |
	net_identifier, { dimension }, "=", constant_optional_arrayinit
	;

defparam_assignment =
	hierarchical_parameter_identifier, "=", constant_mintypmax_expression
	;

list_of_variable_port_identifiers =
	port_identifier, [ "=", constant_expression ], { ",", port_identifier, [ "=", constant_expression ] }
	;

list_of_variable_identifiers =
	variable_type, { ",", variable_type }
	;

list_of_specparam_assignments =
	specparam_assignment, { ",", specparam_assignment }
	;

list_of_real_identifiers =
	real_type, { ",", real_type }
	;

list_of_port_identifiers =
	port_identifier, { ",", port_identifier }
	;

list_of_param_assignments =
	param_assignment, { ",", param_assignment }
	;

list_of_net_identifiers =
	ams_net_identifier, { ",", ams_net_identifier }
	;

list_of_net_decl_assignments =
	net_decl_assignment, { ",", net_decl_assignment }
	;

list_of_event_identifiers =
	event_identifier, { dimension }, { ",", event_identifier, { dimension } }
	;

list_of_defparam_assignments =
	defparam_assignment, { ",", defparam_assignment }
	;

list_of_branch_identifiers =
	branch_identifier, [ range ], { ",", branch_identifier, [ range ] }
	;

delay_value =
	unsigned_number |
	real_number |
	identifier
	;

delay2 =
	"#", delay_value |
	"#", "(", mintypmax_expression, [ ",", mintypmax_expression ], ")"
	;

delay3 =
	"#", delay_value |
	"#", "(", mintypmax_expression, [ ",", mintypmax_expression, [ ",", mintypmax_expression ] ], ")"
	;

charge_strength =
	"(", "small", ")" |
	"(", "medium", ")" |
	"(", "large", ")"
	;

strength1 =
	"supply1" | "strong1" | "pull1" | "weak1"
	;

strength0 =
	"supply0" | "strong0" | "pull0" | "weak0"
	;

drive_strength =
	"(", strength0, strength1, ")" |
	"(", strength1, strength0, ")" |
	"(", strength0, "highz1", ")" |
	"(", strength1, "highz0", ")" |
	"(", "highz1", strength0, ")" |
	"(", "highz0", strength1, ")"
	;

variable_type =
	variable_identifier, { dimension }, [ "=", constant_arrayinit ] |
	variable_identifier, "=", constant_expression
	;

real_type =
	real_identifier, { dimension }, [ "=", constant_arrayinit ] |
	real_identifier, "=", constant_expression
	;

output_variable_type =
	"integer" | "time"
	;

net_type =
	"supply0" | "supply1" | "tri" | "triand" | "trior" | "tri0" | "tri1" | "uwire" | "wire" | "wand" | "wor"
	;

time_declaration =
	"time", list_of_variable_identifiers, ";"
	;

reg_declaration =
	"reg", [ discipline_identifier ], [ "signed" ], [ range ], list_of_variable_identifiers, ";"
	;

realtime_declaration =
	"realtime", list_of_real_identifiers, ";"
	;

real_declaration =
	"real", list_of_real_identifiers, ";"
	;

net_declaration =
	net_type, [ discipline_identifier ], [ "signed" ], [ delay3 ], list_of_net_identifiers, ";" |
	net_type, [ discipline_identifier ], [ drive_strength ], [ "signed" ], [ delay3 ], list_of_net_decl_assignments, ";" |
	net_type, [ discipline_identifier ], [ "vectored" | "scalared" ], [ "signed" ], range, [ delay3 ], list_of_net_identifiers, ";" |
	net_type, [ discipline_identifier ], [ drive_strength ], [ "vectored" | "scalared" ], [ "signed" ], range, [ delay3 ], list_of_net_decl_assignments, ";" |
	"trireg", [ discipline_identifier ], [ charge_strength ], [ "signed" ], [ delay3 ], list_of_net_identifiers, ";" |
	"trireg", [ discipline_identifier ], [ drive_strength ], [ "signed" ], [ delay3 ], list_of_net_decl_assignments, ";" |
	"trireg", [ discipline_identifier ], [ charge_strength ], [ "vectored" | "scalared" ], [ "signed" ], range, [ delay3 ], list_of_net_identifiers, ";" |
	"trireg", [ discipline_identifier ], [ drive_strength ], [ "vectored" | "scalared" ], [ "signed" ], range, [ delay3 ], list_of_net_decl_assignments, ";" |
	discipline_identifier, [ range ], list_of_net_identifiers, ";" |
	discipline_identifier, [ range ], list_of_net_decl_assignments, ";" |
	"wreal", [ discipline_identifier ], [ range ], list_of_net_identifiers, ";" |
	"wreal", [ discipline_identifier ], [ range ], list_of_net_decl_assignments, ";" |
	"ground", [ discipline_identifier ], [ range ], list_of_net_identifiers, ";"
	;

integer_declaration =
	"integer", list_of_variable_identifiers, ";"
	;

event_declaration =
	"event", list_of_event_identifiers, ";"
	;

branch_terminal =
	net_identifier |
	net_identifier, "[", constant_expression, "]" |
	net_identifier, "[", constant_range_expression, "]"
	;

branch_declaration =
	"branch", "(", branch_terminal, [ ",", branch_terminal ], ")", list_of_branch_identifiers, ";"
	;

output_declaration =
	"output", [ discipline_identifier ], [ net_type | "wreal" ], [ "signed" ], [ range ], list_of_port_identifiers |
	"output", [ discipline_identifier ], "reg", [ "signed" ], [ range ], list_of_variable_port_identifiers |
	"output", output_variable_type, list_of_variable_identifiers
	;

input_declaration =
	"input", [ discipline_identifier ], [ net_type | "wreal" ], [ "signed" ], [ range ], list_of_port_identifiers
	;

inout_declaration =
	"inout", [ discipline_identifier ], [ net_type | "wreal" ], [ "signed" ], [ range ], list_of_port_identifiers
	;

aliasparam_declaration =
	"aliasparam", parameter_identifier, "=", parameter_identifier, ";"
	;

parameter_type =
	"integer" | "real" | "realtime" | "time" | "string"
	;

specparam_declaration =
	"specparam", [ range ], list_of_specparam_assignments, ";"
	;

parameter_declaration =
	"parameter", [ "signed" ], [ range ], list_of_param_assignments |
	"parameter", parameter_type, list_of_param_assignments
	;

local_parameter_declaration =
	"localparam", [ "signed" ], [ range ], list_of_param_assignments |
	"localparam", parameter_type, list_of_param_assignments
	;

paramset_constant_expression =
	constant_primary |
	hierarchical_parameter_identifier |
	unary_operator, { attribute_instance }, constant_primary |
	paramset_constant_expression, binary_operator, { attribute_instance }, paramset_constant_expression |
	paramset_constant_expression, "?", { attribute_instance }, paramset_constant_expression, ":", paramset_constant_expression
	;

paramset_statement =
	".", module_parameter_identifier, "=", paramset_constant_expression, ";" |
	".", system_parameter_identifier, "=", paramset_constant_expression, ";" |
	analog_function_statement
	;

paramset_item_declaration =
	{ attribute_instance }, parameter_declaration, ";" |
	{ attribute_instance }, local_parameter_declaration, ";" |
	aliasparam_declaration |
	{ attribute_instance }, integer_declaration |
	{ attribute_instance }, real_declaration
	;

paramset_declaration =
	{ attribute_instance }, "paramset", paramset_identifier, module_or_paramset_identifier, ";", paramset_item_declaration, { paramset_item_declaration }, paramset_statement, { paramset_statement }, "endparamset"
	;

connect_resolution =
	"connect", discipline_identifier, { ",", discipline_identifier }, "resolveto", ( discipline_identifier | "exclude" ), ";"
	;

connect_port_overrides =
	discipline_identifier, ",", discipline_identifier |
	"input", discipline_identifier, ",", "output", discipline_identifier |
	"output", discipline_identifier, ",", "input", discipline_identifier |
	"inout", discipline_identifier, ",", "inout", discipline_identifier
	;

connect_mode =
	"merged" | "split"
	;

connect_insertion =
	"connect", connectmodule_identifier, [ connect_mode ], [ parameter_value_assignment ], [ connect_port_overrides ], ";"
	;

connectrules_item =
	connect_insertion |
	connect_resolution
	;

connectrules_declaration =
	"connectrules", connectrules_identifier, ";", { connectrules_item }, "endconnectrules"
	;

nature_attribute_override =
	potential_or_flow, ".", nature_attribute
	;

discrete_or_continuous =
	"discrete" | "continuous"
	;

discipline_domain_binding =
	"domain", discrete_or_continuous, ";"
	;

potential_or_flow =
	"potential" | "flow"
	;

nature_binding =
	potential_or_flow, nature_identifier, ";"
	;

discipline_item =
	nature_binding |
	discipline_domain_binding |
	nature_attribute_override
	;

discipline_declaration =
	"discipline", discipline_identifier, [ ";" ], { discipline_item }, "enddiscipline"
	;

nature_attribute =
	nature_attribute_identifier, "=", nature_attribute_expression, ";"
	;

nature_item =
	nature_attribute
	;

parent_nature =
	nature_identifier |
	discipline_identifier, ".", potential_or_flow
	;

nature_declaration =
	"nature", nature_identifier, [ ":", parent_nature ], [ ";" ], { nature_item }, "endnature"
	;

use_clause =
	"use", [ library_identifier, "." ], cell_identifier, [ ":", "config" ]
	;

liblist_clause =
	"liblist", { library_identifier }
	;

cell_clause =
	"cell", [ library_identifier, "." ], cell_identifier
	;

inst_name =
	topmodule_identifier, { ".", instance_identifier }
	;

inst_clause =
	"instance", inst_name
	;

default_clause =
	"default"
	;

config_rule_statement =
	default_clause, liblist_clause, ";" |
	inst_clause, liblist_clause, ";" |
	inst_clause, use_clause, ";" |
	cell_clause, liblist_clause, ";" |
	cell_clause, use_clause, ";"
	;

design_statement =
	"design", { [ library_identifier, "." ], cell_identifier }, ";"
	;

config_declaration =
	"config", config_identifier, ";", design_statement, { config_rule_statement }, "endconfig"
	;

parameter_override =
	"defparam", list_of_defparam_assignments, ";"
	;

non_port_module_item =
	module_or_generate_item |
	generate_region |
	specify_block |
	{ attribute_instance }, parameter_declaration, ";" |
	{ attribute_instance }, specparam_declaration |
	aliasparam_declaration
	;

module_or_generate_item_declaration =
	net_declaration |
	reg_declaration |
	integer_declaration |
	real_declaration |
	time_declaration |
	realtime_declaration |
	event_declaration |
	genvar_declaration |
	task_declaration |
	function_declaration |
	branch_declaration |
	analog_function_declaration
	;

module_or_generate_item =
	{ attribute_instance }, module_or_generate_item_declaration |
	{ attribute_instance }, local_parameter_declaration, ";" |
	{ attribute_instance }, parameter_override |
	{ attribute_instance }, continuous_assign |
	{ attribute_instance }, gate_instantiation |
	{ attribute_instance }, udp_instantiation |
	{ attribute_instance }, module_instantiation |
	{ attribute_instance }, initial_construct |
	{ attribute_instance }, always_construct |
	{ attribute_instance }, loop_generate_construct |
	{ attribute_instance }, conditional_generate_construct |
	{ attribute_instance }, analog_construct
	;

module_item =
	port_declaration, ";" |
	non_port_module_item
	;

port_declaration =
	{ attribute_instance }, inout_declaration |
	{ attribute_instance }, input_declaration |
	{ attribute_instance }, output_declaration
	;

port_reference =
	port_identifier, [ "[", constant_range_expression, "]" ]
	;

port_expression =
	port_reference |
	"{", port_reference, { ",", port_reference }, "}"
	;

port =
	"[", port_expression, "]" |
	".", port_identifier, "(", [ port_expression ], ")"
	;

list_of_port_declarations =
	"(", port_declaration, { ",", port_declaration }, ")" |
	"(", ")"
	;

list_of_ports =
	"(", port, { ",", port }, ")"
	;

module_parameter_port_list =
	"#", "(", parameter_declaration, { ",", parameter_declaration }
	;

module_keyword =
	"module" | "macromodule" | "connectmodule"
	;

module_declaration =
	{ attribute_instance }, module_keyword, module_identifier, [ module_parameter_port_list ], list_of_ports, ";", { module_item }, "endmodule" |
	{ attribute_instance }, module_keyword, module_identifier, [ module_parameter_port_list ], [ list_of_port_declarations ], ";", { non_port_module_item }, "endmodule"
	;

description =
	module_declaration |
	udp_declaration |
	config_declaration |
	paramset_declaration |
	nature_declaration |
	discipline_declaration |
	connectrules_declaration
	;

source_text =
	{ description }
	;

(* Library Map File *)

include_statement =
	"include", file_path_spec, ";"
	;

file_path_spec =
	file_path
	;

library_declaration	=
	"library", library_identifier, file_path_spec, [ { ",", file_path_spec } ], [ "-incdir", file_path_spec, { ",", file_path_spec } ], ";"
	;

library_description =
	library_declaration |
	include_statement |
	config_declaration
	;

library_text =
	{ library_description }
	;

(*
	Keywords:
		above
		abs
		absdelay
		abstol
		ac_stim
		access
		acos
		acosh
		aliasparam
		always
		analog
		analysis
		and
		asin
		asinh
		assert
		assign
		atan
		atan2
		atanh
		automatic
		begin
		branch
		buf
		bufif0
		bufif1
		case
		casex
		casez
		ceil
		cell
		cmos
		config
		connect
		connectmodule
		connectrules
		continuous
		cos
		cosh
		cross
		ddt
		ddt_nature
		ddx
		deassign
		default
		defparam
		design
		disable
		discipline
		discrete
		domain
		driver_update
		edge
		else
		end
		endcase
		endconfig
		endconnectrules
		enddiscipline
		endfunction
		endgenerate
		endmodule
		endnature
		endparamset
		endprimitive
		endspecify
		endtable
		endtask
		event
		exclude
		exp
		final_step
		flicker_noise
		floor
		flow
		for
		force
		forever
		fork
		from
		function
		generate
		genvar
		ground
		highz0
		highz1
		hypot
		idt
		idt_nature
		idtmod
		if
		ifnone
		incdir
		include
		inf
		initial
		initial_step
		inout
		input
		instance
		integer
		join
		laplace_nd
		laplace_np
		laplace_zd
		laplace_zp
		large
		last_crossing
		liblist
		library
		limexp
		ln
		localparam
		log
		macromodule
		max
		medium
		merged
		min
		module
		nand
		nature
		negedge
		net_resolution
		nmos
		noise_table
		nor
		noshowcancelled
		not
		notif0
		notif1
		or
		output
		parameter
		paramset
		pmos
		posedge
		potential
		pow
		primitive
		pull0
		pull1
		pulldown
		pullup
		pulsestyle_ondetect
		pulsestyle_onevent
		rcmos
		real
		realtime
		reg
		release
		repeat
		resolveto
		rnmos
		rpmos
		rtran
		rtranif0
		rtranif1
		scalared
		showcancelled
		signed
		sin
		sinh
		slew
		small
		specify
		specparam
		split
		sqrt
		string
		strong0
		strong1
		supply0
		supply1
		table
		tan
		tanh
		task
		time
		timer
		tran
		tranif0
		tranif1
		transition
		tri
		tri0
		tri1
		triand
		trior
		trireg
		units
		unsigned
		use
		uwire
		vectored
		wait
		wand
		weak0
		weak1
		while
		white_noise
		wire
		wor
		wreal
		xnor
		xor
		zi_nd
		zi_np
		zi_zd
		zi_zp
*)
