(* SPDX-License-Identifier: BSD-3-Clause *)
(* EBNF grammar for SystemVerilog 2012 (IEEE 1800-2012) *)
(*
	NOTE 1: A `package_import_declaration` in a `module_ansi_header`, `interface_ansi_header` or,
			`program_ansi_header`, shall be followed by a `parameter_port_list` or
			`list_of_port_declarations`, or both.
	NOTE 2: The `list_of_port_declarations` syntax is explained in IEEE 1800-2012 §22.2.2.2, which
			also imposes various semantic restrictions, e.g., a `ref` port shall be of a variable
			type and an `inout` port shall not be. It shall be illegal to initialize a port that is
			not a variable `output` port or to specify a default value of a port that is not an
			`input` port.
	NOTE 3: A `timeunits_declaration` shall be legal as a `non_port_module_item`,
			`non_port_interface_item`, `non_port_program_item`, or `package_item` only if it repeats
			and matches a previous `timeunits_declaration` within the same time scope.
	NOTE 4: If the `bind_target_scope` is an `interface_identifier` or the `bind_target_instance` is
			an `interface_instance_identifier` then the `bind_instantiation` shall be an
			`interface_instantiation` or a `checker_instantiation`
	NOTE 5: It shall be illegal for a `program_generate_item` to include any item that would be
			illegal in a `program_declaration` outside of a `program_generate_item.
	NOTE 6: It shall be illegal for a `checker_generate_item` to include any item that would be
			illegal in a `checker_declaration` outside a `checker_generate_item`.
	NOTE 7: In a `parameter_declaration` that is a `class_item`, the `parameter` keyword shall be a
			synonym for the `localparam` keyword.
	NOTE 8: In any one declaration, only one of `protected`, or `local` is allowed, only one of
			`rand` or `randc` is allowed, and `static` and/or `virtual` can appear only once.
	NOTE 9: The `open_range_list` in a `uniqueness_constraint` shall contain only expressions that
			denote scalar or array variables, as described in IEEE 1800-2012 §18.5.5.
	NOTE 10: In a `data_declaration` that is not within a procedural context, it shall be illegal to
			 use the `automatic` keyword. In a `data_declaration`, it shall be illegal to omit the
			 explicit `data_type` before a `list_of_variable_decl_assignments` unless the `var`
			 keyword is used.
	NOTE 11: It shall be illegal to have an import statement directly within a class scope.
	NOTE 12: A charge strength shall only be used with the `trireg` keyword. When the `vectored`
			 or `scalaraed` keyword is used, there shall be at least one packed dimension.
	NOTE 13: When a packed dimension is used within the `struct` or `union` keyword, the `packed`
			 keyword shall also be used.
	NOTE 14: When a `type_reference` is used in a net declaration, it shall be preceded by a net
			 type keyword; and when it is used in a variable declaration, it shall be preceded by
			 the `var` keyword.
	NOTE 15: A `type_identifier` shall be legal as an `enum_base_type` if it denotes an
			 `integer_atom_type`, with which an additional packed dimension is not permitted, or an
			 `integer_vector_type`.
	NOTE 16: It shall be legal to declare a `void` `struct_union_member` only within tagged unions.
	NOTE 17: An expression that is used as the argument in a `type_reference` shall not contain
			 any hierarchical references, or references to elements of dynamic objects.
	NOTE 18: In a `param_assignment` it shall be illegal to omit the `constraint_param_expression`
			 except within a `parameter_declaration` in a `parameter_port_list`. In a
			`type_assignment` it shall be illegal to mit the `data_type` except within a
			`parameter_declaration` in a `parameter_port_list`.
	NOTE 19: In a shallow copy, the expression shall evaluate to an object handle.
	NOTE 20: In `packed_dimension`, `unsized_dimension` is permitted only as the sole packed dimension
			 in a DPI import declaration; see `dpi_function_proto` and `dpi_task_proto`.
	NOTE 21: `dpi_function_proto` return types are restricted to small values per
			 IEEE 1800-2012 §35.5.5.
	NOTE 22: Formals of `dpi_function_proto` and `dpi_task_proto` cannot use pass-by-reference mode,
			 and class types cannot be passed at all; see IEEE 1800-2012 §35.5.6 for a description
			 of allowed types for DPI formal arguments.
	NOTE 23: In a `tf_port_item`, it shall be illegal to omit the explicit `port_identifier` except
			 within a `function_prototype` or `task_prototype`.
	NOTE 24: The `matches` operator shall have higher precedence than the `&&` and `||` operators.
	NOTE 25: It shall be legal to use the `$` primary in an `open_value_range` of the form
			 `[` expression `:` `$` `]` or `[` `$` `:` expression `]`.
	NOTE 26: The result of this expression shall be assignment compatible with an integral type.
	NOTE 27: The expression is restricted as described in IEEE 1800-2012 §19.5.1.2.
	NOTE 28: This expression is restricted as described in IEEE 1800-2012 §19.5.
	NOTE 29: The `.*` token shall appear at most once in a list of port connections.
	NOTE 30: Within an `interface_declaration`, it shall only be legal for a `generate_item` to be
			 an `interface_or_generate_item`. Within a `module_declaration` except when also within
			 an `interface_declaration`, it shall only be legal for a `generate_item` to be a
			 `module_or_generate_item`. Within a `checker_declaration`, it shall only be legal for
			 a `generate_item` to be a `checker_or_generate_item`.
	NOTE 31: Parentheses are required when an event expression that contains comma-separated event
			 expressions is passed as an actual argument using positional binding.
	NOTE 32: In a `constant_assignment_pattern_expression`, all member expressions shall be constant
			 expressions.
	NOTE 33: Embedded spaces are illegal.
	NOTE 34: In a `multiple_concatenation`, it shall be illegal for the multiplier to not be a
			 `constant_expression` unless the type of the concatenation is `string`.
	NOTE 35: `{` `}` shall only be legal in the context of a queue.
	NOTE 36: In a `constant_function_call`, all arguments shall be `constant_expressions`.
	NOTE 37: It shall be illegal to omit the parentheses in a `tf_call` unless the subroutine is a
			 task, `void` function, or class method. If the subroutine is a non-void class function
			 method, it shall be illegal to omit the parentheses if the call is directly recursive.
	NOTE 38: In a `randomize_call` that is not a method call of an object of class type (i.e. a
			 scope randomize), the optional parenthesized `identifier_list` after the keyword
			 `width` shall be illegal, and he use of `null` shall be illegal.
	NOTE 39: A `genvar_identifier` shall be legal in a `constant_primary` only within a
			 `genvar_expression`.
	NOTE 40: It shall be legal to use a `type_reference` `constant_primary` as the `casting_type`
			 in a static cast. It shall be illegal for a `type_reference` `constant_primary` to be
			 used with any operators except the equality/inequality and the case equality/inequality
			 operators.
	NOTE 41: `implicit_class_handle` shall only appear within the scope of a `class_declaration` or
			 out-of-block method declaration.
	NOTE 42: The `$` primary shall be legal only in a `select` for a queue variable, in an
			 `open_value_range`, or as an entire `sequence_actual_arg` or `property_actual_arg`.
	NOTE 43: The `local::` qualifier shall only appear within the scope of an inline constraint
			 block.
	NOTE 44: The unsigned number or fixed-point number in `time_literal` shall not be followed by
			 one or more `white_space`.
	NOTE 45: In a `constant_let_expression`, all arguments shall be `constant_expression`s and its
			 right hand side shall be a `constant_expression` itself provided that its formal
			 arguments are treaded as `constant_primary` there.
	NOTE 46: In a `variable_lvalue` that is assigned within a `sequence_match_item` any `select`
			 shall also be a `constant_select`.
	NOTE 47: A `streaming_concatenation` expression shall not be nested withing another
			 `variable_lvalue`. A `streaming_concatenation` shall not be the target of the increment
			 or decrement operator, nor the target of any assignment operator except the simple (`=`)
			 or nonblocking assignment (`<=`) operator.
	NOTE 48: The apostrophe (`'`) in `unbased_unsized_literal` shall not be followed by one or more
			 `white_space`.
	NOTE 49: A `simple_identifier` or `c_identifier` shall start with [a-zA-Z_], shall have at least
			 one character, and shall not have any spaces.
	NOTE 50: The `$` character in a `system_tf_identifier` shall not be followed by one or more
			 `white_space`. A `system_tf_identifier` shall not be escaped
	NOTE 51: EOF (End Of File) is valid white space.
	NOTE 52: The grave ('`') character may not be followed by `white_space`
*)

(* See NOTE 51 *)
white_space =
	" " | "\t" | "\n"
	;

variable_identifier =
	identifier
	;

udp_identifier =
	identifier
	;

type_identifier =
	identifier
	;

topmodule_identifier =
	identifier
	;

terminal_identifier =
	identifier
	;

tf_identifier =
	identifier
	;

task_identifier =
	identifier
	;

(* See NOTE 50 *)
system_tf_identifier =
	"$", a-zA-Z0-9_$, { a-zA-Z0-9_$ }
	;

specparam_identifier =
	identifier
	;

(* See NOTE 49 *)
simple_identifier =
	a-zA-Z_, { a-zA-Z0-9_$ }
	;

signal_identifier =
	identifier
	;

sequence_identifier =
	identifier
	;

(* See NOTE 43 *)
ps_type_identifier =
	[ "local::" | package_scope ], type_identifier
	;

ps_parameter_identifier =
	[ package_scope | class_scope ], parameter_identifier |
	{ generate_block_identifier, [ "[", constant_expression, "]" ], "." }, parameter_identifier
	;

ps_or_hierarchical_tf_identifier =
	[ package_scope ], tf_identifier |
	hierarchical_tf_identifier
	;

ps_or_hierarchical_sequence_identifier =
	[ package_scope ], sequence_identifier |
	hierarchical_sequence_identifier
	;

ps_or_hierarchical_property_identifier =
	[ package_scope ], property_identifier |
	hierarchical_property_identifier
	;

ps_or_hierarchical_net_identifier =
	[ package_scope ], net_identifier |
	hierarchical_net_identifier
	;

ps_or_hierarchical_array_identifier =
	[ implicit_class_handle, "." | class_scope | package_scope ], hierarchical_array_identifier
	;

ps_identifier =
	[ package_scope ], identifier
	;

ps_checker_identifier =
	[ package_scope ], checker_identifier
	;

ps_covergroup_identifier =
	[ package_scope ], covergroup_identifier
	;

ps_class_identifier =
	[ package_scope ], class_identifier
	;

property_identifier =
	identifier
	;

program_identifier =
	identifier
	;

production_identifier =
	identifier
	;

port_identifier =
	identifier
	;

parameter_identifier =
	identifier
	;

package_scope =
	package_identifier, "::" |
	"$unit", "::"
	;

package_identifier =
	identifier
	;

output_port_identifier =
	identifier
	;

net_type_identifier =
	identifier
	;

net_identifier =
	identifier
	;

module_identifier =
	identifier
	;

modport_identifier =
	identifier
	;

method_identifier =
	identifier
	;

member_identifier =
	identifier
	;

library_identifier =
	identifier
	;

instance_identifier =
	identifier
	;

input_port_identifier =
	identifier
	;

inout_port_identifier =
	identifier
	;

interface_instance_identifier =
	identifier
	;

interface_identifier =
	identifier
	;

index_variable_identifier =
	identifier
	;

identifier =
	simple_identifier |
	escaped_identifier
	;

hierarchical_variable_identifier =
	hierarchical_identifier
	;

hierarchical_tf_identifier =
	hierarchical_identifier
	;

hierarchical_task_identifier =
	hierarchical_identifier
	;

hierarchical_sequence_identifier =
	hierarchical_identifier
	;

hierarchical_property_identifier =
	hierarchical_identifier
	;

hierarchical_parameter_identifier =
	hierarchical_identifier
	;

hierarchical_net_identifier =
	hierarchical_identifier
	;

hierarchical_identifier =
	[ "$root", "." ], { identifier, constant_bit_select, "." }, identifier
	;

hierarchical_event_identifier =
	hierarchical_identifier
	;

hierarchical_block_identifier =
	hierarchical_identifier
	;

hierarchical_array_identifier =
	hierarchical_identifier
	;

genvar_identifier =
	identifier
	;

generate_block_identifier =
	identifier
	;

function_identifier =
	identifier
	;

formal_port_identifier =
	identifier
	;

formal_identifier =
	identifier
	;

escaped_identifier =
	"\\", { ? Any_ASCII_Character_Except_White_Space ? }, white_space
	;

enum_identifier =
	identifier
	;

dynamic_array_variable_identifier =
	variable_identifier
	;

cross_identifier =
	identifier
	;

cover_point_identifier =
	identifier
	;

covergroup_variable_identifier =
	variable_identifier
	;

covergroup_identifier =
	identifier
	;

constraint_identifier =
	identifier
	;

const_identifier =
	identifier
	;

config_identifier =
	identifier
	;

clocking_identifier =
	identifier
	;

class_variable_identifier =
	variable_identifier
	;

class_identifier =
	identifier
	;

checker_identifier =
	identifier
	;

cell_identifier =
	identifier
	;

(* See NOTE 49 *)
c_identifier =
	a-zA-Z_, { a-zA-Z0-9_ }
	;

bin_identifier =
	identifier
	;

block_identifier =
	identifier
	;

array_identifier =
	identifier
	;

comment_text =
	{ ? Any_ASCII_character ? }
	;

block_comment =
	"/*", comment_text, "*/"
	;

one_line_comment =
	"//", comment_text, "\n"
	;

comment =
	one_line_comment |
	block_comment
	;

attr_name =
	identifier
	;

attr_spec =
	attr_name, [ "=", constant_expression ]
	;

attribute_instance =
	"(*", attr_spec, { ",", attr_spec }, "*)"
	;

string_literal =
	'"', { ? Any_ASCII_Characters ? }, '"'
	;

unbased_unsized_literal =
	"'0" |
	"'1" |
	(* See NOTE 48 *)
	"'", z_or_x
	;

z_digit =
	"z" | "Z" | "?"
	;

x_digit =
	"x" | "X"
	;

hex_digit =
	x_digit | z_digit | "0" | "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9" |
	"a" | "b" | "c" | "d" | "e" | "f" |
	"A" | "B" | "C" | "D" | "E" | "F"
	;

octal_digit =
	x_digit | z_digit | "0" | "1" | "2" | "3" | "4" | "5" | "6" | "7"
	;

binary_digit =
	x_digit | z_digit | "0" | "1"
	;

decimal_digit =
	"0" | "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9"
	;

non_zero_decimal_digit =
	"1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9"
	;

(* See NOTE 33 *)
hex_base =
	"'", [ "s" | "S" ], "h" |
	"'", [ "s" | "S" ], "H"
	;

(* See NOTE 33 *)
octal_base =
	"'", [ "s" | "S" ], "o" |
	"'", [ "s" | "S" ], "O"
	;

(* See NOTE 33 *)
binary_base =
	"'", [ "s" | "S" ], "b" |
	"'", [ "s" | "S" ], "B"
	;

(* See NOTE 33 *)
decimal_base =
	"'", [ "s" | "S" ], "d" |
	"'", [ "s" | "S" ], "D"
	;

(* See NOTE 33 *)
hex_value =
	hex_digit, { "_" | hex_digit }
	;

(* See NOTE 33 *)
octal_value =
	octal_digit, { "_" | octal_digit }
	;

(* See NOTE 33 *)
binary_value =
	binary_digit, { "_" | binary_digit }
	;

(* See NOTE 33 *)
unsigned_number =
	decimal_digit, { "_" | decimal_digit }
	;

exp =
	"e" | "E"
	;

(* See NOTE 33 *)
fixed_point_number =
	unsigned_number, ".", unsigned_number
	;

(* See NOTE 33 *)
real_number =
	fixed_point_number |
	unsigned_number, [ ".", unsigned_number ], exp, [ sign ], unsigned_number
	;

(* See NOTE 33 *)
non_zero_unsigned_number =
	non_zero_decimal_digit, { "_" | decimal_digit }
	;

size =
	non_zero_unsigned_number
	;

sign =
	"+" | "-"
	;

hex_number =
	[ size ], hex_base, hex_value
	;

octal_number =
	[ size ], octal_base, octal_value
	;

binary_number =
	[ size ], binary_base, binary_value
	;

decimal_number =
	unsigned_number |
	[ size ], decimal_base, unsigned_number |
	[ size ], decimal_base, x_digit, { "_" } |
	[ size ], decimal_base, z_digit, { "_" }
	;

integral_number =
	decimal_number |
	octal_number |
	binary_number |
	hex_number
	;

number =
	integral_number |
	real_number
	;

binary_module_path_operator =
	"==" | "!=" | "&&" | "||" | "&" | "|" | "^" | "^~" | "~^"
	;

unary_module_path_operator =
	"!" | "~" | "&" | "~&" | "|" | "~|" | "^" | "~^" | "^~"
	;

inc_or_dec_operator =
	"++" | "--"
	;

binary_operator =
	"+" | "-" | "*" | "/" | "%" | "==" | "!=" | "===" | "!==" | "==?" | "!=?" | "&&" | "||" | "**" |
	"<" | "<=" | ">" | ">=" | "&" | "|" | "^" | "^~" | "~^" | ">>" | "<<" | ">>>" | "<<<" |
	"->" | "<->"
	;

unary_operator =
	"+" | "-" | "!" | "~" | "&" | "~&" | "|" | "~|" | "^" | "~^" | "^~"
	;

nonrange_variable_lvalue =
	[ implicit_class_handle, "." | package_scope ], hierarchical_variable_identifier, nonrange_select
	;

variable_lvalue =
	(* See NOTE 46 *)
	[ implicit_class_handle, "." | package_scope ], hierarchical_variable_identifier, select |
	"{", variable_lvalue, { ",", variable_lvalue }, "}" |
	[ assignment_pattern_expression_type ], assignment_pattern_variable_lvalue |
	(* See NOTE 47 *)
	stream_concatenation
	;

net_lvalue =
	ps_or_hierarchical_net_identifier, constant_select |
	"{", net_lvalue, { ",", net_lvalue }, "}" |
	[ assignment_pattern_expression_type ], assignment_pattern_net_lvalue
	;

cast =
	casting_type, "'", "(", expression, ")"
	;

(* See Note 45 *)
constant_let_expression =
	let_expression
	;

constant_cast =
	casting_type, "'", "(", constant_expression, ")"
	;

constant_select =
	[ { ".", member_identifier, constant_bit_select }, ".", member_identifier ], constant_bit_select,
		[ "[", constant_part_select_range ,"]" ]
	;

constant_bit_select =
	{ "[", constant_expression, "]" }
	;

nonrange_select =
	[ { ".", member_identifier, bit_select }, ".", member_identifier ], bit_select
	;

select =
	[ { ".", member_identifier, bit_select }, ".", member_identifier ], bit_select, [ "[", part_select_range ,"]" ]
	;

bit_select =
	{ "[", expression, "]" }
	;

(* See NOTE 41 *)
implicit_class_handle =
	"this" | "super" | "this", ".", "super"
	;

time_unit =
	"s" | "ms" | "us" | "ns" | "ps" | "fs"
	;

(* See NOTE 44 *)
time_literal =
	unsigned_number, time_unit |
	fixed_point_number, time_unit
	;

primary_literal =
	number |
	time_literal |
	unbased_unsized_literal |
	string_literal
	;

range_expression =
	expression |
	part_select_range
	;

class_qualifier =
	(* See NOTE 43 *)
	[ "local::" ], [ implicit_class_handle, "." | class_scope ]
	;

primary =
	primary_literal |
	[ class_qualifier | package_scope ], hierarchical_identifier, select |
	empty_queue |
	concatenation, [ "[", range_expression, "]" ] |
	multiple_concatenation, [ "[", range_expression, "]" ] |
	function_subroutine_call |
	let_expression |
	"(", mintypmax_expression, ")" |
	cast |
	assignment_pattern_expression |
	streaming_concatenation |
	sequence_method_call |
	(* See NOTE 41 *)
	"this" |
	(* See NOTE 42 *)
	"$" |
	"null"
	;

module_path_primary =
	number |
	identifier |
	module_path_concatenation |
	module_path_multiple_concatenation |
	function_subroutine_call |
	"(", module_path_mintypmax_expression, ")"
	;

constant_primary =
	primary_literal |
	ps_parameter_identifier, constant_select |
	specparam_identifier, [ "[", constant_range_expression, "]", ] |
	(* See NOTE 39 *)
	genvar_identifier |
	formal_port_identifier, constant_select |
	[ package_scope | class_scope ], enum_identifier |
	constant_concatenation, [ "[", constant_range_expression, "]" ] |
	constant_multiple_concatenation, [ "[", constant_range_expression, "]" ] |
	constant_function_call |
	constant_let_expression |
	"(", constant_mintypmax_expression, ")" |
	constant_cast |
	constant_assignment_pattern_expression |
	(* See NOTE 40 *)
	type_reference
	;

genvar_expression =
	constant_expression
	;

indexed_range =
	expression, "+:", constant_expression |
	expression, "-:", constant_expression
	;

part_select_range =
	constant_range |
	indexed_range
	;

module_path_mintypmax_expression =
	module_path_expression |
	module_path_expression, ":", module_path_expression, ":", module_path_expression
	;

module_path_expression =
	module_path_primary |
	unary_module_path_operator, { attribute_instance }, module_path_primary |
	module_path_expression, binary_module_path_operator, { attribute_instance }, module_path_expression |
	module_path_conditional_expression
	;

module_path_conditional_expression =
	module_path_expression, "?", { attribute_instance }, module_path_expression, ":", module_path_expression
	;

mintypmax_expression =
	expression |
	expression, ":", expression, ":", expression
	;

value_range =
	expression |
	"[", expression, ":", expression, "]"
	;

inside_expression =
	expression, "inside", { open_range_list }
	;

tagged_union_expression =
	"tagged", member_identifier, [ expression ]
	;

expression =
	primary |
	unary_operator, { attribute_instance }, primary |
	inc_or_dec_expression |
	"(", operator_assignment, ")" |
	expression, binary_operator, { attribute_instance }, expression |
	conditional_expression |
	inside_expression |
	tagged_union_expression
	;

constant_indexed_range =
	constant_expression, "+:", constant_expression |
	constant_expression, "-:", constant_expression
	;

constant_range =
	constant_expression, ":", constant_expression
	;

constant_part_select_range =
	constant_range |
	constant_indexed_range
	;

constant_range_expression =
	constant_expression |
	constant_part_select_range
	;

param_expression =
	mintypmax_expression |
	data_type |
	"$"
	;

constant_param_expression =
	constant_mintypmax_expression |
	data_type |
	"$"
	;

constant_mintypmax_expression =
	constant_expression |
	constant_expression, ":", constant_expression, ":", constant_expression
	;

constant_expression =
	constant_primary |
	unary_operator, { attribute_instance }, constant_primary |
	constant_expression, binary_operator, { attribute_instance }, constant_expression |
	constant_expression, "?", { attribute_instance }, constant_expression, ":", constant_expression
	;

conditional_expression =
	cond_predicate, "?", { attribute_instance }, expression, ":", expression
	;

inc_or_dec_expression =
	inc_or_dec_operator, { attribute_instance }, variable_lvalue |
	variable_lvalue, { attribute_instance }, inc_or_dec_operator
	;

array_method_name =
	method_identifier |
	"unique" |
	"and" |
	"or" |
	"xor"
	;

method_call_root =
	primary |
	implicit_class_handle
	;

(* See NOTE 38 *)
randomize_call =
	"randomize", { attribute_instance }, [ "(", [ variable_identifier_list | "null" ], ")" ],
		[ "with", [ "(", [ identifier_list ], ")" ], constraint_block ]
	;

array_manipulation_call =
	array_method_name, { attribute_instance }, [ "(", list_of_arguments, ")" ],
		[ "with", "(", expression, ")" ]
	;

built_in_method_call =
	array_manipulation_call |
	randomize_call
	;

method_call_body =
	method_identifier, { attribute_instance }, [ "(", list_of_arguments, ")" ] |
	built_in_method_call
	;

method_call =
	method_call_root, ".", method_call_body
	;

list_of_arguments =
	[ expression ], { ",", [ expression ] }, { ",", ".", identifier, "(", [ expression ], ")" } |
	".", identifier, "(", [ expression ], ")", { ",", ".", identifier, "(", [ expression ], ")" }
	;

function_subroutine_call =
	subroutine_call
	;

subroutine_call =
	tf_call |
	system_tf_call |
	method_call |
	[ "std::", ], randomize_call
	;

system_tf_call =
	system_tf_identifier, [ "(", list_of_arguments, ")" ] |
	system_tf_identifier, "(", data_type, [ ",", expression ], ")"
	;

(* See NOTE 37 *)
tf_call =
	ps_or_hierarchical_tf_identifier, { attribute_instance }, [ "(", list_of_arguments, ")" ]
	;

constant_function_call =
	(* See NOTE 36 *)
	function_subroutine_call
	;

(* See NOTE 35 *)
empty_queue =
	"{", "}"
	;

array_range_expression =
	expression |
	expression, ":", expression |
	expression, "+:", expression |
	expression, "-:", expression
	;

stream_expression =
	expression, [ "with", "[", array_range_expression, "]" ]
	;

stream_concatenation =
	"{", stream_expression, { ",", stream_expression }, "}"
	;

slice_size =
	simple_type |
	constant_expression
	;

stream_operator =
	">>" | "<<"
	;

streaming_concatenation =
	"{", stream_operator, [ slice_size ], stream_concatenation, "}"
	;

(* See NOTE 34 *)
multiple_concatenation =
	"{", expression, concatenation, "}"
	;

module_path_multiple_concatenation =
	"{", constant_expression, module_path_concatenation, "}"
	;

module_path_concatenation =
	"{", module_path_expression, { ",", module_path_expression }, "}"
	;

constant_multiple_concatenation =
	"{", constant_expression, constant_concatenation, "}"
	;

constant_concatenation =
	"{", constant_expression, { ",", constant_expression }, "}"
	;

concatenation =
	"{", expression, { ",", expression }, "}"
	;

scalar_constant =
	"1'b0" | "1'b1" | "1'B0" | "1'B1" | "'b0" | "'b1" | "'B0" | "'B1" | "1" | "0"
	;

scalar_timing_check_condition =
	expression |
	"~", expression |
	expression, "==", scalar_constant |
	expression, "!=", scalar_constant |
	expression, "===", scalar_constant |
	expression, "!==", scalar_constant
	;

timing_check_condition =
	scalar_timing_check_condition |
	"(", scalar_timing_check_condition, ")"
	;

z_or_x =
	"x" | "X" | "z" | "Z"
	;

zero_or_one =
	"0" | "1"
	;

(* See NOTE 33 *)
edge_descriptor =
	"01" |
	"10" |
	z_or_x, zero_or_one |
	zero_or_one, z_or_x
	;

edge_control_specifier =
	"edge", "[", edge_descriptor, { ",", edge_descriptor }, "]"
	;

specify_terminal_descriptor =
	specify_input_terminal_descriptor |
	specify_output_terminal_descriptor
	;

timing_check_event_control =
	"posedge" |
	"negedge" |
	"edge" |
	edge_control_specifier
	;

controlled_timing_check_event =
	timing_check_event_control, specify_terminal_descriptor, [ "&&&", timing_check_condition ]
	;

timing_check_event =
	[ timing_check_event_control ], specify_terminal_descriptor, [ "&&&", timing_check_condition ]
	;

timing_check_limit =
	expression
	;

threshold =
	constant_expression
	;

start_edge_offset =
	mintypmax_expression
	;

timestamp_condition =
	mintypmax_expression
	;

remain_active_flag =
	constant_mintypmax_expression
	;

reference_event =
	timing_check_event
	;

notifier =
	variable_identifier
	;

event_based_flag =
	constant_expression
	;

end_edge_offset =
	mintypmax_expression
	;

delayed_reference =
	terminal_identifier |
	terminal_identifier, "[", constant_mintypmax_expression, "]"
	;

delayed_data =
	terminal_identifier |
	terminal_identifier, "[", constant_mintypmax_expression, "]"
	;

data_event =
	timing_check_event
	;

controlled_reference_event =
	controlled_timing_check_event
	;

timecheck_condition =
	mintypmax_expression
	;

nochange_timing_check =
	"$nochange", "(", reference_event, ",", data_event, ",", start_edge_offset, ",", end_edge_offset,
		[ ",", [ notifier ] ],")", ";"
	;

width_timing_check =
	"$width", "(", controlled_reference_event, ",", timing_check_limit, ",", threshold, [ ",", [ notifier ] ],
		")", ";"
	;

period_timing_check =
	"$period", "(", controlled_reference_event, ",", timing_check_limit, [ ",", [ notifier ] ], ")", ";"
	;

fullskew_timing_check =
	"$fullskew", "(", reference_event, ",", data_event, ",", timing_check_limit, ",", timing_check_limit,
		[ ",", [ notifier ], [ ",", [ event_based_flag ], [ ",", [ remain_active_flag ] ] ] ], ")", ";"
	;

timeskew_timing_check =
	"$timeskew", "(", reference_event, ",", data_event, ",", timing_check_limit, [ ",", [ notifier ],
		[ ",", [ event_based_flag ], [ ",", [ remain_active_flag ] ] ] ], ")", ";"
	;

skew_timing_check =
	"$skew", "(", reference_event, ",", data_event, ",", timing_check_limit, [ ",", [ notifier ] ], ")", ";"
	;

recrem_timing_check =
	"$recrem", "(", reference_event, ",", data_event, ",", timing_check_limit, ",", timing_check_limit,
		[ ",", [ notifier ], [ ",", [ timestamp_condition ], [ ",", [ timecheck_condition,
			[ ",", [ delayed_reference ], [ ",", [ delayed_data ] ] ] ] ] ] ], ")", ";"
	;

removal_timing_check =
	"$removal", "(", reference_event, ",", data_event, ",", timing_check_limit, [ ",", [ notifier ] ], ")", ";"
	;

recovery_timing_check =
	"$recovery", "(", reference_event, ",", data_event, ",", timing_check_limit, [ ",", [ notifier ] ], ")", ";"
	;

setuphold_timing_check =
	"$setuphold", "(", reference_event, ",", data_event, ",", timing_check_limit, ",", timing_check_limit,
		[ ",", [ notifier ], [ ",", [ timestamp_condition ], [ ",", [ timecheck_condition,
			[ ",", [ delayed_reference ], [ ",", [ delayed_data ] ] ] ] ] ] ], ")", ";"
	;

hold_timing_check =
	"$hold", "(", reference_event, ",", data_event, ",", timing_check_limit, [ ",", [ notifier ] ], ")", ";"
	;

setup_timing_check =
	"$setup", "(", data_event, ",", reference_event, ",", timing_check_limit, [ ",", [ notifier ] ], ")", ";"
	;

system_timing_check =
	setup_timing_check |
	hold_timing_check |
	setuphold_timing_check |
	recovery_timing_check |
	removal_timing_check |
	recrem_timing_check |
	skew_timing_check |
	timeskew_timing_check |
	fullskew_timing_check |
	period_timing_check |
	width_timing_check |
	nochange_timing_check
	;

polarity_operator =
	"+" | "-"
	;

state_dependent_path_declaration =
	"if", "(", module_path_expression, ")", simple_path_declaration |
	"if", "(", module_path_expression, ")", edge_sensitive_path_declaration |
	"ifnone", simple_path_declaration
	;

edge_identifier =
	"posedge" | "negedge" | "edge"
	;

data_source_expression =
	expression
	;

full_edge_sensitive_path_description =
	"(", [ edge_identifier ], list_of_path_inputs, "*>",
		"(", list_of_path_outputs, [ polarity_operator ], ":", data_source_expression, ")", ")"
	;

parallel_edge_sensitive_path_description =
	"(", [ edge_identifier ], specify_input_terminal_descriptor, "=>",
		"(", specify_output_terminal_descriptor, [ polarity_operator ], ":", data_source_expression, ")", ")"
	;

edge_sensitive_path_declaration =
	parallel_edge_sensitive_path_description, "=", path_delay_value |
	full_edge_sensitive_path_description, "=", path_delay_value
	;

path_delay_expression =
	constant_mintypmax_expression
	;

tzx_path_delay_expression =
	path_delay_expression
	;

txz_path_delay_expression =
	path_delay_expression
	;

tx0_path_delay_expression =
	path_delay_expression
	;

t1x_path_delay_expression =
	path_delay_expression
	;

tx1_path_delay_expression =
	path_delay_expression
	;

t0x_path_delay_expression =
	path_delay_expression
	;

tz0_path_delay_expression =
	path_delay_expression
	;

t1z_path_delay_expression =
	path_delay_expression
	;

tz1_path_delay_expression =
	path_delay_expression
	;

t0z_path_delay_expression =
	path_delay_expression
	;

t10_path_delay_expression =
	path_delay_expression
	;

t01_path_delay_expression =
	path_delay_expression
	;

tz_path_delay_expression =
	path_delay_expression
	;

tfall_path_delay_expression =
	path_delay_expression
	;

trise_path_delay_expression =
	path_delay_expression
	;

t_path_delay_expression =
	path_delay_expression
	;

list_of_path_delay_expressions =
	t_path_delay_expression |
	trise_path_delay_expression, ",", tfall_path_delay_expression |
	trise_path_delay_expression, ",", tfall_path_delay_expression, ",", tz_path_delay_expression, "," |
	t01_path_delay_expression, ",", t10_path_delay_expression, ",", t0z_path_delay_expression, ",",
	tz1_path_delay_expression, ",", t1z_path_delay_expression, ",", tz0_path_delay_expression |
	t01_path_delay_expression, ",", t10_path_delay_expression, ",", t0z_path_delay_expression, ",",
	tz1_path_delay_expression, ",", t1z_path_delay_expression, ",", tz0_path_delay_expression, ",",
	t0x_path_delay_expression, ",", tx1_path_delay_expression, ",", t1x_path_delay_expression, ",",
	tx0_path_delay_expression, ",", txz_path_delay_expression, ",", tzx_path_delay_expression
	;

path_delay_value =
	list_of_path_delay_expressions |
	"(", list_of_path_delay_expressions, ")"
	;

output_identifier =
	output_port_identifier |
	inout_port_identifier |
	interface_identifier, ".", port_identifier
	;

input_identifier =
	input_port_identifier |
	inout_port_identifier |
	interface_identifier, ".", port_identifier
	;

specify_output_terminal_descriptor =
	output_identifier, [ "[", constant_range_expression, "]" ]
	;

specify_input_terminal_descriptor =
	input_identifier, [ "[", constant_range_expression, "]" ]
	;

list_of_path_outputs =
	specify_output_terminal_descriptor, { ",", specify_output_terminal_descriptor }
	;

list_of_path_inputs =
	specify_input_terminal_descriptor, { ",", specify_input_terminal_descriptor }
	;

full_path_description =
	"(", list_of_path_inputs, [ polarity_operator ], "*>", list_of_path_outputs, ")"
	;

parallel_path_description =
	"(", specify_input_terminal_descriptor, [ polarity_operator ], "=>", specify_output_terminal_descriptor, ")"
	;

simple_path_declaration =
	parallel_path_description, "=", path_delay_value |
	full_path_description, "=", path_delay_value
	;

path_declaration =
	simple_path_declaration, ";" |
	edge_sensitive_path_declaration, ";" |
	state_dependent_path_declaration, ";"
	;

showcancelled_declaration =
	"showcancelled", list_of_path_outputs, ";" |
	"noshowcancelled", list_of_path_outputs, ";" |
	;

pulsestyle_declaration =
	"pulsestyle_onevent", list_of_path_outputs, ";" |
	"pulsestyle_ondetect", list_of_path_outputs, ";"
	;

specify_item =
	specparam_declaration |
	pulsestyle_declaration |
	showcancelled_declaration |
	path_declaration |
	system_timing_check |
	;

specify_block =
	"specify", { specify_item }, "endspecify"
	;

rs_case_item =
	case_item_expression, { ",", case_item_expression }, ":", production_item, ";" |
	"default", [ ":" ], production_item, ";"
	;

rs_case =
	"case", "(", case_expression, ")", rs_case_item, { rs_case_item }, "endcase"
	;

rs_repeat =
	"repeat", "(", expression, ")", production_item
	;

rs_if_else =
	"if", "(", expression, ")", production_item, [ "else", production_item ]
	;

production_item =
	production_identifier, [ "(", list_of_arguments, ")" ]
	;

rs_prod =
	production_item |
	rs_code_block |
	rs_if_else |
	rs_repeat |
	rs_case
	;

rs_code_block =
	"{", { data_declaration }, { statement_or_null }, "}"
	;

weight_specification =
	integral_number |
	ps_identifier |
	"(", expression, ")"
	;

rs_production_list =
	rs_prod, { rs_prod } |
	"rand", "join", [ "(", expression, ")" ], production_item, production_item, { production_item }
	;

rs_rule =
	rs_production_list, [ ":=", weight_specification, [ rs_code_block ] ]
	;

production =
	[ data_type_or_void ], production_identifier, [ "(", tf_port_list, ")" ], ":", rs_rule,
		{ "|", rs_rule }, ";"
	;

randsequence_statement =
	"randsequence", "(", [ production_identifier ], ")", production, { production }, "endsequence"
	;

clockvar_expression =
	clockvar, select
	;

clockvar =
	hierarchical_identifier
	;

cycle_delay =
	"##", integral_number |
	"##", identifier |
	"##", "(", expression, ")"
	;

clocking_drive =
	clockvar_expression, "<=", [ cycle_delay ], expression
	;

clocking_skew =
	edge_identifier, [ delay_control ] |
	delay_control
	;

clocking_decl_assign =
	signal_identifier, [ "=", expression ]
	;

list_of_clocking_decl_assign =
	clocking_decl_assign, { ",", clocking_decl_assign }
	;

clocking_direction =
	"input", [ clocking_skew ] |
	"output", [ clocking_skew ] |
	"input", [ clocking_skew ], "output", [ clocking_skew ] |
	"inout"
	;

default_skew =
	"input", clocking_skew |
	"output", clocking_skew |
	"input", clocking_skew, "output", clocking_skew
	;

clocking_item =
	"default", default_skew, ";" |
	clocking_direction, list_of_clocking_decl_assign, ";" |
	{ attribute_instance }, assertion_item_declaration
	;

clocking_event =
	"@", identifier |
	"@", "(", event_expression, ")"
	;

clocking_declaration =
	[ "default" ], "clocking", [ clocking_identifier ], clocking_event, ";", { clocking_item },
		"endclocking", [ ":", clocking_identifier ] |
	"global", "clocking", [ clocking_identifier ], clocking_event, ";", "endclocking",
		[ ":", clocking_identifier ]
	;

deferred_immediate_cover_statement =
	"cover", "#0", "(", expression, ")", statement_or_null |
	"cover", "final", "(", expression, ")", statement_or_null
	;

deferred_immediate_assume_statement =
	"assume", "#0", "(", expression, ")", action_block |
	"assume", "final", "(", expression, ")", action_block
	;

deferred_immediate_assert_statement =
	"assert", "#0", "(", expression, ")", action_block |
	"assert", "final", "(", expression, ")", action_block
	;

deferred_immediate_assertion_statement =
	deferred_immediate_assert_statement |
	deferred_immediate_assume_statement |
	deferred_immediate_cover_statement
	;

simple_immediate_cover_statement =
	"cover", "(", expression, ")", statement_or_null
	;

simple_immediate_assume_statement =
	"assume", "(", expression,")", action_block
	;

simple_immediate_assert_statement =
	"assert", "(", expression, ")", action_block
	;

simple_immediate_assertion_statement =
	simple_immediate_assert_statement |
	simple_immediate_assume_statement |
	simple_immediate_cover_statement
	;

immediate_assertion_statement =
	simple_immediate_assertion_statement |
	deferred_immediate_assertion_statement
	;

procedural_assertion_statement =
	concurrent_assertion_statement |
	immediate_assert_statement |
	checker_instantiation
	;

deferred_immediate_assertion_item =
	[ block_identifier, ":" ], deferred_immediate_assertion_statement
	;

assertion_item =
	concurrent_assertion_item |
	deferred_immediate_assertion_item
	;

subroutine_call_statement =
	subroutine_call, ";" |
	"void", "'", "(", function_subroutine_call, ")", ";"
	;

loop_variables =
	[ index_variable_identifier ], { ",", [ index_variable_identifier ] }
	;

for_step_assignment =
	operator_assignment |
	inc_or_dec_expression |
	function_subroutine_call
	;

for_step =
	for_step_assignment, { ",", for_step_assignment }
	;

(* See NOTE 14 *)
for_variable_declaration =
	[ "var" ], data_type, variable_identifier, "=", expression, { ",", variable_identifier, "=", expression }
	;

for_initialization =
	list_of_variable_assignments |
	for_variable_declaration, { ",", for_variable_declaration }
	;

loop_statement =
	"forever", statement_or_null |
	"repeat", "(", expression, ")", statement_or_null |
	"while", "(", expression, ")", statement_or_null |
	"for", "(", [ for_initialization ], ";", [ expression ], ";", [ for_step ], ")", statement_or_null |
	"do", statement_or_null, "while", "(", expression, ")", ";" |
	"foreach", "(", ps_or_hierarchical_array_identifier, "[", loop_variables, "]", ")", statement
	;

assignment_pattern_variable_lvalue =
	"'", "{", variable_lvalue, { ",", variable_lvalue }, "}"
	;

assignment_pattern_net_lvalue =
	"'", "{", net_lvalue, { ",", net_lvalue }, "}"
	;

(* See NOTE 32 *)
constant_assignment_pattern_expression =
	assignment_pattern_expression
	;

assignment_pattern_expression_type =
	ps_type_identifier |
	ps_parameter_identifier |
	integer_atom_type |
	type_reference
	;

assignment_pattern_expression =
	[ assignment_pattern_expression_type ], assignment_pattern
	;

assignment_pattern_key =
	simple_type |
	"default"
	;

array_pattern_key =
	constant_expression |
	assignment_pattern_key
	;

structure_pattern_key =
	member_identifier |
	assignment_pattern_key
	;

assignment_pattern =
	"'", "{", expression, { ",", expression }, "}" |
	"'", "{", structure_pattern_key, ":", expression, { ",", structure_pattern_key, ":", expression }, "}" |
	"'", "{", array_pattern_key, ":", expression, { ",", array_pattern_key, ":", expression }, "}" |
	"'", "{", constant_expression, "{", expression, { ",", expression }, "}", "}"
	;

pattern =
	".", variable_identifier |
	".*" |
	constant_expression |
	"tagged", member_identifier, [ pattern ] |
	"'", "{", pattern, { ",", pattern }, "}" |
	"'", "{", member_identifier, ":", pattern, { ",", member_identifier, ":", pattern }, "}"
	;

(* See NOTE 25 *)
open_value_range =
	value_range
	;

open_range_list =
	open_value_range, { ",", open_value_range }
	;

randcase_item =
	expression, ":", statement_or_null
	;

randcase_statement =
	"randcase", randcase_item, { randcase_item }, "endcase"
	;

case_item_expression =
	expression
	;

case_inside_item =
	open_range_list, ":", statement_or_null |
	"default", [ ":" ], statement_or_null
	;

case_pattern_item =
	pattern, [ "&&&", expression ], ":", statement_or_null |
	"default", [ ":" ], statement_or_null
	;

case_item =
	case_item_expression, { ",", case_item_expression }, ":", statement_or_null |
	"default", [ ":" ], statement_or_null
	;

case_expression =
	expression
	;

case_keyword =
	"case" | "casez" | "casex"
	;

case_statement =
	[ unique_priority ], case_keyword, "(", case_expression, ")", case_item, { case_item }, "endcase" |
	[ unique_priority ], case_keyword, "(", case_expression, ")", "matches",
		case_pattern_item, { case_pattern_item }, "endcase" |
	[ unique_priority ], "case", "(", case_expression, ")", "inside",
		case_inside_item, { case_inside_item }, "endcase"
	;

cond_pattern =
	expression, "matches", pattern
	;

expression_or_cond_pattern =
	expression |
	cond_pattern
	;

cond_predicate =
	expression_or_cond_pattern, { "&&&", expression_or_cond_pattern }
	;

unique_priority =
	"unique" | "unique0" | "priority"
	;

conditional_statement =
	[ unique_priority ], "if", "(", cond_predicate, ")", statement_or_null,
		{ "else", "if", "(", cond_predicate, ")", statement_or_null }, [ "else", statement_or_null ]
	;

disable_statement =
	"disable", hierarchical_task_identifier, ";" |
	"disable", hierarchical_block_identifier, ";" |
	"disable", "fork", ";"
	;

event_trigger =
	"->", hierarchical_event_identifier, ";" |
	"->>", [ delay_or_event_control ], hierarchical_event_identifier, ";"
	;

wait_statement =
	"wait", "(", expression, ")", statement_or_null |
	"wait", "fork", ";" |
	"wait_order", "(", hierarchical_identifier, { ",", hierarchical_identifier }, ")", action_block
	;

jump_statement =
	"return", [ expression ], ";" |
	"break", ";" |
	"continue", ";"
	;

procedural_timing_control =
	delay_control |
	event_control |
	cycle_delay
	;

(* See NOTE 31 *)
event_expression =
	[ edge_identifier ], expression, [ "iff", expression ] |
	sequence_instance, [ "iff", expression ] |
	event_expression, "or", event_expression |
	event_expression, ",", event_expression |
	"(", event_expression, ")"
	;

event_control =
	"@", hierarchical_event_identifier |
	"@", "(", event_expression, ")" |
	"@", "*" |
	"@", "(", "*", ")" |
	"@", ps_or_hierarchical_sequence_identifier
	;

delay_control =
	"#", delay_value |
	"#", "(", mintypmax_expression, ")"
	;

delay_or_event_control =
	delay_control |
	event_control |
	"repeat", "(", expression, ")", event_control
	;

procedural_timing_control_statement =
	procedural_timing_control, statement_or_null
	;

variable_identifier_list =
	variable_identifier, { ",", variable_identifier }
	;

function_statement_or_null =
	function_statement |
	{ attribute_instance }, ";"
	;

function_statement =
	statement
	;

statement_item =
	blocking_assignment, ";" |
	nonblocking_assignment, ";" |
	procedural_continuous_assignments, ";" |
	case_statement |
	conditional_statement |
	inc_or_dec_expression, ";" |
	subroutine_call_statement |
	disable_statement |
	event_trigger |
	loop_statement |
	jump_statement |
	par_block |
	procedural_timing_control_statement |
	seq_block |
	wait_statement |
	procedural_assertion_statement |
	clocking_drive, ";" |
	randsequence_statement |
	randcase_statement |
	expect_property_statement
	;

statement =
	[ block_identifier, ":" ], { attribute_instance }, statement_item
	;

statement_or_null =
	statement |
	{ attribute_instance }, ";"
	;

join_keyword =
	"join" | "join_any" | "join_none"
	;

par_block =
	"fork", [ ":", block_identifier ], { block_item_declaration }, { statement_or_null },
		join_keyword, [ ":", block_identifier ]
	;

seq_block =
	"begin", [ ":", block_identifier ], { block_item_declaration }, { statement_or_null },
		"end", [ ":", block_identifier ]
	;

action_block =
	statement_or_null |
	[ statement ], "else", statement_or_null
	;

variable_assignment =
	variable_lvalue, "=", expression
	;

procedural_continuous_assignments =
	"assign", variable_assignment |
	"deassign", variable_lvalue |
	"force", variable_assignment |
	"force", net_assignment |
	"release", variable_lvalue |
	"release", net_lvalue
	;

nonblocking_assignment =
	variable_lvalue, "<=", [ delay_or_event_control ], expression
	;

assignment_operator =
	"=" | "+=" | "-=" | "*=" | "/=" | "%=" | "&=" | "|=" | "^=" | "<<=" | ">>=" | "<<<=" | ">>>="
	;

operator_assignment =
	variable_lvalue, assignment_operator, expression
	;

blocking_assignment =
	variable_lvalue, "=", delay_or_event_control, expression |
	nonrange_variable_lvalue, "=", dynamic_array_new |
	[ implicit_class_handle, "." | class_scope | package_scope ], hierarchical_variable_identifier,
		select, "=", class_new |
	operator_assignment
	;

final_construct =
	"final", function_statement
	;

always_keyword =
	"always" | "always_comb" | "always_latch" | "always_ff"
	;

always_construct =
	always_keyword, statement
	;

initial_construct =
	"initial", statement_or_null
	;

net_assignment =
	net_lvalue, "=", expression
	;

net_alias =
	"alias", net_lvalue, "=", net_lvalue, { "=", net_lvalue }, ";"
	;

list_of_variable_assignments =
	variable_assignment, { ",", variable_assignment }
	;

list_of_net_assignments =
	net_assignment, { ",", net_assignment }
	;

continuous_assign =
	"assign", [ drive_strength ], [ delay3 ], list_of_net_assignments, ";" |
	"assign", [ delay_control ], list_of_variable_assignments, ";"
	;

udp_instance =
	[ name_of_instance ], "(", output_terminal, ",", input_terminal, { ",", input_terminal }, ")"
	;

udp_instantiation =
	udp_identifier, [ drive_strength ], [ delay2 ], udp_instance, { ",", udp_instance }, ";"
	;

edge_symbol =
	"r" | "R" | "f" | "F" | "p" | "P" | "n" | "N" | "*"
	;

level_symbol =
	"0"| "1" | "x" | "X" | "?" | "b" | "B"
	;

output_symbol =
	"0" | "1" | "x" | "X"
	;

next_state =
	output_symbol | "-"
	;

current_state =
	level_symbol
	;

edge_indicator =
	"(", level_symbol, level_symbol, ")" |
	edge_symbol
	;

edge_input_list =
	{ level_symbol }, edge_indicator, { level_symbol }
	;

level_input_list =
	level_symbol, { level_symbol }
	;

seq_input_list =
	level_input_list |
	edge_input_list
	;

sequential_entry =
	seq_input_list, ":", current_state, ":", next_state, ";"
	;

init_val =
	"1'b0" | "1'b1" | "1'bx" | "1'bX" | "1'B0" | "1'B1" | "1'Bx" | "1'BX" | "1" | "0"
	;

udp_initial_statement =
	"initial", output_port_identifier, "=", init_val, ";"
	;

sequential_body =
	[ udp_initial_statement ], "table", sequential_entry, { sequential_entry }, "endtable"
	;

combinational_entry =
	level_input_list, ":", output_symbol, ";"
	;

combinational_body =
	"table", combinational_entry, { combinational_entry }, "endtable"
	;

udp_body =
	combinational_body |
	sequential_body
	;

udp_reg_declaration =
	{ attribute_instance }, "reg", variable_identifier
	;

udp_input_declaration =
	{ attribute_instance }, "input", list_of_udp_port_identifiers
	;

udp_output_declaration =
	{ attribute_instance }, "output", port_identifier |
	{ attribute_instance }, "output", "reg", port_identifier, [ "=", constant_expression ]
	;

udp_port_declaration =
	udp_output_declaration, ";" |
	udp_input_declaration, ";" |
	udp_reg_declaration, ";"
	;

udp_declaration_port_list =
	udp_output_declaration, ",", udp_input_declaration, { ",", udp_input_declaration }
	;

udp_port_list =
	output_port_identifier, ",", input_identifier, { ",", input_port_identifier }
	;

udp_declaration =
	udp_nonansi_declaration, udp_port_declaration, { udp_port_declaration }, udp_body, "endprimitive",
		[ ":", udp_identifier ] |
	udp_ansi_declaration, udp_body, "endprimitive", [ ":", udp_identifier ] |
	"extern", udp_nonansi_declaration |
	"extern", udp_ansi_declaration |
	{ attribute_instance }, "primitive", udp_identifier, "(", ".*", ")", ";", { udp_port_declaration },
		udp_body, "endprimitive", [ ":", udp_identifier ]
	;

udp_ansi_declaration =
	{ attribute_instance }, "primitive", udp_identifier, "(", udp_declaration_port_list, ")", ";"
	;

udp_nonansi_declaration =
	{ attribute_instance }, "primitive", udp_identifier, "(", udp_port_list, ")", ";"
	;

(* See NOTE 30 *)
generate_item =
	module_or_generate_item |
	interface_or_generate_item |
	checker_or_generate_item
	;

generate_block =
	generate_item |
	[ generate_block_identifier, ":" ], "begin", [ ":", generate_block_identifier ],
		{ generate_item }, "end", [ ":", generate_block_identifier ]
	;

case_generate_item =
	constant_expression, { ",", constant_expression }, ":", generate_block |
	"default", [ ":" ], generate_block
	;

case_generate_construct =
	"case", "(", constant_expression, ")", case_generate_item, { case_generate_item }, "endcase"
	;

if_generate_construct =
	"if", "(", constant_expression, ")", generate_block, [ "else", generate_block ]
	;

conditional_generate_construct =
	if_generate_construct |
	case_generate_construct
	;

genvar_iteration =
	genvar_identifier, assignment_operator, genvar_expression |
	inc_or_dec_operator, genvar_identifier |
	genvar_identifier, inc_or_dec_operator
	;

genvar_initialization =
	[ "genvar" ], genvar_identifier, "=", constant_expression
	;

loop_generate_construct =
	"for", "(", genvar_initialization, ";", genvar_expression, ";", genvar_iteration, ")", generate_block
	;

generate_region =
	"generate", { generate_item }, "endgenerate"
	;

named_checker_port_connection =
	{ attribute_instance }, ".", formal_port_identifier, [ "(", [ property_actual_arg ], ")" ] |
	{ attribute_instance }, ".*"
	;

ordered_checker_port_connection =
	{ attribute_instance }, [ property_actual_arg ]
	;

(* See NOTE 29 *)
list_of_checker_port_connections =
	ordered_checker_port_connection, { ",", ordered_checker_port_connection } |
	named_checker_port_connection, { ",", named_checker_port_connection }
	;

checker_instantiation =
	ps_checker_identifier, name_of_instance, "(", [ list_of_checker_port_connections ], ")", ";"
	;

program_instantiation =
	program_identifier, [ parameter_value_assignment ], hierarchical_instance, { ",", hierarchical_instance }, ";"
	;

interface_instantiation =
	interface_identifier, [ parameter_value_assignment ], hierarchical_instance, { ",", hierarchical_instance }, ";"
	;

named_port_connection =
	{ attribute_instance }, ".", port_identifier, [ "(", [ expression ], ")" ] |
	{ attribute_instance }, ".*"
	;

ordered_port_connection =
	{ attribute_instance }, [ expression ]
	;

(* See NOTE 29 *)
list_of_port_connections =
	ordered_port_connection, { ",", ordered_port_connection } |
	named_port_connection, { ",", named_port_connection }
	;

name_of_instance =
	instance_identifier, { unpacked_dimension }
	;

hierarchical_instance =
	name_of_instance, "(", [ list_of_port_connections ], ")"
	;

named_parameter_assignment =
	".", parameter_identifier, "(", [ param_expression ], ")"
	;

ordered_parameter_assignment =
	param_expression
	;

list_of_parameter_assignments =
	ordered_parameter_assignment, { ",", ordered_parameter_assignment } |
	named_parameter_assignment, { ",", named_parameter_assignment }
	;

parameter_value_assignment =
	"#", "(", [ list_of_parameter_assignments ], ")"
	;

module_instantiation =
	module_identifier, [ parameter_value_assignment ], hierarchical_instance, { ",", hierarchical_instance }, ";"
	;

pass_switchtype =
	"tran" | "rtran"
	;

pass_en_switchtype =
	"tranif0" | "tranif1" | "rtranif1" | "rtranif0"
	;

n_output_gatetype =
	"buf" | "not"
	;

n_input_gatetype =
	"and" | "nand" | "or" | "nor" | "xor" | "xnor"
	;

mos_switchtype =
	"nmos" | "pmos" | "rnmos" | "rpmos"
	;

enable_gatetype =
	"bufif0" | "bufif1" | "notif0" | "notif1"
	;

cmos_switchtype =
	"cmos" | "rcmos"
	;

pcontrol_terminal =
	expression
	;

output_terminal =
	net_lvalue
	;

ncontrol_terminal =
	expression
	;

input_terminal =
	expression
	;

inout_terminal =
	net_lvalue
	;

enable_terminal =
	expression
	;

pullup_strength =
	"(", strength0, strength1, ")" |
	"(", strength1, strength0, ")" |
	"(", strength1, ")"
	;

pulldown_strength =
	"(", strength0, strength1, ")" |
	"(", strength1, strength0, ")" |
	"(", strength0, ")"
	;

pull_gate_instance =
	[ name_of_instance ], "(", output_terminal, ")"
	;

pass_enable_switch_instance =
	[ name_of_instance ], "(", inout_terminal, ",", inout_terminal, ",", enable_terminal, ")"
	;

pass_switch_instance =
	[ name_of_instance ], "(", inout_terminal, ",", inout_terminal, ")"
	;

n_output_gate_instance =
	[ name_of_instance ], "(", output_terminal, { ",", output_terminal }, ",", input_terminal, ")"
	;

n_input_gate_instance =
	[ name_of_instance ], "(", output_terminal, ",", input_terminal, { ",", input_terminal }, ")"
	;

mos_switch_instance =
	[ name_of_instance ], "(", output_terminal, ",", input_terminal, ",", enable_terminal, ")"
	;

enable_gate_instance =
	[ name_of_instance ], "(", output_terminal, ",", input_terminal, ",", enable_terminal, ")"
	;

cmos_switch_instance =
	[ name_of_instance ], "(", output_terminal, ",", input_terminal, ",", ncontrol_terminal, ",", pcontrol_terminal, ")"
	;

gate_instantiation =
	cmos_switchtype, [ delay3 ], cmos_switch_instance, { ",", cmos_switch_instance }, ";"|
	enable_gatetype, [ drive_strength ], [ delay3 ], enable_gate_instance, { ",", enable_gate_instance }, ";" |
	mos_switchtype, [ delay3 ], mos_switch_instance, { ",", mos_switch_instance }, ";" |
	n_input_gatetype, [ drive_strength ], [ delay2 ], n_input_gate_instance, { ",", n_input_gate_instance }, ";" |
	n_output_gatetype, [ drive_strength ], [ delay2 ], n_output_gate_instance, { ",", n_output_gate_instance }, ";" |
	pass_en_switchtype, [ delay2 ], pass_enable_switch_instance, { ",", pass_enable_switch_instance }, ";" |
	pass_switchtype, pass_switch_instance, { ",", pass_switch_instance }, ";" |
	"pulldown", [ pulldown_strength ], pull_gate_instance, { ",", pull_gate_instance }, ";" |
	"pullup", [ pullup_strength ], pull_gate_instance, { ",", pull_gate_instance }, ";"
	;

(* See NOTE 28 *)
covergroup_expression =
	expression
	;

cross_set_expression =
	covergroup_expression
	;

integer_covergroup_expression =
	covergroup_expression
	;

(* See NOTE 27 *)
set_covergroup_expression =
	covergroup_expression
	;

(* See NOTE 26 *)
with_covergroup_expression =
	covergroup_expression
	;

covergroup_value_range =
	covergroup_expression |
	(* See NOTE 25 *)
	"[", covergroup_expression, ":", covergroup_expression, "]"
	;

covergroup_range_list =
	covergroup_value_range, { ",", covergroup_value_range }
	;

bins_expression =
	variable_identifier |
	cover_point_identifier, [ ".", bin_identifier ]
	;

select_condition =
	"binsof", "(", bins_expression, ")", [ "intersect", "{", covergroup_range_list, "}" ]
	;

(* See NOTE 24 *)
select_expression =
	select_condition |
	"!", select_condition |
	select_expression, "&&", select_expression |
	select_expression, "||", select_expression |
	"(", select_expression, ")" |
	select_expression, "with", "(", with_covergroup_expression, ")", [ "matches", integer_covergroup_expression ] |
	cross_identifier |
	cross_set_expression, [ "matches", integer_covergroup_expression ]
	;

bins_selection =
	bins_keyword, bin_identifier, "=", select_expression, [ "iff", "(", expression, ")" ]
	;

bins_selection_or_option =
	{ attribute_instance }, coverage_option |
	{ attribute_instance }, bins_selection
	;

cross_body_item =
	function_declaration |
	bins_selection_or_option, ";"
	;

cross_body =
	"{", { cross_body_item, ";" }, "}" |
	";"
	;

cross_item =
	cover_point_identifier |
	variable_identifier
	;

list_of_cross_items =
	cross_item, ",", cross_body_item, { ",", cross_item }
	;

cover_cross =
	[ cross_identifier, ":" ], "cross", list_of_cross_items, [ "iff", "(", expression, ")" ],
		cross_body
	;

repeat_range =
	covergroup_expression |
	covergroup_expression, ":", covergroup_expression
	;

trans_item =
	covergroup_range_list
	;

trans_range_list =
	trans_item |
	trans_item, [ "[", "*", repeat_range, "]" ] |
	trans_item, [ "[", "->", repeat_range, "]" ] |
	trans_item, [ "[", "=", repeat_range, "]" ]
	;

trans_set =
	trans_range_list, { "=>", trans_range_list }
	;

trans_list =
	"(", trans_set, ")", { ",", "(", trans_set, ")" }
	;

range_list =
	value_range, { ",", value_range }
	;

bins_keyword =
	"bins" | "illegal_bins" | "ignore_bins"
	;

bins_or_options =
	coverage_option |
	[ "wildcard" ], bins_keyword, bin_identifier, [ "[", [ covergroup_expression ], "]" ], "=",
		"{", covergroup_range_list, "}", [ "with", "(", with_covergroup_expression, ")" ],
		[ "iff", "(", expression, ")" ] |
	[ "wildcard" ], bins_keyword, bin_identifier, [ "[", [ covergroup_expression ], "]" ], "=",
		cover_point_identifier, [ "with", "(", with_covergroup_expression, ")" ],
		[ "iff", "(", expression, ")" ] |
	[ "wildcard" ], bins_keyword, bin_identifier, [ "[", [ covergroup_expression ], "]" ], "=",
		set_covergroup_expression, [ "iff", "(", expression, ")" ] |
	[ "wildcard" ], bins_keyword, bin_identifier, [ "[", "]" ], "=", trans_list,
		[ "iff", "(", expression, ")" ] |
	bins_keyword, bin_identifier, [ "[", [ covergroup_expression ], "]" ], "=", "default",
		[ "iff", "(", expression, ")" ] |
	bins_keyword, bin_identifier, "=", "default", "sequence", [ "iff", "(", expression, ")" ]
	;

bins_or_empty =
	"{", { attribute_instance }, { bins_or_options, ";" }, "}" |
	";"
	;

cover_point =
	[ [ data_type_or_implicit ], cover_point_identifier, ":" ], "coverpoint", expression,
		[ "iff", "(", expression, ")" ], bins_or_empty
	;

hierarchical_btf_identifier =
	hierarchical_tf_identifier |
	hierarchical_block_identifier |
	[ hierarchical_identifier, "." | class_scope ], method_identifier
	;

block_event_expression =
	block_event_expression, "or", block_event_expression |
	"begin", hierarchical_btf_identifier |
	"end", hierarchical_btf_identifier
	;

coverage_event =
	clocking_event |
	"with", "function", "sample", "(", [ tf_port_list ], ")" |
	"@", "@", "(", block_event_expression, ")"
	;

coverage_spec =
	cover_point |
	cover_cross
	;

coverage_option =
	"option", ".", member_identifier, "=", expression |
	"type_option", ".", member_identifier, "=", expression
	;

coverage_spec_or_option =
	{ attribute_instance }, coverage_spec |
	{ attribute_instance }, coverage_option, ";"
	;

covergroup_declaration =
	"covergroup", covergroup_identifier, [ "(", [ tf_port_list ], ")" ], [ coverage_event ], ";",
		{ coverage_spec_or_option }, "endgroup", [ ":", covergroup_identifier ]
	;

let_actual_arg =
	expression
	;

let_list_of_arguments =
	[ let_actual_arg ], { ",", [ let_actual_arg ] }, { ".", identifier, "(", [ let_actual_arg ], ")" } |
	".", identifier, "(", [ let_actual_arg ], ")", { ",", ".", identifier,"(", [ let_actual_arg ], ")" }
	;

let_expression =
	[ package_scope ], let_identifier, [ "(", [ let_list_of_arguments ], ")" ]
	;

let_formal_type =
	data_type_or_implicit |
	"untyped"
	;

let_port_item =
	{ attribute_instance }, let_formal_type, formal_port_identifier, { variable_dimension }, [ "=", expression ]
	;

let_port_list =
	let_port_item, { ",", let_port_item }
	;

let_identifier =
	identifier
	;

let_declaration =
	"let", let_identifier, [ "(", [ let_port_list ], ")" ], "=", expression, ";"
	;

assertion_variable_declaration =
	var_data_type, list_of_variable_decl_assignments, ";"
	;

expression_or_dist =
	expression, [ "dist", "{", dist_list, "}" ]
	;

cycle_delay_const_range_expression =
	constant_expression, ":", constant_expression |
	constant_expression, ":", "$"
	;

const_or_range_expression =
	constant_expression |
	cycle_delay_const_range_expression
	;

goto_repetition =
	"[", "->", const_or_range_expression, "]"
	;

non_consecutive_repetition =
	"[", "=", const_or_range_expression, "]"
	;

consecutive_repetition =
	"[", "*", const_or_range_expression, "]" |
	"[", "*", "]" |
	"[", "+", "]"
	;

sequence_abbrev =
	consecutive_repetition
	;

boolean_abbrev =
	consecutive_repetition |
	non_consecutive_repetition |
	goto_repetition
	;

sequence_actual_arg =
	event_expression |
	sequence_expr
	;

sequence_list_of_arguments =
	[ sequence_actual_arg ], { ",", [ sequence_actual_arg ] }, { ",", ".", identifier, "(", [ sequence_actual_arg ], ")" } |
	".", identifier, "(", [ sequence_actual_arg ], ")", { ",", identifier, "(", [ sequence_actual_arg, ], ")" }
	;

sequence_instance =
	ps_or_hierarchical_sequence_identifier, [ "(", [ sequence_list_of_arguments ], ")" ]
	;

sequence_match_item =
	operator_assignment |
	inc_or_dec_expression |
	subroutine_call
	;

sequence_method_call =
	sequence_instance, ".", method_identifier
	;

cycle_delay_range =
	"##", constant_primary |
	"##", "[", cycle_delay_const_range_expression, "]" |
	"##", "[", "*", "]" |
	"##", "[", "+", "]"
	;

sequence_expr =
	cycle_delay_range, sequence_expr, { cycle_delay_range, sequence_expr, } |
	sequence_expr, cycle_delay_range, sequence_expr, { cycle_delay_range, sequence_expr, } |
	expression_or_dist, [ boolean_abbrev ] |
	sequence_instance, [ sequence_abbrev ] |
	"(", sequence_expr, { ",", sequence_match_item, }, ")", [ sequence_abbrev ] |
	sequence_expr, "and", sequence_expr |
	sequence_expr, "intersect", sequence_expr |
	sequence_expr, "or", sequence_expr |
	"first_match", "(", sequence_expr, { ",", sequence_match_item }, ")" |
	expression_or_dist, "throughout", sequence_expr |
	sequence_expr, "within", sequence_expr |
	clocking_event, sequence_expr
	;

sequence_formal_type =
	data_type_or_implicit |
	"sequence" |
	"untyped"
	;

sequence_lvar_port_direction =
	"input" |
	"inout" |
	"output"
	;

sequence_port_item =
	{ attribute_instance }, [ "local", [ sequence_lvar_port_direction ] ], sequence_formal_type,
		port_identifier, { variable_dimension }, [ "=", sequence_actual_arg ]
	;

sequence_port_list =
	sequence_port_item, { ",", sequence_port_item }
	;

sequence_declaration =
	"sequence", sequence_identifier, [ "(", [ sequence_port_list ], ")" ], ";", { assertion_variable_declaration },
		sequence_expr, [ ";" ], "endsequence", [ ":", sequence_identifier ]
	;

property_case_item =
	expression_or_dist, { ",", expression_or_dist }, ":", property_expr |
	"default", [ ":" ], property_expr, [ ";" ]
	;

property_expr =
	sequence_expr |
	"strong", "(", sequence_expr, ")" |
	"weak", "(", sequence_expr, ")" |
	"(", property_expr, ")" |
	"not", property_expr |
	property_expr, "or", property_expr |
	property_expr, "and", property_expr |
	sequence_expr, "|->", property_expr |
	sequence_expr, "|=>", property_expr |
	"if", "(", expression_or_dist, ")", property_expr, [ "else", property_expr ] |
	"case", "(", expression_or_dist, ")", property_case_item, { property_case_item }, "endcase" |
	sequence_expr, "#-#", property_expr |
	sequence_expr, "#=#", property_expr |
	"nexttime", property_expr |
	"nexttime", "[", constant_range, "]", property_expr |
	"s_nexttime", property_expr |
	"s_nexttime", "[", constant_range, "]", property_expr |
	"always", property_expr |
	"always", "[", cycle_delay_const_range_expression, "]", property_expr |
	"s_always", "[", constant_range, "]", property_expr |
	"s_eventually", property_expr |
	"eventually", "[", constant_range, "]", property_expr |
	"s_eventually", "[", cycle_delay_const_range_expression, "]", property_expr |
	property_expr, "until", property_expr |
	property_expr, "s_until", property_expr |
	property_expr, "until_with", property_expr |
	property_expr, "s_until_with", property_expr |
	property_expr, "implies", property_expr |
	property_expr, "iff", property_expr |
	"accept_on", "(", expression_or_dist, ")", property_expr |
	"reject_on", "(", expression_or_dist, ")", property_expr |
	"sync_accept_on", "(", expression_or_dist, ")", property_expr |
	"sync_reject_on", "(", expression_or_dist, ")", property_expr |
	property_instance |
	clocking_event, property_expr
	;

property_spec =
	[ clocking_event ], [ "disable", "iff", "(", expression_or_dist, ")" ], property_expr
	;

property_formal_type =
	sequence_formal_type |
	"property"
	;

property_lvar_port_direction =
	"input"
	;

property_port_item =
	{ attribute_instance }, [ "local", [ property_lvar_port_direction ] ], property_formal_type,
		formal_port_identifier, { variable_dimension }, [ "=", property_actual_arg ]
	;

property_port_list =
	property_port_item, { ",", property_port_item }
	;

property_declaration =
	"property", property_identifier, [ "(", [ property_port_list ], ")" ], ";", { assertion_variable_declaration },
		property_spec, [ ";" ], "endproperty", [ ":", property_identifier ]
	;

assertion_item_declaration =
	property_declaration |
	sequence_declaration |
	let_declaration
	;

property_actual_arg =
	property_expr |
	sequence_actual_arg
	;

property_list_of_arguments =
	[ property_actual_arg ], { ",", [ property_actual_arg ] }, { ",", ".", identifier, "(", [ property_actual_arg ], ")" } |
	".", identifier, "(", [ property_actual_arg ], ")", { ",", ".", identifier, "(", [ property_actual_arg ], ")" }
	;

property_instance =
	ps_or_hierarchical_property_identifier, [ "(", [ property_list_of_arguments ], ")" ]
	;

restrict_property_statement =
	"restrict", "property", "(", property_spec, ")", ";"
	;

cover_sequence_statement =
	"cover", "sequence", "(", [ clocking_event ], [ "disable", "iff", "(", expression_or_dist, ")" ],
		sequence_expr, ")", statement_or_null
	;

expect_property_statement =
	"expect", "(", property_spec, ")", action_block
	;

cover_property_statement =
	"cover", "property", "(", property_spec, ")", statement_or_null
	;

assume_property_statement =
	"assume", "property", "(", property_spec, ")", action_block
	;

assert_property_statement =
	"assert", "property", "(", property_sepc, ")", action_block
	;

concurrent_assertion_statement =
	assert_property_statement |
	assume_property_statement |
	cover_property_statement |
	cover_sequence_statement |
	restrict_property_statement
	;

concurrent_assertion_item =
	[ block_identifier, ":" ], concurrent_assertion_statement |
	checker_instantiation
	;

import_export =
	"import" | "export"
	;

modport_tf_port =
	method_prototype |
	tf_identifier
	;

modport_tf_ports_declaration =
	import_export, modport_tf_port, { ",", modport_tf_port }
	;

modport_simple_port =
	port_identifier |
	".", port_identifier, "(", [ expression ], ")"
	;

modport_simple_ports_declaration =
	port_direction, modport_simple_port, { ",", modport_simple_port }
	;

modport_clocking_declaration =
	"clocking", clocking_identifier
	;

modport_ports_declaration =
	{ attribute_instance }, modport_simple_ports_declaration |
	{ attribute_instance }, modport_tf_ports_declaration |
	{ attribute_instance }, modport_clocking_declaration
	;

modport_item =
	modport_identifier, "(", modport_ports_declaration, { ",", modport_ports_declaration }, ")"
	;

modport_declaration =
	"modport", modport_item, { ",", modport_item }
	;

overload_proto_formals =
	data_type, { ",", data_type }
	;

overload_operator =
	"+" | "++" | "-" | "--" | "*" | "**" | "/" | "%" | "==" | "!=" | "<" | "<=" | ">" | ">=" | "="
	;

overload_declaration =
	"bind", overload_operator, "function", data_type, function_identifier, "(", overload_proto_formals, ")", ";"
	;

block_item_declaration =
	{ attribute_instance }, data_declaration |
	{ attribute_instance }, local_parameter_declaration, ";" |
	{ attribute_instance }, parameter_declaration, ";" |
	{ attribute_instance }, overload_declaration |
	{ attribute_instance }, let_declaration
	;

task_prototype =
	"task", task_identifier, "(", [ tf_port_list ], ")"
	;

tf_port_declaration =
	{ attribute_instance }, tf_port_declaration, [ "var" ], data_type_or_implicit,
		list_of_tf_variable_identifiers, ";"
	;

tf_port_direction =
	port_direction |
	"const", "ref"
	;

(* See NOTE 23 *)
tf_port_item =
	{ attribute_instance }, [ tf_port_direction ], [ "var" ], data_type_or_implicit,
		[ port_identifier, { variable_dimension }, [ "=", expression ] ]
	;

tf_port_list =
	tf_port_item, { ",", tf_port_item }
	;

tf_item_declaration =
	block_item_declaration |
	tf_port_declaration
	;

task_body_declaration =
	[ interface_identifier, "." | class_scope ], task_identifier, ";", { tf_item_declaration },
		{ statement_or_null }, "endtask", [ ":", task_identifier ] |
	[ interface_identifier, "." | class_scope ], task_identifier, "(", [ tf_port_list ], ")", ";",
		{ block_item_declaration }, { statement_or_null }, "endtask", [ ":", task_identifier ]
	;

task_declaration =
	"task", [ lifetime ], task_body_declaration
	;

(* See NOTE 22 *)
dpi_task_proto =
	task_prototype
	;

(* See NOTE 21, NOTE 22 *)
dpi_function_proto =
	function_prototype
	;

dpi_task_import_property =
	"context"
	;

dpi_function_import_property =
	"context" | "pure"
	;

dpi_spec_string =
	'"', "DPI-C", '"' | '"', "DPI", '"'
	;

dpi_import_export =
	"import", dpi_spec_string, [ dpi_function_import_property ], [ c_identifier, "=" ], dpi_function_proto, ";" |
	"import", dpi_spec_string, [ dpi_task_import_property ], [ c_identifier, "=" ], dpi_task_proto, ";" |
	"export", dpi_spec_string, [ c_identifier, "=" ], "function", function_identifier, ";" |
	"export", dpi_spec_string, [ c_identifier, "=" ], "task", task_identifier, ";"
	;

function_prototype =
	"function", data_type_or_void, function_identifier, [ "(", [ tf_port_list ], ")" ]
	;

function_body_declaration =
	function_data_type_or_implicit, [ interface_identifier, "." | class_scope ], function_identifier, ";",
		{ tf_item_declaration }, { function_statement_or_null }, "endfunction", [ ":", function_identifier ] |
	function_data_type_or_implicit, [ interface_identifier, "." | class_scope ], function_identifier,
		"(", [ tf_port_list ], ")", ";", { block_item_declaration }, { function_statement_or_null },
		"endfunction", [ ":", function_identifier ]
	;

function_declaration =
	"function", [ lifetime ], function_body_declaration
	;

function_data_type_or_implicit =
	data_type_or_void |
	implicit_data_type
	;

unsized_dimension =
	"[", "]"
	;

queue_dimension =
	"[", "$", [ ":", constant_expression ], "]"
	;

variable_dimension =
	unsigned_dimension |
	unpacked_dimension |
	associative_dimension |
	queue_dimension
	;

associative_dimension =
	"[", data_type, "]" |
	"[", "*", "]"
	;

(* See NOTE 20 *)
packed_dimension =
	"[", constant_range, "]" |
	unsigned_dimension
	;

unpacked_dimension =
	"[", constant_range, "]" |
	"[", constant_expression, "]"
	;

dynamic_array_new =
	"new", "[", expression, "]", [ "(", expression, ")" ]
	;

(* See NOTE 19 *)
class_new =
	[ class_scope ], "new", [ "(", list_of_arguments, ")" ] |
	"new", expression
	;

variable_decl_assignment =
	variable_identifier, { variable_dimension }, [ "=", expression ] |
	dynamic_array_variable_identifier, unsized_dimension, { variable_dimension },
		[ "=", dynamic_array_new ] |
	class_variable_identifier, [ "=", class_new ]
	;

limit_value =
	constant_mintypmax_expression
	;

reject_limit_value =
	limit_value
	;

error_limit_value =
	limit_value
	;

pulse_control_specparam =
	"PATHPULSE$", "=", "(", reject_limit_value, [ ",", error_limit_value ], ")" |
	"PATHPULSE$", specify_input_terminal_descriptor, "$", specify_output_terminal_descriptor, "=", "(",
		reject_limit_value, [ ",", error_limit_value ], ")"
	;

(* See NOTE 18 *)
type_assignment =
	type_identifier, [ "=", data_type ]
	;

specparam_assignment =
	specparam_identifier, "=", constant_mintypmax_expression |
	pulse_control_specparam
	;

(* See NOTE 18 *)
param_assignment =
	parameter_identifier, { unpacked_dimension }, [ "=", constant_param_expression ]
	;

net_decl_assignment =
	net_identifier, { unpacked_dimension }, [ "=", expression ]
	;

defparam_assignment =
	hierarchical_parameter_identifier, "=", constant_mintypmax_expression
	;

list_of_variable_port_identifiers =
	port_identifier, { variable_dimension }, [ "=", constant_expression ],
		{ ",", port_identifier, { variable_dimension }, [ "=", constant_expression ], }
	;

list_of_variable_identifiers =
	variable_identifier, { variable_dimension }, { ",", variable_identifier, { variable_dimension } }
	;

list_of_variable_decl_assignments =
	variable_decl_assignment, { ",", variable_decl_assignment }
	;

list_of_type_assignments =
	type_assignment, { ",", type_assignment }
	;

list_of_tf_variable_identifiers =
	port_identifier, { variable_dimension }, [ "=", expression ],
		{ ",", port_identifier, { variable_dimension }, [ "=", expression ], }
	;

list_of_specparam_assignments =
	specparam_assignment, { ",", specparam_assignment }
	;

list_of_udp_port_identifiers =
	port_identifier, { ",", port_identifier }
	;

list_of_port_identifiers =
	port_identifier, { unpacked_dimension }, { ",", port_identifier, { unpacked_dimension } }
	;

list_of_param_assignments =
	param_assignment, { ",", param_assignment }
	;

list_of_net_decl_assignments =
	net_decl_assignment, { ",", net_decl_assignment }
	;

list_of_interface_identifiers =
	interface_identifier, { unpacked_dimension }, { ",", interface_identifier, { unpacked_dimension } }
	;

list_of_genvar_identifiers =
	genvar_identifier, { ",", genvar_identifier }
	;

list_of_defparam_assignments =
	defparam_assignment, { ",", defparam_assignment }
	;

delay_value =
	unsigned_number |
	real_number |
	ps_identifier |
	time_literal |
	"1step"
	;

delay2 =
	"#", delay_value |
	"#", "(", mintypmax_expression, [ ",", constant_mintypmax_expression ], ")"
	;

delay3 =
	"#", delay_value |
	"#", "(", mintypmax_expression, [ ",", mintypmax_expression, [ ",", mintypmax_expression ] ], ")"
	;

charge_strength =
	"(", "small", ")" |
	"(", "medium", ")" |
	"(", "large", ")"
	;

strength1 =
	"supply1" | "strong1" | "pull1" | "weak1"
	;

strength0 =
	"supply0" | "strong0" | "pull0" | "weak0"
	;

drive_strength =
	"(", strength0, strength1, ")" |
	"(", strength1, strength0, ")" |
	"(", strength0, "highz1", ")" |
	"(", strength1, "highz0", ")" |
	"(", "highz1", strength0, ")" |
	"(", "highz0", strength1, ")"
	;

type_reference =
	(* See NOTE 17 *)
	"type", "(", expression, ")" |
	"type", "(", data_type, ")"
	;

struct_union =
	"struct" |
	"union", [ "tagged" ]
	;

data_type_or_void =
	data_type |
	"void"
	;

(* See NOTE 16 *)
struct_union_member =
	{ attribute_instance }, [ random_qualifier ], data_type_or_void, list_of_variable_decl_assignments, ";"
	;

simple_type =
	integer_type |
	non_integer_type |
	ps_type_identifier |
	ps_parameter_identifier
	;

signing =
	"signed" | "unsigned"
	;

var_data_type =
	data_type |
	"var", data_type_or_implicit
	;

variable_port_type =
	var_data_type
	;

net_port_type =
	[ net_type ], data_type_or_implicit |
	net_type_identifier |
	"interconnect", implicit_data_type
	;

net_type =
	"supply0" | "supply1" | "tri" | "triand" | "trior" | "trireg" | "tri0" | "tri1" | "uwire" |
	"wire" | "wand" | "wor"
	;

non_integer_type =
	"shortreal" | "real" | "realtime"
	;

integer_vector_type =
	"bit" | "logic" | "reg"
	;

integer_atom_type =
	"byte" | "shortint" | "int" | "longint" | "integer" | "time"
	;

integer_type =
	integer_vector_type |
	integer_atom_type
	;

class_type =
	ps_class_identifier, [ parameter_value_assignment ], { "::", class_identifier, [ parameter_value_assignment ] }
	;

class_scope =
	class_type, "::"
	;

enum_name_declaration =
	enum_identifier, [ "[", integral_number, [ ":", integral_number ], "]" ], [ "=", constant_expression ]
	;

enum_base_type =
	integer_atom_type, [ signing ] |
	integer_vector_type, [ signing ], [ packed_dimension ] |
	(* See NOTE 15 *)
	type_identifier, [ packed_dimension ]
	;

implicit_data_type =
	[ signing ], { packed_dimension }
	;

data_type_or_implicit =
	data_type |
	implicit_data_type
	;

data_type =
	integer_vector_type, [ signing ], { packed_dimension } |
	integer_atom_type, [ signing ] |
	non_integer_type |
	(* See NOTE 13 *)
	struct_union, [ "packed", [ signing ] ], "{", struct_union_member, { struct_union_member }, "}",
		{ packed_dimension } |
	"enum", [ enum_base_type ], "{", enum_name_declaration, { ",", enum_name_declaration }, "}",
		{ packed_dimension } |
	"string" |
	"chandle" |
	"virtual", [ "interface" ], interface_identifier, [ parameter_value_assignment ], [ ".", modport_identifier ] |
	[ class_scope | package_scope ], type_identifier, { packed_dimension } |
	class_type |
	"event" |
	ps_covergroup_identifier |
	(* See NOTE 14 *)
	type_reference
	;

casting_type =
	simple_type |
	constant_primary |
	signing |
	"string" |
	"const"
	;

lifetime =
	"static" | "automatic"
	;

net_type_declaration =
	"nettype", data_type, net_type_identifier, [ "with", [ package_scope | class_scope ], tf_identifier ], ";" |
	"nettype", [ package_scope | class_scope ], net_type_identifier, net_type_identifier, ";"
	;

type_declaration =
	"typedef", data_type, type_identifier, { variable_dimension }, ";" |
	"typedef", interface_instance_identifier, constant_bit_select, ".", type_identifier, type_identifier, ";" |
	"typedef", [ "enum" | "struct" | "union" | "class" | "interface", "class" ], type_identifier, ";"
	;

(* See NOTE 12 *)
net_declaration =
	net_type, [ drive_strength | charge_strength ], [ "vectored" | "scalared" ], data_type_or_implicit,
		[ delay3 ], list_of_net_decl_assignments, ";" |
	net_type_identifier, [ delay_control ], list_of_net_decl_assignments, ";" |
	"interconnect", implicit_data_type, [ "#", delay_value ], net_identifier, { unpacked_dimension },
		[ ",", net_identifier, { unpacked_dimension } ], ";"
	;

genvar_declaration =
	"genvar", list_of_genvar_identifiers, ";"
	;

package_export_declaration =
	"export", "*::*", ";" |
	"export", package_import_item, { ",", package_import_item }, ";"
	;

package_import_item =
	package_identifier, "::", identifier |
	package_identifier, "::", "*"
	;

package_import_declaration =
	"import", package_import_item, { ",", package_import_item }, ";"
	;

(* See NOTE 10 *)
data_declaration =
	[ "const" ], [ "var" ], [ lifetime ], data_type_or_implicit, list_of_variable_decl_assignments, ";" |
	type_declaration |
	(* See NOTE 11 *)
	package_import_declaration |
	net_type_declaration
	;

ref_declaration =
	"ref", variable_port_type, list_of_port_identifiers
	;

interface_port_declaration =
	interface_identifier, list_of_interface_identifiers |
	interface_identifier, ".", modport_identifier, list_of_interface_identifiers
	;

output_declaration =
	"output", net_port_type, list_of_port_identifiers |
	"output", variable_port_type, list_of_variable_port_identifiers
	;

input_declaration =
	"input", net_port_type, list_of_port_identifiers |
	"input", variable_port_type, list_of_variable_identifiers
	;

inout_declaration =
	"inout", net_port_type, list_of_port_identifiers
	;

specparam_declaration =
	"specparam", [ packed_dimension ], list_of_specparam_assignments, ";"
	;

parameter_declaration =
	"parameter", data_type_or_implicit, list_of_param_assignments |
	"parameter", "type", list_of_type_assignments
	;

local_parameter_declaration =
	"localparam", data_type_or_implicit, list_of_param_assignments |
	"localparam", "type", list_of_type_assignments
	;

anonymous_program_item =
	task_declaration |
	function_declaration |
	class_declaration |
	covergroup_declaration |
	class_constructor_declaration |
	";"
	;

anonymous_program =
	"program", ";", { anonymous_program_item }, "endprogram"
	;

package_or_generate_item_declaration =
	net_declaration |
	data_declaration |
	task_declaration |
	function_declaration |
	checker_declaration |
	dpi_import_export |
	extern_constraint_declaration |
	class_declaration |
	class_constructor_declaration |
	local_parameter_declaration, ";" |
	parameter_declaration, ";" |
	covergroup_declaration |
	overload_declaration |
	assertion_item_declaration |
	";"
	;

package_item =
	package_or_generate_item_declaration |
	anonymous_program |
	package_export_declaration |
	(* See NOTE 3 *)
	timeunits_declaration
	;

identifier_list =
	identifier, { ",", identifier }
	;

extern_constraint_declaration =
	[ "static" ], "constraint", class_scope, constraint_identifier, constraint_block
	;

constraint_prototype_qualifier =
	"extern" | "pure"
	;

constraint_prototype =
	[ constraint_prototype_qualifier ], [ "static" ], "constraint", constraint_identifier, ";"
	;

dist_weight =
	":=", expression |
	":/", expression
	;

dist_item =
	value_range, [ dist_weight ]
	;

dist_list =
	dist_item, { ",", dist_item }
	;

constraint_set =
	constraint_expression |
	"{", { constraint_expression }, "}"
	;

(* See NOTE 9 *)
uniqueness_constraint =
	"unique", "{", open_range_list, "}"
	;

constraint_expression =
	[ "soft" ], expression_or_dist, ";" |
	uniqueness_constraint, ";" |
	expression, "->", constraint_set |
	"if", "(", expression, ")", constraint_set, [ "else", constraint_set ] |
	"foreach", "(", ps_or_hierarchical_array_identifier, "[", loop_variables, "]", ")", constraint_set |
	"disable", "soft", constraint_primary, ";"
	;

constraint_primary =
	[ implicit_class_handle, "." | class_scope ], hierarchical_identifier, select
	;

solve_before_list =
	constraint_primary, { ",", constraint_primary }
	;

constraint_block_item =
	"solve", solve_before_list, "before", solve_before_list, ";" |
	constraint_expression
	;

constraint_block =
	"{", { constraint_block_item }, "}"
	;

constraint_declaration =
	[ "static" ], "constraint", constraint_identifier, constraint_block
	;

class_constructor_declaration =
	"function", [ class_scope ], "new", [ "(", [ tf_port_list ], ")" ], ";", { block_item_declaration },
		[ "super", ".", "new", [ "(", list_of_arguments, ")" ], ";" ], { function_statement_or_null },
		"endfunction", [ ":", "new" ]
	;

method_prototype =
	task_prototype |
	function_prototype
	;

(* See NOTE 8 *)
method_qualifier =
	[ "pure" ], "virtual" |
	class_item_qualifier
	;

(* See NOTE 8 *)
random_qualifier =
	"rand" | "randc"
	;

(* See NOTE 8 *)
property_qualifier =
	random_qualifier |
	class_item_qualifier
	;

(* See NOTE 8 *)
class_item_qualifier =
	"static" | "protected" | "local"
	;

class_constraint =
	constraint_prototype |
	constraint_declaration
	;

class_constructor_prototype =
	"function", "new", "(", [ tf_port_list ], ")", ";"
	;

class_method =
	{ method_qualifier }, task_declaration |
	{ method_qualifier }, function_declaration |
	"pure", "virtual", { class_item_qualifier }, method_prototype, ";" |
	"extern", { method_qualifier }, method_prototype, ";" |
	{ method_qualifier }, class_constructor_declaration |
	"extern", { method_qualifier }, class_constructor_prototype
	;

class_property =
	{ property_qualifier }, data_declaration |
	"const", { class_item_qualifier }, data_type, const_identifier, [ "=", constant_expression ], ";"
	;

class_item =
	{ attribute_instance }, class_property |
	{ attribute_instance }, class_method |
	{ attribute_instance }, class_constraint |
	{ attribute_instance }, class_declaration |
	{ attribute_instance }, covergroup_declaration |
	local_parameter_declaration, ";" |
	(* See NOTE 7 *)
	parameter_declaration, ";" |
	";"
	;

(* See NOTE 6 *)
checker_generate_item =
	loop_generate_construct |
	conditional_generate_construct |
	generate_region |
	elaboration_system_task
	;

checker_or_generate_item_declaration =
	[ "rand" ], data_declaration |
	function_declaration |
	checker_declaration |
	assertion_item_declaration |
	covergroup_declaration |
	overload_declaration |
	genvar_declaration |
	clocking_declaration |
	"default", "clocking", clocking_identifier, ";" |
	"default", "disable", "iff", expression_or_dist, ";" |
	";"
	;

checker_or_generate_item =
	checker_or_generate_item_declaration |
	initial_construct |
	always_construct |
	final_construct |
	assertion_item |
	continuous_assign |
	checker_generate_item
	;

checker_port_direction =
	"input" | "output"
	;

checker_port_item =
	{ attribute_instance }, [ checker_port_direction ], property_formal_type, formal_port_identifier,
		{ variable_dimension }, [ "=", property_actual_arg ]
	;

checker_port_list =
	checker_port_item, { ",", checker_port_item }
	;

(* See NOTE 5 *)
program_generate_item =
	loop_generate_construct |
	conditional_generate_construct |
	generate_region |
	elaboration_system_task
	;

non_port_program_item =
	{ attribute_instance }, continuous_assign |
	{ attribute_instance }, module_or_generate_item_declaration |
	{ attribute_instance }, initial_construct |
	{ attribute_instance }, final_construct |
	{ attribute_instance }, concurrent_assertion_item |
	(* See NOTE 3 *)
	timeunits_declaration |
	program_generate_item
	;

program_item =
	port_declaration, ";" |
	non_port_program_item
	;

non_port_interface_item =
	generate_region |
	interface_or_generate_item |
	program_declaration |
	interface_declaration |
	(* See NOTE 3 *)
	timeunits_declaration
	;

interface_item =
	port_declaration, ";" |
	non_port_interface_item
	;

extern_tf_declaration =
	"extern", method_prototype, ";" |
	"extern", "forkjoin", task_prototype, ";"
	;

interface_or_generate_item =
	{ attribute_instance }, module_common_item |
	{ attribute_instance }, modport_declaration |
	{ attribute_instance }, extern_tf_declaration
	;

use_clause =
	"use", [ library_identifier, "." ], cell_identifier, [ ":", "config" ] |
	"use", named_parameter_assignment, { ",", named_parameter_assignment }, [ ":", "config" ] |
	"use", [ library_identifier, "." ], cell_identifier, named_parameter_assignment, { ",", named_parameter_assignment },
		[ ":", "config" ]
	;

liblist_clause =
	"liblist", { library_identifier }
	;

cell_clause =
	"cell", [ library_identifier, "." ], cell_identifier
	;

inst_name =
	topmodule_identifier, { ".", instance_identifier }
	;

inst_clause =
	"instance", inst_name
	;

default_clause =
	"default"
	;

config_rule_statement =
	default_clause, liblist_clause, ";" |
	inst_clause, liblist_clause, ";" |
	inst_clause, use_clause, ";" |
	cell_clause, liblist_clause, ";" |
	cell_clause, use_clause, ";"
	;

design_statement =
	"design", { [ library_identifier, "." ], cell_identifier }, ";"
	;

config_declaration =
	"config", config_identifier, ";", { local_parameter_declaration, ";" }, design_statement,
		{ config_rule_statement }, "endconfig", [ ":", config_identifier ]
	;

bind_instantiation =
	program_instantiation |
	module_instantiation |
	interface_instantiation |
	checker_instantiation
	;

bind_target_instance_list =
	bind_target_instance, { ",", bind_target_instance }
	;

bind_target_instance =
	hierarchical_identifier, constant_bit_select
	;

bind_target_scope =
	module_identifier |
	interface_identifier
	;

(* See NOTE 4 *)
bind_directive =
	"bind", bind_target_scope, [ ":", bind_target_instance_list ], bind_instantiation, ";" |
	"bind", bind_target_instance, bind_instantiation, ";"
	;

parameter_override =
	"defparam", list_of_defparam_assignments, ";"
	;

non_port_module_item =
	generate_region |
	module_or_generate_item |
	specify_block |
	{ attribute_instance }, specparam_declaration |
	program_declaration |
	module_declaration |
	interface_declaration |
	(* See NOTE 3 *)
	timeunits_declaration
	;

module_or_generate_item_declaration =
	package_or_generate_item_declaration |
	genvar_declaration |
	clocking_declaration |
	"default", "clocking", clocking_identifier, ";" |
	"default", "disable", "iff", expression_or_dist, ";"
	;

module_or_generate_item =
	{ attribute_instance }, parameter_override |
	{ attribute_instance }, gate_instantiation |
	{ attribute_instance }, udp_instantiation |
	{ attribute_instance }, module_instantiation |
	{ attribute_instance }, module_common_item
	;

module_item =
	port_declaration, ";" |
	non_port_module_item
	;

module_common_item =
	module_or_generate_item_declaration |
	interface_instantiation |
	program_instantiation |
	assertion_item |
	bind_directive |
	continuous_assign |
	net_alias |
	initial_construct |
	final_construct |
	always_construct |
	loop_generate_construct |
	conditional_generate_construct |
	elaboration_system_task
	;

finish_number =
	"0" | "1" | "2"
	;

elaboration_system_task =
	"$fatal", [ "(", finish_number, [ ",", list_of_arguments ], ")" ], ";" |
	"$error", [ "(", [ list_of_arguments ], ")" ], ";" |
	"$warning", [ "(", [ list_of_arguments ], ")" ], ";" |
	"$info", [ "(", [ list_of_arguments ], ")" ], ";"
	;

ansi_port_declaration =
	[ net_port_header | interface_port_header ], port_identifier, { unpacked_dimension },
		[ "=", constant_expression ] |
	[ variable_port_header ], port_identifier, { variable_dimension }, [ "=", constant_expression ] |
	[ port_direction ], ".", port_identifier, "(", [ expression ], ")"
	;

interface_port_header =
	interface_identifier, [ ".", modport_identifier ] |
	"interface", [ ".", modport_identifier ]
	;

variable_port_header =
	[ port_direction ], variable_port_type
	;

net_port_header =
	[ port_direction ], net_port_type
	;

port_direction =
	"input" | "output" | "inout" | "ref"
	;

port_reference =
	port_identifier, constant_select
	;

port_expression =
	port_reference |
	"{", port_reference, { ",", port_reference }, "}"
	;

port =
	[ port_expression ] |
	".", port_identifier, "(", [ port_expression ], ")"
	;

port_declaration =
	{ attribute_instance }, inout_declaration |
	{ attribute_instance }, input_declaration |
	{ attribute_instance }, output_declaration |
	{ attribute_instance }, ref_declaration |
	{ attribute_instance }, interface_port_declaration
	;

(* See NOTE 2 *)
list_of_port_declarations =
	"(", [ { attribute_instance }, ansi_port_declaration, { ",", { attribute_instance }, ansi_port_declaration } ], ")"
	;

list_of_ports =
	"(", port, { ",", port }, ")"
	;

parameter_port_declaration =
	parameter_declaration |
	local_parameter_declaration |
	data_type, list_of_param_assignments |
	"type", list_of_type_assignments
	;

parameter_port_list =
	"#", "(", list_of_param_assignments, { ",", parameter_port_declaration }, ")" |
	"#", "(", parameter_port_declaration, { ",", parameter_port_declaration }, ")" |
	"#", "(", ")"
	;

timeunits_declaration =
	"timeunit", time_literal, [ "/", time_literal ], ";" |
	"timeprecision", time_literal, ";" |
	"timeunit", time_literal, ";", "timeprecision", time_literal, ";" |
	"timeprecision", time_literal, ";", "timeunit", time_literal, ";"
	;

package_declaration =
	{ attribute_instance }, "package", [ lifetime ], package_identifier, ";", [ timeunits_declaration ],
		{ { attribute_instance }, package_item }, "endpackage", [ ":", package_identifier ]
	;

interface_class_method =
	"pure", "virtual", method_prototype, ";"
	;

interface_class_item =
	type_declaration |
	{ attribute_instance }, interface_class_method |
	local_parameter_declaration, ";" |
	(* See NOTE 7 *)
	parameter_declaration |
	";"
	;

interface_class_declaration =
	"interface", "class", class_identifier, [ parameter_port_list ],
		[ "extends", interface_class_type, { ",", interface_class_type } ], ";",
		{ interface_class_item }, "endcalss", [ ":", class_identifier ]
	;

interface_class_type =
	ps_class_identifier, [ parameter_value_assignment ]
	;

class_declaration =
	[ "virtual" ], "class", [ lifetime ], class_identifier, [ parameter_port_list ],
		[ "extends", class_type, [ "(", list_of_arguments, ")" ] ],
		[ "implements", interface_class_type, { ",", interface_class_type } ], ";", { class_item },
		"endclass", [ ":", class_identifier ]
	;

checker_declaration =
	"checker", checker_identifier, [ "(", [ checker_port_list ], ")" ], ";",
		{ { attribute_instance }, checker_or_generate_item },
		"endchecker", [ ":", checker_identifier ]
	;

(* See NOTE 1 *)
program_ansi_header =
	{ attribute_instance }, "program", [ lifetime ], program_identifier, { package_import_declaration },
		[ parameter_port_list ], [ list_of_port_declarations ], ";"
	;

program_nonansi_header =
	{ attribute_instance }, "program", [ lifetime ], program_identifier, { package_import_declaration },
		[ parameter_port_list ], list_of_ports, ";"
	;

program_declaration =
	program_nonansi_header, [ timeunits_declaration ], { program_item }, "endprogram",
		[ ":", program_identifier ] |
	program_ansi_header, [ timeunits_declaration ], { non_port_program_item }, "endprogram",
		[ ":", program_identifier ] |
	{ attribute_instance }, "program", program_identifier, "(", ".*", ")", ";", [ timeunits_declaration ],
		{ program_item }, "endprogram", [ ":", program_identifier ] |
	"extern", program_nonansi_header |
	"extern", program_ansi_header
	;

(* See NOTE 1 *)
interface_ansi_header =
	{ attribute_instance }, "interface", [ lifetime ], interface_identifier, { package_import_declaration },
		[ parameter_port_list ], [ list_of_port_declarations ], ";"
	;

interface_nonansi_header =
	{ attribute_instance }, "interface", [ lifetime ], interface_identifier, { package_import_declaration },
		[ parameter_port_list ], list_of_ports, ";"
	;

interface_declaration =
	interface_nonansi_header, [ timeunits_declaration ], { interface_item }, "endinterface",
		[ ":", interface_identifier ] |
	interface_ansi_header, [ timeunits_declaration ], { non_port_interface_item }, "endinterface",
		[ ":", interface_identifier ] |
	{ attribute_instance }, "interface", interface_identifier, "(", ".*", ")", ";", [ timeunits_declaration ],
		{ interface_item }, "endinterface", [ ":", interface_identifier ] |
	"extern", interface_nonansi_header |
	"extern", interface_ansi_header
	;

module_keyword =
	"module" | "macromodule"
	;

module_declaration =
	module_nonansi_header, [ timeunits_declaration ], { module_item }, "endmodule",
		[ ":", module_identifier ] |
	module_ansi_header, [ timeunits_declaration ], { non_port_module_item }, "endmodule",
		[ ":", module_identifier ] |
	{ attribute_instance }, module_keyword, [ lifetime ], module_identifier, "(", ".*", ")", ";",
		[ timeunits_declaration ], { module_item }, "endmodule", [ ":", module_identifier ] |
	"extern", module_nonansi_header |
	"extern", module_ansi_header
	;

(* See NOTE 1 *)
module_ansi_header =
	{ attribute_instance }, module_keyword, [ lifetime ], module_identifier, { package_import_declaration },
		[ parameter_port_list ], [ list_of_port_declarations ], ";"
	;

module_nonansi_header =
	{ attribute_instance }, module_keyword, [ lifetime ], module_identifier, { package_import_declaration },
		[ parameter_port_list ], list_of_ports, ";"
	;

description =
	module_declaration |
	udp_declaration |
	interface_declaration |
	program_declaration |
	package_declaration |
	{ attribute_instance }, package_item |
	{ attribute_instance }, bind_directive |
	config_declaration
	;

source_text =
	[ timeunits_declaration ], { description }
	;

(* Library Map File *)

include_statement =
	"include", file_path_spec, ";"
	;

library_declaration =
	"library", library_identifier, file_path_spec, { ",", file_path_spec },
		[ "-incdir", file_path_spec, { ",", file_path_spec } ], ";"
	;

library_description =
	library_declaration |
	include_statement |
	config_declaration |
	";"
	;

library_text =
	{ library_description }
	;

(* Compiler Directives *)

(* See NOTE 52 *)
cell_define_compiler_directive =
	"`", "celldefine"
	;

(* See NOTE 52 *)
end_cell_define_compiler_directive =
	"`", "endcelldefine"
	;

(* See NOTE 52 *)
default_nettype_compiler_directive =
	"`", "default_nettype", directive_net_type
	;

directive_net_type =
	"wire" | "tri" | "tri0" | "wand" | "triand" | "tri1" | "wor" | "trior" | "trireg" | "none" |
	"uwire"
	;

(* See NOTE 52 *)
text_macro_definition =
	"`", "define", text_macro_name, macro_text
	;

text_macro_name =
	text_macro_identifier, [ "(", list_of_formal_arguments, ")" ]
	;

list_of_formal_arguments =
	formal_argument, { ",", formal_argument }
	;

formal_argument =
	simple_identifier, [ "=", default_text ]
	;

text_macro_identifier =
	identifier
	;

(* See NOTE 52 *)
text_macro_usage =
	"`", text_macro_identifier, [ "(", list_of_actual_arguments, ")" ]
	;

list_of_actual_arguments =
	actual_argument, { ",", actual_argument }
	;

actual_argument =
	expression
	;

(* See NOTE 52 *)
undefine_compiler_directive =
	"`", "undef", text_macro_name
	;

(* See NOTE 52 *)
undefineall_compiler_directive =
	"`", "undefineall"
	;

conditional_compilation_directive =
	ifdef_directive |
	ifndef_directive
	;

(* See NOTE 52 *)
ifdef_directive =
	"`", "ifdef", text_macro_identifier, ifdef_group_of_lines,
	{ "`", "elsif", text_macro_identifier, elsif_group_of_lines },
	[ "`", "else", else_group_of_lines ],
	"`", "endif"
	;

(* See NOTE 52 *)
ifndef_directive =
	"`", "ifndef", text_macro_identifier, ifndef_group_of_lines,
	{ "`", "elsif", text_macro_identifier, elsif_group_of_lines },
	[ "`", "else", else_group_of_lines ],
	"`", "endif"
	;


(* See NOTE 52 *)
include_compiler_directive =
	"`", "include", '"', filename, '"' |
	"`", "include", '<', filename, '>'
	;

(* See NOTE 52 *)
resetall_compiler_directive =
	"`", "resetall"
	;

(* See NOTE 52 *)
line_compiler_directive =
	"`", "line", unsigned_number, '"', filename, '"', line_level
	;

line_level =
	"0" | "1" | "2"
	;

(* See NOTE 52 *)
timescale_compiler_directive =
	"`", "timescale", time_scale, time_unit, "/", time_scale, time_unit
	;

time_scale =
	"1" | "10" | "100"
	;

time_unit =
	"s" | "ms" | "us" | "ns" | "ps" | "fs"
	;

(* See NOTE 52 *)
nounconnected_drive_compiler_directive =
	"`", "nounconnected_drive"
	;

(* See NOTE 52 *)
unconnected_drive_compiler_directive =
	"`", "unconnected_drive", drive_pull
	;

drive_pull =
	"pull0" | "pull1"
	;

(* See NOTE 52 *)
pragma =
	"`", "pragma", pragma_name, [ pragma_expression, { ",", pragma_expression } ]
	;

pragma_name =
	simple_identifier
	;

pragma_expression =
	pragma_keyword |
	pragma_keyword, "=", pragma_value |
	pragma_value
	;

pragma_value =
	"(", pragma_expression, { ",", pragma_expression }, ")" |
	number |
	string |
	identifier
	;

pragma_keyword =
	simple_identifier
	;

(* See NOTE 52 *)
keywords_directive =
	"`", "begin_kewords", '"', version_spec, '"'
	;

version_spec =
	"1364-1995" | "1364-2001" | "1364-2001-noconfig" | "1364-2005" | "1800-2005" | "1800-2009" |
	"1800-2012"
	;

(* See NOTE 52 *)
endkeywords_directive =
	"`", "end_keywords"
	;

(* See NOTE 52 *)
default_decay_time_compiler_directive =
	"`", "default_decay_time", decay_time
	;

decay_time =
	integer_constant |
	real_constant |
	"infinite"
	;

(* See NOTE 52 *)
default_trireg_strength_compiler_directive =
	"`", "default_trireg_strength", ? Integer_Constant_Between_0_And_250 ?
	;

(* See NOTE 52 *)
delay_mode_distributed_compiler_directive =
	"`", "delay_mode_distributed"
	;

(* See NOTE 52 *)
delay_mode_path_compiler_directive =
	"`", "delay_mode_path"
	;

(* See NOTE 52 *)
delay_mode_unit_compiler_directive =
	"`", "delay_mode_unit"
	;

(* See NOTE 52 *)
delay_mode_zero_compiler_directive =
	"`", "delay_mode_zero"
	;

(*
	Keywords:
		accept_on
		alias
		always
		always_comb
		always_ff
		always_latch
		and
		assert
		assign
		assume
		automatic
		before
		begin
		bind
		bins
		binsof
		bit
		break
		buf
		bufif0
		bufif1
		byte
		case
		casex
		casez
		cell
		chandle
		checker
		class
		clocking
		cmos
		config
		const
		constraint
		context
		continue
		cover
		covergroup
		coverpoint
		cross
		deassign
		default
		defparam
		design
		disable
		dist
		do
		edge
		else
		end
		endcase
		endchecker
		endclass
		endclocking
		endconfig
		endfunction
		endgenerate
		endgroup
		endinterface
		endmodule
		endpackage
		endprimitive
		endprogram
		endproperty
		endsequence
		endspecify
		endtable
		endtask
		enum
		event
		eventually
		expect
		export
		extends
		extern
		final
		first_match
		for
		force
		foreach
		forever
		fork
		forkjoin
		function
		generate
		genvar
		global
		highz0
		highz1
		if
		iff
		ifnone
		ignore_bins
		illegal_bins
		implements
		implies
		import
		incdir
		include
		initial
		inout
		input
		inside
		instance
		int
		integer
		interconnect
		interface
		intersect
		join
		join_any
		join_none
		large
		let
		liblist
		library
		local
		localparam
		logic
		longint
		macromodule
		matches
		medium
		modport
		module
		nand
		negedge
		nettype
		new
		nexttime
		nmos
		nor
		noshowcancelled
		not
		notif0
		notif1
		null
		or
		output
		package
		packed
		parameter
		pmos
		posedge
		primitive
		priority
		program
		property
		protected
		pull0
		pull1
		pulldown
		pullup
		pulsestyle_ondetect
		pulsestyle_onevent
		pure
		rand
		randc
		randcase
		randsequence
		rcmos
		real
		realtime
		ref
		reg
		reject_on
		release
		repeat
		restrict
		return
		rnmos
		rpmos
		rtran
		rtranif0
		rtranif1
		s_always
		s_eventually
		s_nexttime
		s_until
		s_until_with
		scalared
		sequence
		shortint
		shortreal
		showcancelled
		signed
		small
		soft
		solve
		specify
		specparam
		static
		string
		strong
		strong0
		strong1
		struct
		super
		supply0
		supply1
		sync_accept_on
		sync_reject_on
		table
		tagged
		task
		this
		throughout
		time
		timeprecision
		timeunit
		tran
		tranif0
		tranif1
		tri
		tri0
		tri1
		triand
		trior
		trireg
		type
		typedef
		union
		unique
		unique0
		unsigned
		until
		until_with
		untyped
		use
		uwire
		var
		vectored
		virtual
		void
		wait
		wait_order
		wand
		weak
		weak0
		weak1
		while
		wildcard
		wire
		with
		within
		wor
		xnor
		xor
*)
