(* SPDX-License-Identifier: BSD-3-Clause *)
(* EBNF grammar for Verilog 2005 (IEEE 1364-2005) *)
(*
	NOTE 1: Function statements are limited by the rules of IEEE 1364-2005 ยง10.4.4.
	NOTE 2: Embedded spaces are illegal.
	NOTE 3: A `simple_identifier` shall start with [a-zA-Z_], shall have at least one character, and
			shall not have any spaces.
	NOTE 4: The dollar sign (`$`) in a a `system_function_identifier` of `system_task_identifier`
			shall not be followed by any `white_space`. A `system_function_identifier` or
			`system_task_identifier` shall not be escaped.
	NOTE 5: EOF (End Of File) is a valid `white_space` character.
*)

(* See NOTE 5 *)
white_space =
	" " | "\t" | "\n"
	;

variable_identifier =
	identifier
	;

udp_instance_identifier =
	identifier
	;

udp_identifier =
	identifier
	;

topmodule_identifier =
	identifier
	;

text_macro_identifier =
	identifier
	;

terminal_identifier =
	identifier
	;

task_identifier =
	identifier
	;

(* See NOTE 4 *)
system_task_identifier =
	"$", a-zA-Z0-9_$, { a-zA-Z0-9_$ }
	;

(* See NOTE 4 *)
system_function_identifier =
	"$", a-zA-Z0-9_$, { a-zA-Z0-9_$ }
	;

specparam_identifier =
	identifier
	;

(* See NOTE 3 *)
simple_identifier =
	a-zA-Z_, { a-zA-Z0-9_$ }
	;

real_identifier =
	identifier
	;

port_identifier =
	identifier
	;

parameter_identifier =
	identifier
	;

output_port_identifier =
	identifier
	;

net_identifier =
	identifier
	;

module_instance_identifier =
	identifier
	;

module_identifier =
	identifier
	;

library_identifier =
	identifier
	;

instance_identifier =
	identifier
	;

input_identifier =
	identifier
	;

inout_port_identifier =
	identifier
	;

identifier =
	simple_identifier |
	escaped_identifier
	;

hierarchical_task_identifier =
	hierarchical_identifier
	;

hierarchical_variable_identifier =
	hierarchical_identifier
	;

hierarchical_parameter_identifier =
	hierarchical_identifier
	;

hierarchical_net_identifier =
	hierarchical_identifier
	;

hierarchical_identifier =
	{ identifier, [ "[", constant_expression, "]" ], "." }, identifier
	;

hierarchical_function_identifier =
	hierarchical_identifier
	;

hierarchical_event_identifier =
	hierarchical_identifier
	;

hierarchical_block_identifier =
	hierarchical_identifier
	;

genvar_identifier =
	identifier
	;

generate_block_identifier =
	identifier
	;

gate_instance_identifier =
	identifier
	;

function_identifier =
	identifier
	;

event_identifier =
	identifier
	;

escaped_identifier =
	"\\", { ? Any_ASCII_character_except_white_space ? }, white_space
	;

cell_identifier =
	identifier
	;

block_identifier =
	identifier
	;

comment_text =
	{ ? Any_ASCII_character ? }
	;

block_comment =
	"/*", comment_text, "*/"
	;

one_line_comment =
	"//", comment_text, "\n"
	;

comment =
	one_line_comment |
	block_comment
	;

attr_name =
	identifier
	;

attr_spec =
	attr_name, [ "=", constant_expression ]
	;

attribute_instance =
	"(*", attr_spec, { ",", attr_spec }, "*)"
	;

string =
	'"', { ? Any_ASCII_Characters_except_new_line ? }, '"'
	;

z_digit =
	"z" | "Z" | "?"
	;

x_digit =
	"x" | "X"
	;

hex_digit =
	"0" | "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9" |
	"a" | "b" | "c" | "d" | "e" | "f" |
	"A" | "B" | "C" | "D" | "E" | "F" | x_digit | z_digit
	;

octal_digit =
	"0" | "1" | "2" | "3" | "4" | "5" | "6" | "7" | x_digit | z_digit
	;

binary_digit =
	"0" | "1" | x_digit | z_digit
	;

decimal_digit =
	"0" | "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9"
	;

non_zero_decimal_digit =
	"1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9"
	;

(* See NOTE 2 *)
hex_base =
	"'", [ "s" | "S" ], "h" |
	"'", [ "s" | "S" ], "H"
	;

(* See NOTE 2 *)
octal_base =
	"'", [ "s" | "S" ], "o" |
	"'", [ "s" | "S" ], "O"
	;

(* See NOTE 2 *)
binary_base =
	"'", [ "s" | "S" ], "b" |
	"'", [ "s" | "S" ], "B"
	;

(* See NOTE 2 *)
decimal_base =
	"'", [ "s" | "S" ], "d" |
	"'", [ "s" | "S" ], "D"
	;

(* See NOTE 2 *)
hex_value =
	hex_digit, { "_" | hex_digit }
	;

(* See NOTE 2 *)
octal_value =
	octal_digit, { "_" | octal_digit }
	;

(* See NOTE 2 *)
binary_value =
	binary_digit, { "_" | binary_digit }
	;

(* See NOTE 2 *)
unsigned_number =
	decimal_digit, { "_" | decimal_digit }
	;

(* See NOTE 2 *)
non_zero_unsigned_number =
	non_zero_decimal_digit, { "_" | decimal_digit }
	;

size =
	non_zero_unsigned_number
	;

sign =
	"+" | "-"
	;

hex_number =
	[ size ], hex_base, hex_value
	;

octal_number =
	[ size ], octal_base, octal_value
	;

binary_number =
	[ size ], binary_base, binary_value
	;

decimal_number =
	unsigned_number |
	[ size ], decimal_base, unsigned_number |
	[ size ], decimal_base, x_digit, { "_" } |
	[ size ], decimal_base, z_digit, { "_" }
	;

exp =
	"e" | "E"
	;

(* See NOTE 2 *)
real_number =
	unsigned_number, ".", unsigned_number |
	unsigned_number, [ ".", unsigned_number ], exp, [ sign ], unsigned_number
	;

number =
	decimal_number |
	octal_number |
	binary_number |
	hex_number |
	real_number
	;

binary_module_path_operator =
	"==" | "!=" | "&&" | "||" | "&" | "|" | "^" | "^~" | "~^"
	;

unary_module_path_operator =
	"!" | "~" | "&" | "~&" | "|" | "~|" | "^" | "~^" | "^~"
	;

binary_operator =
	"+" | "-" | "*" | "/" | "%" | "==" | "!=" | "===" | "!==" | "&&" | "||" |
	"**" | "<" | "<=" | ">" | ">=" | "&" | "|" | "^" | "^~" | "~^" | ">>" | "<<" | ">>>" | "<<<"
	;

unary_operator =
	"+" | "-" | "!" | "~" | "&" | "~&" | "|" | "~|" | "^" | "~^" | "^~"
	;

variable_lvalue =
	hierarchical_variable_identifier, [ { "[", expression, "]" }, "[", range_expression, "]" ] |
	"{", variable_lvalue, { ",", variable_lvalue }, "}"
	;

net_lvalue =
	hierarchical_net_identifier, [ { "[", constant_expression, "]" }, "[", constant_range_expression, "]" ] |
	"{", net_lvalue, { ",", net_lvalue }, "}"
	;

primary =
	number |
	hierarchical_identifier, [ { "[", expression, "]" }, "[", range_expression, "]" ] |
	concatenation |
	multiple_concatenation |
	function_call |
	system_function_call |
	"(", mintypmax_expression, ")" |
	string
	;

module_path_primary =
	number |
	identifier |
	module_path_concatenation |
	module_path_multiple_concatenation |
	function_call |
	system_function_call |
	"(", module_path_mintypmax_expression, ")"
	;

constant_primary =
	number |
	parameter_identifier, [ "[", constant_range_expression, "]" ] |
	specparam_identifier, [ "[", constant_range_expression, "]" ] |
	constant_concatenation |
	constant_multiple_concatenation |
	constant_function_call |
	constant_system_function_call |
	"(", constant_mintypmax_expression, ")" |
	string
	;

width_constant_expression =
	constant_expression
	;

range_expression =
	expression |
	msb_constant_expression, ":", lsb_constant_expression |
	base_expression, "+:", width_constant_expression |
	base_expression, "-:", width_constant_expression
	;

msb_constant_expression =
	constant_expression
	;

module_path_mintypmax_expression =
	module_path_expression |
	module_path_expression, ":", module_path_expression, ":", module_path_expression
	;

module_path_expression =
	module_path_primary |
	unary_module_path_operator, { attribute_instance }, module_path_primary |
	module_path_expression, binary_module_path_operator, { attribute_instance }, module_path_expression |
	module_path_conditional_expression
	;

module_path_conditional_expression =
	module_path_expression, "?", { attribute_instance }, module_path_expression, ":", module_path_expression
	;

mintypmax_expression =
	expression |
	expression, ":", expression, ":", expression
	;

lsb_constant_expression =
	constant_expression
	;

expression3 =
	expression
	;

expression2 =
	expression
	;

expression1 =
	expression
	;

expression =
	primary |
	unary_operator, { attribute_instance }, primary |
	expression, binary_operator, { attribute_instance }, expression |
	conditional_expression
	;

dimension_constant_expression =
	constant_expression
	;

constant_range_expression =
	constant_expression |
	msb_constant_expression, ":", lsb_constant_expression |
	constant_base_expression, "+:", width_constant_expression |
	constant_base_expression, "-:", width_constant_expression
	;

constant_mintypmax_expression =
	constant_expression |
	conditional_expression, ":", conditional_expression, ":", conditional_expression
	;

constant_expression =
	constant_primary |
	unary_operator, { attribute_instance }, constant_primary |
	constant_expression, binary_operator, { attribute_instance }, constant_expression |
	conditional_expression, "?", { attribute_instance }, constant_expression, ":", constant_expression
	;

constant_base_expression =
	constant_expression
	;

conditional_expression =
	expression1, "?", { always_construct }, expression2, ":", expression3
	;

base_expression =
	expression
	;

system_function_call =
	system_function_identifier, [ "(", expression, { ",", expression }, ")" ]
	;

function_call =
	hierarchical_function_identifier, { attribute_instance }, "(", expression, { ",", expression }, ")"
	;

constant_system_function_call =
	system_function_identifier, "(", constant_expression, { ",", constant_expression }, ")"
	;

constant_function_call =
	function_identifier, { attribute_instance }, "(", constant_expression, { ",", constant_expression }, ")"
	;

multiple_concatenation =
	"{", constant_expression, concatenation, "}"
	;

module_path_multiple_concatenation =
	"{", constant_expression, module_path_concatenation, "}"
	;

module_path_concatenation =
	"{", module_path_expression, { ",", module_path_expression }, "}"
	;

constant_multiple_concatenation =
	"{", constant_expression, constant_concatenation, "}"
	;

constant_concatenation =
	"{", constant_expression, { ",", constant_expression }, "}"
	;

concatenation =
	"{", expression, { ",", expression }, "}"
	;

scalar_constant =
	"1'b0" | "1'b1" | "1'B0" | "1'B1" | "'b0" | "'b1" | "'B0" | "'B1" | "1" | "0"
	;

scalar_timing_check_condition =
	expression |
	"~", expression |
	expression, "==", scalar_constant |
	expression, "===", scalar_constant |
	expression, "!=", scalar_constant |
	expression, "!==", scalar_constant
	;

timing_check_condition =
	scalar_timing_check_condition |
	"(", scalar_timing_check_condition, ")"
	;

z_or_x =
	"x" | "X" | "z" | "Z"
	;

zero_or_one =
	"0" | "1"
	;

(* See NOTE 2 *)
edge_descriptor =
	"01" |
	"10" |
	z_or_x, zero_or_one |
	zero_or_one, z_or_x
	;

edge_control_specifier =
	"edge", "[", edge_descriptor, { ",", edge_descriptor }, "]"
	;

specify_terminal_descriptor =
	specify_input_terminal_descriptor |
	specify_output_terminal_descriptor
	;

timing_check_event_control =
	"posedge" |
	"negedge" |
	edge_control_specifier
	;

controlled_timing_check_event =
	timing_check_event_control, specify_terminal_descriptor, [ "&&&", timing_check_condition ]
	;

timing_check_event =
	[ timing_check_event_control ], specify_terminal_descriptor, [ "&&&", timing_check_condition ]
	;

timing_check_limit =
	expression
	;

threshold =
	constant_expression
	;

start_edge_offset =
	mintypmax_expression
	;

stamptime_condition =
	mintypmax_expression
	;

remain_active_flag =
	constant_expression
	;

reference_event =
	timing_check_event
	;

notifier =
	variable_identifier
	;

event_based_flag =
	constant_expression
	;

end_edge_offset =
	mintypmax_expression
	;

delayed_reference =
	terminal_identifier |
	terminal_identifier, "[", constant_mintypmax_expression, "]"
	;

delayed_data =
	terminal_identifier |
	terminal_identifier, "[", constant_mintypmax_expression, "]"
	;

data_event =
	timing_check_event
	;

controlled_reference_event =
	controlled_timing_check_event
	;

checktime_condition =
	mintypmax_expression
	;

setup_timing_check =
	"$setup", "(", data_event, ",", reference_event, ",", timing_check_limit, [ ",", [ notifier ] ], ")", ";"
	;

hold_timing_check =
	"$hold", "(", reference_event, ",", data_event, ",", timing_check_limit, [ ",", [ notifier ] ], ")", ";"
	;

setuphold_timing_check =
	"$setuphold", "(", reference_event, ",", data_event, ",", timing_check_limit, ",", timing_check_limit, [ ",", [ notifier ], [ ",", [ stamptime_condition ], [ ",", [ checktime_condition ], [ ",", [ delayed_reference ], [ ",", [ delayed_data ] ] ] ] ] ], ")", ";"
	;

recovery_timing_check =
	"$recovery", "(", reference_event, ",", data_event, ",", timing_check_limit, [ ",", [ notifier ] ], ")", ";"
	;

removal_timing_check =
	"$removal", "(", reference_event, ",", data_event, ",", timing_check_limit, [ ",", [ notifier ] ], ")", ";"
	;

recrem_timing_check =
	"$recrem", "(", reference_event, ",", data_event, ",", timing_check_limit, ",", timing_check_limit, [ ",", [ notifier ], [ ",", [ stamptime_condition ], [ ",", [ checktime_condition ], [ ",", [ delayed_reference ], [ ",", [ delayed_data ] ] ] ] ] ], ")", ";"
	;

skew_timing_check =
	"$skew", "(", reference_event, ",", data_event, ",", timing_check_limit, [ ",", [ notifier ] ], ")", ";"
	;

timeskew_timing_check =
	"$timeskew", "(", reference_event, ",", data_event, ",", timing_check_limit, [ ",", [ notifier ], [ ",", [ event_based_flag ], [ ",", [ remain_active_flag ] ] ] ], ")", ";"
	;

fullskew_timing_check =
	"$fullskew", "(", reference_event, ",", data_event, ",", timing_check_limit, [ ",", [ notifier ], [ ",", [ event_based_flag ], [ ",", [ remain_active_flag ] ] ] ], ")", ";"
	;

period_timing_check =
	"$period", "(", controlled_reference_event, ",", timing_check_limit, [ ",", [ notifier ] ], ")", ";"
	;

width_timing_check =
	"$width", "(", controlled_reference_event, ",", timing_check_limit, [ ",", threshold, [ ",", notifier ] ], ")", ";"
	;

nochange_timing_check =
	"$nochange", "(", reference_event, ",", data_event, ",", start_edge_offset, ",", end_edge_offset, [ ",", [ notifier ] ], ")", ";"
	;

system_timing_check =
	setup_timing_check |
	hold_timing_check |
	setuphold_timing_check |
	recovery_timing_check |
	removal_timing_check |
	recrem_timing_check |
	skew_timing_check |
	timeskew_timing_check |
	fullskew_timing_check |
	period_timing_check |
	width_timing_check |
	nochange_timing_check
	;

polarity_operator =
	"+" | "-"
	;

state_dependent_path_declaration =
	"if", "(", module_path_expression, ")", simple_path_declaration |
	"if", "(", module_path_expression, ")", edge_sensitive_path_declaration |
	"ifnone", simple_path_declaration
	;

edge_identifier =
	"posedge" | "negedge"
	;

data_source_expression =
	expression
	;

full_edge_sensitive_path_description =
	"(", [ edge_identifier ], list_of_path_inputs, "*>", "(", list_of_path_outputs, [ polarity_operator ], ":", data_source_expression, ")", ")"
	;

parallel_edge_sensitive_path_description =
	"(", [ edge_identifier ], specify_input_terminal_descriptor, "=>", "(", specify_output_terminal_descriptor, [ polarity_operator ], ":", data_source_expression, ")", ")"
	;

edge_sensitive_path_declaration =
	parallel_edge_sensitive_path_description, "=", path_delay_value |
	full_edge_sensitive_path_description, "=", path_delay_value
	;

path_delay_expression =
	constant_mintypmax_expression
	;

txz_path_delay_expression =
	path_delay_expression
	;

tzx_path_delay_expression =
	path_delay_expression
	;

tx1_path_delay_expression =
	path_delay_expression
	;

t1x_path_delay_expression =
	path_delay_expression
	;

tx0_path_delay_expression =
	path_delay_expression
	;

t0x_path_delay_expression =
	path_delay_expression
	;

tz1_path_delay_expression =
	path_delay_expression
	;

t1z_path_delay_expression =
	path_delay_expression
	;

tz0_path_delay_expression =
	path_delay_expression
	;

t0z_path_delay_expression =
	path_delay_expression
	;

t10_path_delay_expression =
	path_delay_expression
	;

t01_path_delay_expression =
	path_delay_expression
	;

tz_path_delay_expression =
	path_delay_expression
	;

tfall_path_delay_expression =
	path_delay_expression
	;

trise_path_delay_expression =
	path_delay_expression
	;

t_path_delay_expression =
	path_delay_expression
	;

list_of_path_delay_expressions =
	t_path_delay_expression |
	trise_path_delay_expression, ",", tfall_path_delay_expression |
	trise_path_delay_expression, ",", tfall_path_delay_expression, ",", tz_path_delay_expression |
	t01_path_delay_expression, ",", t10_path_delay_expression, ",", t0z_path_delay_expression, ",",
	tz1_path_delay_expression, ",", t1z_path_delay_expression, ",", tz0_path_delay_expression |
	t01_path_delay_expression, ",", t10_path_delay_expression, ",", t0z_path_delay_expression, ",",
	tz1_path_delay_expression, ",", t1z_path_delay_expression, ",", tz0_path_delay_expression, ",",
	t0x_path_delay_expression, ",", tx1_path_delay_expression, ",", t1x_path_delay_expression, ",",
	tx0_path_delay_expression, ",", txz_path_delay_expression, ",", tzx_path_delay_expression
	;

path_delay_value =
	list_of_path_delay_expressions |
	"(", list_of_path_delay_expressions, ")"
	;

output_identifier =
	output_port_identifier | inout_port_identifier
	;

input_identifier =
	input_port_identifier | inout_port_identifier
	;

specify_output_terminal_descriptor =
	output_identifier, [ "[", constant_range_expression, "]" ]
	;

specify_input_terminal_descriptor =
	input_identifier, [ "[", constant_range_expression, "]" ]
	;

list_of_path_outputs =
	specify_output_terminal_descriptor, { ",", specify_output_terminal_descriptor }
	;

list_of_path_inputs =
	specify_input_terminal_descriptor, { ",", specify_input_terminal_descriptor }
	;

full_path_description =
	"(", list_of_path_inputs, [ polarity_operator ], "*>", list_of_path_outputs, ")"
	;

parallel_path_description =
	"(", specify_input_terminal_descriptor, [ polarity_operator ], "=>", specify_output_terminal_descriptor, ")"
	;

simple_path_declaration =
	parallel_path_description, "=", path_delay_value |
	full_path_description, "=", path_delay_value
	;

path_declaration =
	simple_path_declaration, ";" |
	edge_sensitive_path_declaration, ";" |
	state_dependent_path_declaration, ";"
	;

showcancelled_declaration =
	"showcancelled", list_of_path_outputs, ";" |
	"noshowcancelled", list_of_path_outputs, ";"
	;

pulsestyle_declaration =
	"pulsestyle_onevent", list_of_path_outputs, ";" |
	"pulsestyle_ondetect", list_of_path_outputs, ";"
	;

specify_item =
	specparam_declaration |
	pulsestyle_declaration |
	showcancelled_declaration |
	path_declaration |
	system_timing_check
	;

specify_block =
	"specify", { specify_item }, "endspecify"
	;

task_enable =
	hierarchical_task_identifier, [ "(", expression, { ",", expression }, ")" ], ";"
	;

system_task_enable =
	system_task_identifier, [ "(", [ expression ], { ",", [ expression ] }, ")" ], ";"
	;

loop_statement =
	"forever", statement |
	"repeat", "(", expression, ")", statement |
	"while", "(", expression, ")", statement |
	"for", "(", variable_assignment, ";", expression, ";", variable_assignment, ")", statement
	;

case_item =
	expression, { ",", expression }, ":", statement_or_null |
	"default", [ ":" ], statement_or_null
	;

case_statement =
	"case", "(", expression, ")", case_item, { case_item }, "endcase" |
	"casez", "(", expression, ")", case_item, { case_item }, "endcase" |
	"casex", "(", expression, ")", case_item, { case_item }, "endcase"
	;

if_else_if_statement =
	"if", "(", expression, ")", statement_or_null, { "else", "if", "(", expression, ")", statement_or_null }, [ "else", statement_or_null ]
	;

conditional_statement =
	"if", "(", expression, ")", statement_or_null, [ "else", statement_or_null ] |
	if_else_if_statement
	;

wait_statement =
	"wait", "(", expression, ")", statement_or_null
	;

procedural_timing_control_statement =
	procedural_timing_control, statement_or_null
	;

procedural_timing_control =
	delay_control |
	event_control
	;

event_trigger =
	expression |
	"posedge", expression |
	"negedge", expression |
	event_expression, "or", event_expression |
	event_expression, ",", event_expression
	;

event_control =
	"@", hierarchical_event_identifier |
	"@", "(", event_expression, ")" |
	"@", "*" |
	"@", "(", "*", ")"
	;

disable_statement =
	"disable", hierarchical_task_identifier, ";" |
	"disable", hierarchical_block_identifier, ";"
	;

delay_or_event_control =
	delay_control |
	event_control |
	"repeat", "(", expression, ")", event_control
	;

delay_control =
	"#", delay_value |
	"#", "(", mintypmax_expression, ")"
	;

(* See NOTE 1 *)
function_statement =
	statement
	;

statement_or_null =
	statement |
	{ attribute_instance }, ";"
	;

statement =
	{ attribute_instance }, blocking_assignment, ";" |
	{ attribute_instance }, case_statement |
	{ attribute_instance }, conditional_statement |
	{ attribute_instance }, disable_statement |
	{ attribute_instance }, event_trigger |
	{ attribute_instance }, loop_statement |
	{ attribute_instance }, nonblocking_assignment, ";" |
	{ attribute_instance }, par_block |
	{ attribute_instance }, procedural_continuous_assignments, ";" |
	{ attribute_instance }, procedural_timing_control_statement |
	{ attribute_instance }, seq_block |
	{ attribute_instance }, system_task_enable |
	{ attribute_instance }, task_enable |
	{ attribute_instance }, wait_statement
	;

seq_block =
	"begin", [ ":", block_identifier, { block_item_declaration } ], { statement }, "end"
	;

par_block =
	"fork", [ ":", block_identifier, { block_item_declaration } ], { statement }, "join"
	;

variable_assignment =
	variable_lvalue, "=", expression
	;

procedural_continuous_assignments =
	"assign", variable_assignment |
	"deassign", variable_lvalue |
	"force", variable_assignment |
	"force", net_assignment |
	"release", variable_lvalue |
	"release", net_lvalue
	;

nonblocking_assignment =
	variable_lvalue, "<=", [ delay_or_event_control ], expression
	;

blocking_assignment =
	variable_lvalue, "=", [ delay_or_event_control ], expression
	;

always_construct =
	"always", statement
	;

initial_construct =
	"initial", statement
	;

net_assignment =
	net_lvalue, "=", expression
	;

list_of_net_assignments =
	net_assignment, { ",", net_assignment }
	;

continuous_assign =
	"assign", [ drive_strength ], [ delay3 ], list_of_net_assignments, ";"
	;

name_of_udp_instance =
	udp_instance_identifier, [ range ]
	;

udp_instance =
	[ name_of_udp_instance ], "(", output_terminal, ",", input_terminal, ",", { ",", input_terminal }, ")"
	;

udp_instantiation =
	udp_identifier, [ drive_strength ], [ delay2 ], udp_instance, { ",", udp_instance }, ";"
	;

edge_symbol =
	"r" | "R" | "f" | "F" | "p" | "P" | "n" | "N" | "*"
	;

level_symbol =
	"0" | "1" | "x" | "X" | "?" | "b" | "B"
	;

output_symbol =
	"0" | "1" | "x" | "X"
	;

next_state =
	output_symbol | "-"
	;

current_state =
	level_symbol
	;

edge_indicator =
	"(", level_symbol, level_symbol, ")" | edge_symbol
	;

edge_input_list =
	{ level_symbol }, edge_indicator, { level_symbol }
	;

level_input_list =
	level_symbol, { level_symbol }
	;

seq_input_list =
	level_input_list |
	edge_input_list
	;

sequential_entry =
	seq_input_list, ":", current_state, ":", next_state, ";"
	;

init_val =
	"1'b0" | "1'b1" | "1'bx" | "1'bX" | "1'B0" | "1'B1" | "1'Bx" | "1'BX" | "1" | "0"
	;

udp_initial_statement =
	"initial", output_port_identifier, "=", init_val, ";"
	;

sequential_body =
	[ udp_initial_statement ], "table", sequential_entry, { sequential_entry }, "endtable"
	;

combinatorial_entry =
	level_input_list, ":", output_symbol, ";"
	;

combinatorial_body =
	"table", combinatorial_entry, { combinatorial_entry }, "endtable"
	;

udp_body =
	combinatorial_body |
	sequential_body
	;

udp_reg_declaration =
	{ attribute_instance }, "reg", variable_type
	;

udp_input_declaration =
	{ attribute_instance }, "input", list_of_port_identifiers
	;

udp_output_declaration =
	{ attribute_instance }, "output", port_identifier |
	{ attribute_instance }, "output", "reg", port_identifier, [ "=", constant_expression ]
	;

udp_port_declaration =
	udp_output_declaration, ";" |
	udp_input_declaration, ";" |
	udp_reg_declaration, ";"
	;

udp_declaration_port_list =
	udp_output_declaration, ",", udp_input_declaration, { ",", udp_input_declaration }
	;

udp_port_list =
	output_port_identifier, ",", input_port_identifier, { ",", input_port_identifier }
	;

udp_declaration =
	{ attribute_instance }, "primitive", udp_identifier, "(", udp_port_list, ")", ";", udp_port_declaration, { udp_port_declaration }, udp_body, "endprimitive" |
	{ attribute_instance }, "primitive", udp_identifier, "(", udp_declaration_port_list, ")", ";", udp_body, "endprimitive"
	;

generate_block_or_null =
	generate_block | ";"
	;

generate_block =
	module_or_generate_item |
	"begin", [ ":", generate_block_identifier ], { module_or_generate_item }, "end"
	;

case_generate_item =
	constant_expression, { ",", constant_expression }, ":", generate_block_or_null |
	"default", [ ":" ], generate_block_or_null
	;

case_generate_construct =
	"case", "(", constant_expression, ")", case_generate_item, { case_generate_item }, "endcase"
	;

if_generate_construct =
	"if", "(", constant_expression, ")", generate_block_or_null, [ "else", generate_block_or_null ]
	;

conditional_generate_construct =
	if_generate_construct |
	case_generate_construct
	;

genvar_primary =
	constant_primary |
	genvar_identifier
	;

genvar_iteration =
	genvar_identifier, "=", genvar_expression
	;

genvar_expression =
	genvar_primary |
	unary_operator, { attribute_instance }, genvar_primary |
	genvar_expression, binary_operator, { attribute_instance }, genvar_expression |
	genvar_expression, "?", { attribute_instance }, genvar_expression, ":", genvar_expression
	;

genvar_initialization =
	genvar_identifier, "=", constant_expression
	;

loop_generate_construct =
	"for", "(", genvar_initialization, ";", genvar_expression, ";", genvar_iteration, ")", generate_block
	;

list_of_genvar_identifiers =
	genvar_identifier, { ",", genvar_identifier }
	;

genvar_declaration =
	"genvar", list_of_genvar_identifiers, ";"
	;

generate_region =
	"generate", { module_or_generate_item }, "endgenerate"
	;

named_port_connection =
	{ attribute_instance }, ".", port_identifier, "(", [ expression ], ")"
	;

ordered_port_connection =
	{ attribute_instance }, [ expression ]
	;

list_of_port_connections =
	ordered_port_connection, { ",", ordered_port_connection } |
	named_port_connection, { ",", named_port_connection }
	;

name_of_module_instance =
	module_instance_identifier, [ range ]
	;

module_instance =
	name_of_module_instance, "(", [ list_of_port_connections ], ")"
	;

named_parameter_assignment =
	".", parameter_identifier, "(", [ mintypmax_expression ], ")"
	;

ordered_parameter_assignment =
	expression
	;

list_of_parameter_assignments =
	ordered_parameter_assignment, { ",", ordered_parameter_assignment } |
	named_parameter_assignment, { ",", named_parameter_assignment }
	;

parameter_value_assignment =
	"#", "(", list_of_parameter_assignments, ")"
	;

module_instantiation =
	module_identifier, [ parameter_value_assignment ], module_instance, { ",", module_instance }, ";"
	;

pass_switchtype =
	"tran" | "rtran"
	;

pass_en_switchtype =
	"tranif0" | "tranif1" | "rtranif0" | "rtranif1"
	;

n_output_gatetype =
	"buf" | "not"
	;

n_input_gatetype =
	"and" | "nand" | "or" | "nor" | "xor" | "xnor"
	;

mos_switchtype =
	"nmos" | "pmos" | "rnmos" | "rpmos"
	;

enable_gatetype =
	"bufif0" | "bufif1" | "notif0" | "notif1"
	;

cmos_switchtype =
	"cmos" | "rcmos"
	;

pcontrol_terminal =
	expression
	;

output_terminal =
	net_lvalue
	;

ncontrol_terminal =
	expression
	;

input_terminal =
	expression
	;

inout_terminal =
	net_lvalue
	;

enable_terminal =
	expression
	;

pullup_strength =
	"(", strength0, ",", strength1, ")" |
	"(", strength1, ",", strength0, ")" |
	"(", strength1, ")"
	;

pulldown_strength =
	"(", strength0, ",", strength1, ")" |
	"(", strength1, ",", strength0, ")" |
	"(", strength0, ")"
	;

name_of_gate_instance =
	gate_instance_identifier, [ range ]
	;

pull_gate_instance =
	[ name_of_gate_instance ], "(", output_terminal, ")"
	;

pass_enable_switch_instance =
	[ name_of_gate_instance ], "(", inout_terminal, ",", inout_terminal, ",", enable_terminal, ")"
	;

pass_switch_instance =
	[ name_of_gate_instance ], "(", inout_terminal, ",", inout_terminal, ")"
	;

n_output_gate_instance =
	[ name_of_gate_instance ], "(", output_terminal, { ",", output_terminal }, ",", input_terminal, ")"
	;

n_input_gate_instance =
	[ name_of_gate_instance ], "(", output_terminal, ",", input_terminal, { ",", input_terminal }, ")"
	;

mos_switch_instance =
	[ name_of_gate_instance ], "(", output_terminal, ",", input_terminal, ",", enable_terminal, ")"
	;

enable_gate_instance =
	[ name_of_gate_instance ], "(", output_terminal, ",", input_terminal, ",", enable_terminal, ")"
	;

cmos_switch_instance =
	[ name_of_gate_instance ], "(", output_terminal, ",", input_terminal, ",", ncontrol_terminal, ",", pcontrol_terminal, ")"
	;

gate_instantiation =
	cmos_switchtype, [ delay3 ], cmos_switch_instance, { ",", cmos_switch_instance }, ";" |
	enable_gatetype, [ drive_strength ], [ delay3 ], enable_gate_instance, { ",", enable_gate_instance }, ";" |
	mos_switchtype, [ delay3 ], mos_switch_instance, { ",", mos_switch_instance }, ";" |
	n_input_gatetype, [ drive_strength ], [ delay2 ], n_input_gate_instance, { ",", n_input_gate_instance }, ";" |
	n_output_gatetype, [ drive_strength ], [ delay2 ], n_output_gate_instance, { ",", n_output_gate_instance }, ";" |
	pass_en_switchtype, [ delay2 ], pass_enable_switch_instance, { ",", pass_enable_switch_instance }, ";" |
	pass_switchtype, pass_switch_instance, { ",", pass_switch_instance }, ";" |
	"pulldown", [ pulldown_strength ], pull_gate_instance, { ",", pull_gate_instance }, ";" |
	"pullup", [ pullup_strength ], pull_gate_instance, { ",", pull_gate_instance }, ";"
	;

block_real_type =
	real_identifier, { dimension }
	;

block_variable_type =
	variable_identifier, { dimension }
	;

list_of_block_real_identifiers =
	block_real_type, { ",", block_real_type }
	;

list_of_block_variable_identifiers =
	block_variable_type, { ",", block_variable_type }
	;

block_item_declaration =
	{ attribute_instance }, "reg", [ "signed" ], list_of_block_variable_identifiers, ";" |
	{ attribute_instance }, "integer", list_of_block_variable_identifiers, ";" |
	{ attribute_instance }, "time", list_of_block_variable_identifiers, ";" |
	{ attribute_instance }, "real", list_of_block_real_identifiers, ";" |
	{ attribute_instance }, "realtime", list_of_block_real_identifiers, ";" |
	{ attribute_instance }, event_declaration |
	{ attribute_instance }, local_parameter_declaration, ";" |
	{ attribute_instance }, parameter_declaration, ";"
	;

task_port_type =
	"integer" | "real" | "realtime" | "time"
	;

tf_inout_declaration =
	"inout", [ "reg" ], [ "signed" ], [ range ], list_of_port_identifiers |
	"inout", task_port_type, list_of_port_identifiers
	;

tf_output_declaration =
	"output", [ "reg" ], [ "signed" ], [ range ], list_of_port_identifiers |
	"output", task_port_type, list_of_port_identifiers
	;

tf_input_declaration =
	"input", [ "reg" ], [ "signed" ], [ range ], list_of_port_identifiers |
	"input", task_port_type, list_of_port_identifiers
	;

task_port_item =
	{ attribute_instance }, tf_input_declaration |
	{ attribute_instance }, tf_output_declaration |
	{ attribute_instance }, tf_inout_declaration
	;

task_port_list =
	task_port_item, { ",", task_port_item }
	;

task_item_declaration =
	block_item_declaration |
	{ attribute_instance }, tf_input_declaration, ";" |
	{ attribute_instance }, tf_output_declaration, ";" |
	{ attribute_instance }, tf_inout_declaration, ";"
	;

task_declaration =
	"task", [ "automatic" ], task_identifier, ";", { task_item_declaration }, statement_or_null, "endtask" |
	"task", [ "automatic" ], task_identifier, "(", [ task_port_list ], ")", ";", { block_item_declaration }, statement_or_null, "endtask"
	;

function_range_or_type =
	[ "signed" ], [ range ] |
	"integer" |
	"real" |
	"realtime" |
	"time"
	;

function_port_list =
	{ attribute_instance }, tf_input_declaration, { ",", { attribute_instance }, tf_input_declaration }
	;

function_item_declaration =
	block_item_declaration |
	{ attribute_instance }, tf_input_declaration , ";"
	;

function_declaration =
	"function", [ "automatic" ], [ function_range_or_type ], function_identifier, ";", function_item_declaration, { function_item_declaration }, function_statement, "endfunction" |
	"function", [ "automatic" ], [ function_range_or_type ], function_identifier, "(", function_port_list, ")", ";", { block_item_declaration }, function_statement, "endfunction"
	;

range =
	"[", msb_constant_expression,":", lsb_constant_expression, "]"
	;

dimension =
	"[", dimension_constant_expression, ":", dimension_constant_expression ,"]"
	;

limit_value =
	constant_mintypmax_expression
	;

reject_limit_value =
	limit_value
	;

error_limit_value =
	limit_value
	;

pulse_control_specparam =
	"PATHPULSE$", "=", "(", reject_limit_value, [ ",", error_limit_value ], ")" |
	"PATHPULSE$", specify_input_terminal_descriptor, "$", specify_output_terminal_descriptor, "=", "(", reject_limit_value, [ ",", error_limit_value ], ")"
	;

specparam_assignment =
	specparam_identifier, "=", constant_mintypmax_expression |
	pulse_control_specparam
	;

param_assignment =
	parameter_identifier, "=", constant_mintypmax_expression
	;

net_decl_assignment =
	net_identifier, "=", expression
	;

defparam_assignment =
	hierarchical_parameter_identifier, "=", constant_mintypmax_expression
	;

list_of_variable_port_identifiers =
	port_identifier, [ "=", constant_expression ], { ",", port_identifier, [ "=", constant_expression ] }
	;

list_of_variable_identifiers =
	variable_type, { ",", variable_type }
	;

list_of_specparam_assignments =
	specparam_assignment, { ",", specparam_assignment }
	;

list_of_real_identifiers =
	real_type, { ",", real_type }
	;

list_of_port_identifiers =
	port_identifier, { ",", port_identifier }
	;

list_of_param_assignments =
	param_assignment, { ",", param_assignment }
	;

list_of_net_identifiers =
	net_identifier, { dimension }, { ",", net_identifier, { dimension } }
	;

list_of_net_decl_assignments =
	net_decl_assignment, { ",", net_decl_assignment }
	;

list_of_event_identifiers =
	event_identifier, { dimension }, { ",", event_identifier, { dimension } }
	;

list_of_defparam_assignments =
	defparam_assignment, { ",", defparam_assignment }
	;

delay_value =
	unsigned_number |
	real_number |
	identifier
	;

delay2 =
	"#", delay_value |
	"#", "(", mintypmax_expression, [ ",", mintypmax_expression, [ ",", mintypmax_expression ] ], ")"
	;

delay3 =
	"#", delay_value |
	"#", "(", mintypmax_expression, [ ",", mintypmax_expression ], ")"
	;

charge_strength =
	"(", "small", ")" |
	"(", "medium", ")" |
	"(", "large", ")"
	;

strength1 =
	"supply1" | "strong1" | "pull1" | "weak1"
	;

strength0 =
	"supply0" | "strong0" | "pull0" | "weak0"
	;

drive_strength =
	"(", strength0, ",", strength1, ")" |
	"(", strength1, ",", strength0, ")" |
	"(", strength0, ",", "highz1", ")" |
	"(", strength1, ",", "highz0", ")" |
	"(", "highz0", ",", strength1, ")" |
	"(", "highz1", ",", strength0, ")"
	;

variable_type =
	variable_identifier, { dimension } |
	variable_identifier, "=", constant_expression
	;

real_type =
	real_identifier, { dimension } |
	real_identifier, "=", constant_expression
	;

output_variable_type =
	"integer" | "time"
	;

net_type =
	"supply0" | "supply1" | "tri" | "triand" | "trior" | "tri0" | "tri1" |
	"uwire" | "wire" | "wand" | "wor"
	;

time_declaration =
	"time", list_of_variable_identifiers, ";"
	;

reg_declaration =
	"reg", [ "signed" ], [ range ], list_of_variable_identifiers, ";"
	;

realtime_declaration =
	"realtime", list_of_real_identifiers, ";"
	;

real_declaration =
	"real", list_of_real_identifiers, ";"
	;

net_declaration =
	net_type, [ "signed" ], [ delay3 ], list_of_net_identifiers, ";" |
	net_type, [ drive_strength ], [ "signed" ], [ delay3 ], list_of_net_decl_assignments, ";" |
	net_type, [ "vectored" | "scalared" ], [ "signed" ], range, [ delay3 ], list_of_net_identifiers, ";" |
	net_type, [ drive_strength ], [ "vectored" | "scalared" ], [ "signed" ], range, [ delay3 ], list_of_net_decl_assignments, ";" |
	"trireg", [ charge_strength ], [ "signed" ], [ delay3 ], list_of_net_identifiers, ";" |
	"trireg", [ drive_strength ], [ "signed" ], [ delay3 ], list_of_net_decl_assignments, ";" |
	"trireg", [ charge_strength ], [ "vectored" | "scalared" ], [ "signed" ], range, [ delay3 ], list_of_net_identifiers, ";" |
	"trireg", [ drive_strength ], [ "vectored" | "scalared" ], [ "signed" ], range, [ delay3 ], list_of_net_decl_assignments, ";"
	;

integer_declaration =
	"integer", list_of_variable_identifiers, ";"
	;

event_declaration =
	"event", list_of_event_identifiers, ";"
	;

output_declaration =
	"output", [ net_type ], [ "signed" ], [ range ], list_of_port_identifiers |
	"output", "reg", [ "signed" ], [ range ], list_of_variable_port_identifiers |
	"output", [ output_variable_type ], list_of_variable_port_identifiers
	;

input_declaration =
	"input", [ net_type ], [ "signed" ], [ range ], list_of_port_identifiers
	;

inout_declaration =
	"inout", [ net_type ], [ "signed" ], [ range ], list_of_port_identifiers
	;

parameter_type =
	"integer" | "real" | "realtime" | "time"
	;

specparam_declaration =
	"specparam", [ range ], list_of_specparam_assignments, ";"
	;

parameter_declaration =
	"parameter", [ "signed" ], [ range ], list_of_param_assignments |
	"parameter", parameter_type, list_of_param_assignments
	;

local_parameter_declaration =
	"localparam", [ "signed" ], [ range ], list_of_param_assignments |
	"localparam", parameter_type, list_of_param_assignments
	;

use_clause =
	"use", [ library_identifier, "." ], cell_identifier, [ ":", "config" ]
	;

liblist_clause =
	"liblist", { library_identifier }
	;

cell_clause =
	"cell", [ library_identifier, "." ], cell_identifier
	;

inst_name =
	topmodule_identifier, { ".", instance_identifier }
	;

inst_clause =
	"instance", inst_name
	;

default_clause =
	"default"
	;

config_rule_statement =
	default_clause, liblist_clause, ";" |
	inst_clause, liblist_clause, ";" |
	inst_clause, use_clause, ";" |
	cell_clause, liblist_clause, ";" |
	cell_clause, use_clause, ";"
	;

design_statement =
	"design", { [ library_identifier, "." ], cell_identifier }, ";"
	;

config_declaration =
	"config", config_identifier, ";", design_statement, { config_rule_statement }, "endconfig"
	;

parameter_override =
	"defparam", list_of_defparam_assignments, ";"
	;

non_port_module_item =
	module_or_generate_item |
	generate_region |
	specify_block |
	{ attribute_instance }, parameter_declaration, ";" |
	{ attribute_instance }, specparam_declaration
	;

module_or_generate_item_declaration =
	net_declaration |
	reg_declaration |
	integer_declaration |
	real_declaration |
	time_declaration |
	realtime_declaration |
	event_declaration |
	genvar_declaration |
	task_declaration |
	function_declaration
	;

module_or_generate_item =
	{ attribute_instance }, module_or_generate_item_declaration |
	{ attribute_instance }, local_parameter_declaration, ";" |
	{ attribute_instance }, parameter_override |
	{ attribute_instance }, continuous_assign |
	{ attribute_instance }, gate_instantiation |
	{ attribute_instance }, udp_instantiation |
	{ attribute_instance }, module_instantiation |
	{ attribute_instance }, initial_construct |
	{ attribute_instance }, always_construct |
	{ attribute_instance }, loop_generate_construct |
	{ attribute_instance }, conditional_generate_construct
	;

module_item =
	port_declaration, ";" |
	non_port_module_item
	;

port_declaration =
	{ attribute_instance }, inout_declaration |
	{ attribute_instance }, input_declaration |
	{ attribute_instance }, output_declaration
	;

port_reference =
	port_identifier, [ "[", constant_range_expression, "]" ]
	;

port_expression =
	port_reference |
	"{", port_reference, { ",", port_reference }, "}"
	;

port =
	[ port_expression ] |
	".", port_identifier, "(", [ port_expression ], ")"
	;

list_of_port_declarations =
	"(", port_declaration, { ",", port_declaration }, ")" |
	"(", ")"
	;

list_of_ports =
	"(", port, { ",", port }, ")"
	;

module_parameter_port_list =
	"#(", parameter_declaration, { ",", parameter_declaration }, ")"
	;

module_keyword =
	"module" | "macromodule"
	;

module_declaration =
	{ attribute_instance }, module_keyword, module_identifier, [ module_parameter_port_list ], list_of_ports, ";", { module_item }, "endmodule" |
	{ attribute_instance }, module_keyword, module_identifier, [ module_parameter_port_list ], [ list_of_port_declarations ], ";", { non_port_module_item }, "endmodule"
	;

description =
	module_declaration |
	udp_declaration |
	config_declaration
	;

source_text =
	{ description }
	;

(* Library Map File *)

include_statement =
	"include", file_path_spec, ";"
	;

library_declaration =
	"library", library_identifier, file_path_spec, [ { ",", file_path_spec } ], [ "-incdir", file_path_spec, { ",", file_path_spec } ], ";"
	;

library_description =
	library_declaration |
	include_statement |
	config_declaration
	;

library_text =
	{ library_description }
	;

(*
	Keywords:
		always
		and
		assign
		automatic
		begin
		buf
		bufif0
		bufif1
		case
		casex
		casez
		cell
		cmos
		config
		deassign
		default
		defparam
		design
		disable
		edge
		else
		end
		endcase
		endconfig
		endfunction
		endgenerate
		endmodule
		endprimitive
		endspecify
		endtable
		endtask
		event
		for
		force
		forever
		fork
		function
		generate
		genvar
		highz0
		highz1
		if
		ifnone
		incdir
		include
		initial
		inout
		input
		instance
		integer
		join
		large
		liblist
		library
		localparam
		macromodule
		medium
		module
		nand
		negedge
		nmos
		nor
		noshowcancelled
		not
		notif0
		notif1
		or
		output
		parameter
		pmos
		posedge
		primitive
		pull0
		pull1
		pulldown
		pullup
		pulsestyle_ondetect
		pulsestyle_onevent
		rcmos
		real
		realtime
		reg
		release
		repeat
		rnmos
		rpmos
		rtran
		rtranif0
		rtranif1
		scalared
		showcancelled
		signed
		small
		specify
		specparam
		strong0
		strong1
		supply0
		supply1
		table
		task
		time
		tran
		tranif0
		tranif1
		tri
		tri0
		tri1
		triand
		trior
		trireg
		unsigned (reserved)
		use
		uwire
		vectored
		wait
		wand
		weak0
		weak1
		while
		wire
		wor
		xnor
		xor
*)
