(* SPDX-License-Identifier: BSD-3-Clause *)
(* EBNF grammar for Verilog 1995 (IEEE 1364-1995) *)
(*
	NOTE 1: The period (`.`) in any identifier shall not be preceded by a space
	NOTE 2: The dollar (`$`) character may not be followed by `white_space`
*)

white_space =
	" " | "\t" | "\n"
	;

escaped_identifier =
	"\\", { ? Any_ASCII_character_except_white_space ? }, white_space
	;

simple_identifier =
	a-zA-Z_, { a-zA-Z0-9_$ }
	;

IDENTIFIER =
	simple_identifier |
	escaped_identifier
	;

(* See NOTE 1 *)
identifier =
	IDENTIFIER, [ { ".", IDENTIFIER } ]
	;

comment_text =
	{ ? Any_ASCII_character ? }
	;

long_comment =
	"/*", comment_text, "*/"
	;

short_comment =
	"//", comment_text, "\n"
	;

comment =
	short_comment |
	long_comment
	;

string =
	'"', { ? Any_ASCII_Characters_except_new_line ? }, '"'
	;

(* See NOTE 2 *)
name_of_system_function =
	"$", identifier
	;

function_call =
	function_identifier, "(", expression, { ",", expression }, ")" |
	name_of_system_function, [ "(", expression, { ",", expression }, ")" ]
	;

multiple_concatenation =
	"{", expression, "{", expression, { ",", expression }, "}", "}"
	;

concatenation =
	"{", expression, { ",", expression }, "}"
	;

hex_digit =
	"x" | "X" | "z" | "Z" | "0" | "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9" |
	"a" | "b" | "c" | "d" | "e" | "f" |
	"A" | "B" | "C" | "D" | "E" | "F"
	;

octal_digit =
	"x" | "X" | "z" | "Z" | "0" | "1" | "2" | "3" | "4" | "5" | "6" | "7"
	;

binary_digit =
	"x" | "X" | "z" | "Z" | "0" | "1"
	;

decimal_digit =
	"0" | "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9"
	;

hex_base =
	"'h" | "'H"
	;

octal_base =
	"'o" | "'O"
	;

binary_base =
	"'b" | "'B"
	;

decimal_base =
	"'d" | "'D"
	;

unsigned_number =
	decimal_digit, { "_" | decimal_digit }
	;

size =
	unsigned_number
	;

sign =
	"+" | "-"
	;

hex_number =
	[ size ], hex_base, hex_digit, { "_", | hex_digit }
	;

octal_number =
	[ size ], octal_base, octal_digit, { "_", | octal_digit }
	;

binary_number =
	[ size ], binary_base, binary_digit, { "_", | binary_digit }
	;

decimal_number =
	[ sign ], unsigned_number |
	[ size ], decimal_base, unsigned_number
	;

real_number =
	[ sign ], unsigned_number, ".", unsigned_number |
	[ sign ], unsigned_number, [ ".", unsigned_number ], "e", [ sign ], unsigned_number |
	[ sign ], unsigned_number, [ ".", unsigned_number ], "E", [ sign ], unsigned_number
	;

number =
	decimal_number |
	octal_number |
	binary_number |
	hex_number |
	real_number
	;

primary =
	number |
	identifier |
	identifier, "[", expression, "]" |
	identifier, "[", msb_constant_expression, ":", lsb_constant_expression, "]" |
	concatenation |
	multiple_concatenation |
	function_call |
	"(", mintypmax_expression, ")"
	;

binary_operator =
	"+" | "-" | "*" | "/" | "%" | "==" | "!=" | "===" | "!==" | "&&" | "||" |
	"<" | "<=" | ">" | ">=" | "&" | "|" | "^" | "^~" | "~^" | ">>" | "<<"
 	;

unary_operator =
	"+" | "-" | "!" | "~" | "&" | "~&" | "|" | "~|" | "^" | "~^" | "^~"
	;

expression =
	primary |
	unary_operator, primary |
	expression, binary_operator, expression |
	expression, "?", expression, ":", expression |
	string
	;

mintypmax_expression =
	expression |
	expression, ":", expression, ":", expression
	;

constant_mintypmax_expression =
	constant_expression |
	constant_expression, ":", constant_expression, ":", constant_expression
	;

constant_primary =
	number |
	parameter_identifier |
	constant_concatenation |
	constant_multiple_concatenation
	;

constant_expression =
	constant_primary |
	unary_operator, constant_primary |
	constant_expression, binary_operator, constant_expression |
	constant_expression, "?", constant_expression, ":", constant_expression |
	string
	;

reg_lvalue =
	register_identifier |
	register_identifier, "[", expression, "]" |
	register_identifier, "[", msb_constant_expression, ":", lsb_constant_expression, "]" |
	reg_concatenation
	;

net_lvalue =
	net_identifier |
	net_identifier, "[", expression, "]" |
	net_identifier, "[", msb_constant_expression, ":", lsb_constant_expression, "]" |
	net_concatenation
	;

notify_register =
	register_identifier
	;

scalar_constant =
	"1'b0" | "1'b1" | "1'B0" | "1'B1" | "'b0" | "'b1" | "'B0" | "'B1" | "1" | "0"
	;

timing_check_limit =
	expression
	;

scalar_timing_check_condition =
	expression |
	"~", expression |
	expression, "==", scalar_constant |
	expression, "===", scalar_constant |
	expression, "!=", scalar_constant |
	expression, "!==", scalar_constant
	;

timing_check_condition =
	scalar_timing_check_condition |
	"(", scalar_timing_check_condition, ")"
	;

edge_descriptor =
	"01" | "10" | "0x" | "x0" | "1x" | "x1"
	;

edge_control_specifier =
	"edge", "[", edge_descriptor, [ ",", edge_descriptor ], "]"
	;

timing_check_event_control =
	"posedge" | "negedge" | edge_control_specifier
	;

controlled_timing_check_event =
	timing_check_event_control, specify_terminal_descriptor, [ "&&&", timing_check_condition ]
	;

specify_terminal_descriptor =
	specify_input_terminal_descriptor |
	specify_output_terminal_descriptor
	;

timing_check_event =
	[ timing_check_event_control ], specify_terminal_descriptor, [ "&&&", timing_check_condition ]
	;

system_timing_check =
	"$setup", "(", timing_check_event, ",", timing_check_event, ",", timing_check_limit, [ ",", notify_register ], ")", ";" |
	"$hold", "(", timing_check_event, ",", timing_check_event, ",", timing_check_limit, [ ",", notify_register ], ")", ";" |
	"$period", "(", controlled_timing_check_event, ",", timing_check_limit, [ ",", notify_register ], ")", ";" |
	"$width", "(", controlled_timing_check_event, ",", timing_check_limit, ",", constant_expression, [ ",", notify_register ], ")", ";" |
	"$skew", "(", timing_check_event, ",", timing_check_event, ",", timing_check_limit, [ ",", notify_register ], ")", ";" |
	"$recovery", "(", controlled_timing_check_event, ",", timing_check_event, ",", timing_check_limit, [ ",", notify_register ], ")", ";" |
	"$setuphold", "(", timing_check_event, ",", timing_check_event, ",", timing_check_limit, ",", timing_check_limit, [ ",", notify_register ], ")", ";"
	;

state_dependent_path_declaration =
	"if", "(", conditional_expression, ")", simple_path_declaration |
	"if", "(", conditional_expression, ")", edge_sensitive_path_declaration |
	"ifnone", simple_path_declaration
	;

edge_identifier =
	"posedge" | "negedge"
	;

data_source_expression =
	expression
	;

full_edge_sensitive_path_description =
	"(", [ edge_identifier ], list_of_path_inputs, "*>", list_of_path_outputs, [ polarity_operator ], ":", data_source_expression, ")"
	;

parallel_edge_sensitive_path_description =
	"(", [ edge_identifier ], specify_input_terminal_descriptor, "=>", specify_output_terminal_descriptor, [ polarity_operator ], ":", data_source_expression, ")"
	;

edge_sensitive_path_declaration =
	parallel_edge_sensitive_path_description, "=", path_delay_value |
	full_edge_sensitive_path_description, "=", path_delay_value
	;

path_delay_expression =
	constant_mintypmax_expression
	;

tzx_path_delay_expression =
	path_delay_expression
	;

txz_path_delay_expression =
	path_delay_expression
	;

tx0_path_delay_expression =
	path_delay_expression
	;

t1x_path_delay_expression =
	path_delay_expression
	;

tx1_path_delay_expression =
	path_delay_expression
	;

t0x_path_delay_expression =
	path_delay_expression
	;

tz0_path_delay_expression =
	path_delay_expression
	;

t1z_path_delay_expression =
	path_delay_expression
	;

tz1_path_delay_expression =
	path_delay_expression
	;

t0z_path_delay_expression =
	path_delay_expression
	;

t10_path_delay_expression =
	path_delay_expression
	;

t01_path_delay_expression =
	path_delay_expression
	;

tz_path_delay_expression =
	path_delay_expression
	;

tfall_path_delay_expression =
	path_delay_expression
	;

trise_path_delay_expression =
	path_delay_expression
	;

t_path_delay_expression =
	path_delay_expression
	;

list_of_path_delay_expressions =
	t_path_delay_expression |
	trise_path_delay_expression, ",", tfall_path_delay_expression |
	trise_path_delay_expression, ",", tfall_path_delay_expression, ",", tz_path_delay_expression |
	t01_path_delay_expression, ",", t10_path_delay_expression, ",", t0z_path_delay_expression, ",",
	tz1_path_delay_expression, ",", t1z_path_delay_expression, ",", tz0_path_delay_expression |
	t01_path_delay_expression, ",", t10_path_delay_expression, ",", t0z_path_delay_expression, ",",
	tz1_path_delay_expression, ",", t1z_path_delay_expression, ",", tz0_path_delay_expression, ",",
	t0x_path_delay_expression, ",", tx1_path_delay_expression, ",", t1x_path_delay_expression, ",",
	tx0_path_delay_expression, ",", txz_path_delay_expression, ",", tzx_path_delay_expression
 	;

path_delay_value =
	list_of_path_delay_expressions |
	"(", list_of_path_delay_expressions, ")"
	;

polarity_operator =
	"+" | "-"
	;

output_identifier =
	output_identifier |
	inout_port_identifier
	;

input_identifier =
	input_port_identifier |
	inout_port_identifier
	;

specify_output_terminal_descriptor =
	output_identifier |
	output_identifier, "[", constant_expression, "]" |
	output_identifier, "[", msb_constant_expression, ":", lsb_constant_expression, "]"
	;

specify_input_terminal_descriptor =
	input_identifier |
	input_identifier, "[", constant_expression, "]" |
	input_identifier, "[", msb_constant_expression, ":", lsb_constant_expression, "]"
	;

list_of_path_outputs =
	specify_output_terminal_descriptor, { ",", specify_output_terminal_descriptor }
	;

list_of_path_inputs =
	specify_input_terminal_descriptor, { ",", specify_input_terminal_descriptor }
	;

full_path_description =
	"(", list_of_path_inputs, [ polarity_operator ], "*>", list_of_path_outputs, ")"
	;

parallel_path_description =
	"(", specify_input_terminal_descriptor, [ polarity_operator ], "=>", specify_output_terminal_descriptor, ")"
	;

simple_path_declaration =
	parallel_path_description, "=", path_delay_value |
	full_path_description, "=", path_delay_value
	;

path_declaration =
	simple_path_declaration, ";" |
	edge_sensitive_path_declaration, ";" |
	state_dependent_path_declaration, ";"
	;

limit_value =
	constant_mintypmax_expression
	;

reject_limit_value =
	limit_value
	;

error_limit_value =
	limit_value
	;

pulse_control_specparam =
	"PATHPULSE$", "=", "(", reject_limit_value, [ ",", error_limit_value ], ")", ";" |
	"PATHPULSE$", specify_input_terminal_descriptor, "$", specify_output_terminal_descriptor, "=", "(", reject_limit_value, [ ",", error_limit_value ], ")", ";"
	;

specparam_assignment =
	specparam_identifier, "=", constant_expression |
	pulse_control_specparam
	;

list_of_specparam_assignments =
	specparam_assignment, { ",", specparam_assignment }
	;

specparam_declaration =
	"specparam", list_of_specparam_assignments, ";"
	;

specify_item =
	specparam_declaration |
	path_declaration |
	system_timing_check
	;

specify_block =
	"specify", [ specify_item ], "endspecify"
	;

(* See NOTE 2 *)
system_task_name =
	"$", identifier
	;

system_task_enable =
	system_task_name, [ "(", expression, { ",", expression }, ")" ], ";"
	;

task_enable =
	task_identifier, [ "(", expression, { ",", expression }, ")" ], ";"
	;

par_block =
	"fork", [ ":", block_identifier, { block_item_declaration } ], { statement }, "join"
	;

seq_block =
	"begin", [ ":", block_identifier, { block_item_declaration } ], { statement }, "end"
	;

disable_statement =
	"disable", task_identifier, ";" |
	"disable", event_identifier, ";"
	;

event_trigger =
	"->", event_identifier, ";"
	;

wait_statement =
	"wait", "(", expression, ")", statement_or_null
	;

reg_assignment =
	reg_lvalue, "=", expression
	;

loop_statement =
	"forever", statement |
	"repeat", "(", expression, ")", statement |
	"while", "(", expression, ")", statement |
	"for", "(", reg_assignment, ";", expression, ";", reg_assignment, ")", statement
	;

case_item =
	expression, { ",", expression }, ":", statement_or_null |
	"default", [ ":" ], statement_or_null
	;

case_statement =
	"case", "(", expression, ")", case_item, { case_item }, "endcase" |
	"casez", "(", expression, ")", case_item, { case_item }, "endcase" |
	"casex", "(", expression, ")", case_item, { case_item }, "endcase"
	;

conditional_statement =
	"if", "(", expression, ")", statement_or_null, [ "else", statement_or_null ]
	;

event_expression =
	expression |
	event_identifier |
	"posedge", expression |
	"negedge", expression |
	event_expression, "or", event_expression
	;

event_control =
	"@", event_identifier |
	"@", "(", event_expression, ")"
	;

delay_control =
	"#", delay_value |
	"#", "(", mintypmax_expression, ")"
	;

delay_or_event_control =
	delay_control |
	event_control |
	"repeat", "(", expression, ")", event_controls
	;

procedural_timing_control_statement =
	delay_or_event_control, statement_or_null
	;

procedural_continuous_assignment =
	"assign", reg_assignment, ";" |
	"deassign", reg_lvalue, ";" |
	"force", reg_assignment, ";" |
	"force", net_assignment, ";" |
	"release", reg_lvalue, ";" |
	"release", net_lvalue, ";"
	;

non_blocking_assignment =
	reg_lvalue, "<=", [ delay_or_event_control ], expression
	;

blocking_assignment =
	reg_lvalue, "=", [ delay_or_event_control ], expression
	;

statement_or_null =
	statement | ";"
	;

statement =
	blocking_assignment, ";" |
	non_blocking_assignment, ";" |
	procedural_continuous_assignment, ";" |
	procedural_timing_control_statement |
	conditional_statement |
	case_statement |
	loop_statement |
	wait_statement |
	disable_statement |
	event_trigger |
	seq_block |
	par_block |
	task_enable |
	system_task_enable
	;

always_construct =
	"always", statement
	;

initial_construct =
	"initial", statement
	;

net_assignment =
	net_lvalue, "=", expression
	;

list_of_net_assignments =
	net_assignment, { ",", net_assignment }
	;

continuous_assign =
	"assign", [ drive_strength ], [ delay3 ], list_of_net_assignments, ";"
	;

name_of_udp_instance =
	udp_instance_identifier, [ range ]
	;

udp_instance =
	[ name_of_udp_instance ], "(", output_port_connection, ",", input_port_connection, { ",", input_port_connection, }, ")"
	;

udp_instantiation =
	udp_identifier, [ drive_strength ], [ delay2 ], udp_instance, { ",", udp_instance }, ";"
	;

edge_symbol =
	"r" | "R" | "f" | "F" | "p" | "P" | "n" | "N" | "*"
	;

level_symbol =
	"0" | "1" | "x" | "X" | "?" | "b" | "B"
	;

output_symbol =
	"0" | "1" | "x" | "X"
	;

next_state =
	output_symbol | "-"
	;

current_state =
	level_symbol
	;

edge_indicator =
	"(", level_symbol, level_symbol, ")" |
	edge_symbol
	;

edge_input_list =
	{ level_symbol }, edge_indicator, { level_symbol }
	;

level_input_list =
	level_symbol, { level_symbol }
	;

seq_input_list =
	level_input_list |
	edge_input_list
	;

sequential_entry =
	seq_input_list, ":", current_state, ":", next_state, ";"
	;

init_val =
	"1'b0" | "1'b1" | "1'bx" | "1'bX" | "1'B0" | "1'B1" | "1'Bx" | "1'BX" | "1" | "0"
	;

udp_initial_statement =
	"initial", udp_output_port_identifier, "=", init_val, ";"
	;

sequential_entry =
	[ udp_initial_statement ], "table", sequential_entry, { sequential_entry }, "endtable"
	;

combinational_entry =
	level_input_list, ":", output_symbol, ";"
	;

combinatorial_body =
	"table", combinational_entry, { combinational_entry }, "endtable"
	;

udp_body =
	combinational_body |
	sequential_body
	;

udp_port_declaration =
	output_declaration |
	input_declaration |
	reg_declaration
	;

udp_port_list =
	output_port_identifier, ",", input_port_identifier, { ",", input_port_identifier }
	;

udp_declaration =
	"primitive", udp_identifier, "(", udp_port_list, ")", ";", udp_port_declaration, { udp_declaration }, udp_body, "endprimitive"
	;

named_port_connection =
	".", port_identifier, "(", [ expression ], ")"
	;

ordered_port_connection =
	[ expression ]
	;

list_of_module_connections =
	ordered_port_connection, { ",", ordered_port_connection } |
	named_port_connection, { ",", named_port_connection }
	;

name_of_instance =
	module_instance_identifier, [ range ]
	;

module_instance =
	name_of_instance, "(", [ list_of_module_connections ], ")"
	;

parameter_value_assignment =
	"#", "(", expression, { ",", expression }, ")"
	;

module_instantiation =
	module_identifier, [ parameter_value_assignment ], module_instance, { ",", module_instance }, ";"
	;

pass_switchtype =
	"tran" | "rtran"
	;

pass_en_switchtype =
	"tranif0" | "tranif1" | "rtranif0" | "rtranif1"
	;

n_output_gatetype =
	"buf" | "not"
	;

n_input_gatetype =
	"and" | "nand" | "or" | "nor" | "xor" | "xnor"
	;

mos_switchtype =
	"nmos" | "pmos" | "rnmos" | "rpmos"
	;

enable_gatetype =
	"bufif0" | "bufif1" | "notif0" | "notif1"
	;

cmos_switchtype =
	"cmos" | "rcmos"
	;

pcontrol_terminal =
	scalar_expression
	;

output_terminal =
	terminal_identifier |
	terminal_identifier, "[", constant_expression, "]"
	;

ncontrol_terminal =
	scalar_expression
	;

input_terminal =
	scalar_expression
	;

inout_terminal =
	terminal_identifier |
	terminal_identifier, "[", constant_expression, "]"
	;

enable_terminal =
	scalar_expression
	;

pullup_strength =
	"(", strength0, ",", strength1, ")" |
	"(", strength1, ",", strength0, ")" |
	"(", strength1, ")"
	;

pulldown_strength =
	"(", strength0, ",", strength1, ")" |
	"(", strength1, ",", strength0, ")" |
	"(", strength0, ")"
	;

name_of_gate_instance =
	gate_instance_identifier, [ range ]
	;

pull_gate_instance =
	[ name_of_gate_instance ], "(", output_terminal, ")"
	;

pass_en_switch_instance =
	[ name_of_gate_instance ], "(", inout_terminal, ",", inout_terminal, ",", enable_terminal, ")"
	;

pass_switch_instance =
	[ name_of_gate_instance ], "(", inout_terminal, ",", inout_terminal, ")"
	;

n_output_gate_instance =
	[ name_of_gate_instance ], "(", output_terminal, { ",", output_terminal }, ",", input_terminal, ")"
	;

n_input_gate_instance =
	[ name_of_gate_instance ], "(", output_terminal, ",", input_terminal, { ",", input_terminal }, ")"
	;

mos_switch_instance =
	[ name_of_gate_instance ], "(", output_terminal, ",", input_terminal, ",", enable_terminal, ")"
	;

enable_gate_instance =
	[ name_of_gate_instance ], "(", output_terminal, ",", input_terminal, ",", enable_terminal, ")"
	;

cmos_switch_instance =
	[ name_of_gate_instance ], "(", output_terminal, ",", input_terminal, ",", ncontrol_terminal, ",", pcontrol_terminal, ")"
	;

gate_instantiation =
	cmos_switchtype, [ delay3 ], cmos_switch_instance, { ",", cmos_switch_instance }, ";" |
	enable_gatetype, [ drive_strength ], [ delay3 ], enable_gate_instance, { ",", enable_gate_instance }, ";" |
	mos_switchtype, [ delay3 ], mos_switch_instance, { ",", mos_switch_instance }, ";" |
	n_input_gatetype, [ drive_strength ], [ delay2 ], n_input_gate_instance, { ",", n_input_gate_instance }, ";" |
	n_output_gatetype, [ drive_strength ], [ delay2 ], n_output_gate_instance, { ",", n_output_gate_instance }, ";" |
	pass_en_switchtype, [ delay3 ], pass_en_switch_instance, { ",", pass_en_switch_instance }, ";" |
	pass_switchtype, pass_switch_instance, { ",", pass_switch_instance }, ";" |
	"pulldown", [ pulldown_strength ], pull_gate_instance, { ",", pull_gate_instance }, ";" |
	"pullup", [ pullup_strength ], pull_gate_instance, { ",", pull_gate_instance }, ";"
	;

block_item_declaration =
	parameter_declaration |
	reg_declaration |
	integer_declaration |
	real_declaration |
	time_declaration |
	realtime_declaration |
	event_declaration
	;

task_argument_declaration =
	block_item_declaration |
	output_declaration |
	inout_declaration
	;

task_declaration =
	"task", task_identifier, ";", { task_item_declaration }, statement_or_null, "endtask"
	;

function_item_declaration =
	block_item_declaration |
	input_declaration
	;

range_or_type =
	range | "integer" | "real" | "realtime" | "time"
	;

function_declaration =
	"function", [ range_or_type ], function_identifier, ";", function_item_declaration, { function_item_declaration }, statement, "endfuncion"
	;

net_decl_assignment =
	net_identifier, "=", expression
	;

list_of_net_decl_assignments =
	net_decl_assignment, { ",", net_decl_assignment }
	;

delay_value =
	unsigned_number |
	parameter_identifier |
	constant_mintypmax_expression
	;

delay2 =
	"#", delay_value |
	"#", "(", delay_value, [ ",", delay_value ], ")"
	;

delay3 =
	"#", delay_value |
	"#", "(", delay_value, [ ",", delay_value, [ ",", delay_value ] ], ")"
	;

charge_strength =
	"(", "small", ")" |
	"(", "medium", ")" |
	"(", "large", ")"
	;

strength1 =
	"supply1" | "strong1" | "pull1" | "weak1"
	;

strength0 =
	"supply0" | "strong0" | "pull0" | "weak0"
	;

drive_strength =
	"(", strength0, ",", strength1, ")" |
	"(", strength1, ",", strength0, ")" |
	"(", strength0, ",", "highz1", ")" |
	"(", strength1, ",", "highz0", ")" |
	"(", "highz0", ",", strength1, ")" |
	"(", "highz1", ",", strength0, ")"
	;

list_of_net_identifiers =
	net_identifier, { ",", net_identifier }
	;

net_type =
	"wire" | "tri" | "tri1" | "supply0" | "wand" | "triand" | "tri0" | "supply1" | "wor" | "trior"
	;

net_declaration =
	net_type, [ "vectored" | "scalared" ], [ range ], [ delay3 ], list_of_net_identifiers, ";" |
	"trireg", [ "vectored" | "scalared" ], [ charge_strength ], [ range ], [ delay3 ], list_of_net_identifiers, ";" |
	net_type, [ "vectored" | "scalared" ], [ drive_strength ], [ range ], [ delay3 ], list_of_net_decl_assignments, ";"
	;

range =
	"[", msb_constant_expression, ":", lsb_constant_expression, "]"
	;

register_name =
	register_identifier |
	memory_identifier, "[", upper_limit_constant_expression, ":", lower_limit_constant_expression, "]"
	;

list_of_register_identifiers =
	register_name, { ",", register_name }
	;

list_of_real_identifiers =
	real_identifier, { ",", real_identifier }
	;

event_declaration =
	"event", event_identifier, { ",", event_identifier }, ";"
	;

realtime_declaration =
	"realtime", list_of_real_identifiers, ";"
	;

real_declaration =
	"real", list_of_real_identifiers, ";"
	;

integer_declaration =
	"integer", list_of_register_identifiers, ";"
	;

time_declaration =
	"time", list_of_register_identifiers, ";"
	;

reg_declaration =
	"reg", [ range ], list_of_register_identifiers, ";"
	;

list_of_port_identifiers =
	port_identifier, { ",", port_identifier }
	;

inout_declaration =
	"inout", [ range ], list_of_port_identifiers, ";"
	;

output_declaration =
	"output", [ range ], list_of_port_identifiers, ";"
	;

input_declaration =
	"input", [ range ], list_of_port_identifiers, ";"
	;

param_assignment =
	parameter_identifier, "=", constant_expression
	;

list_of_param_assignments =
	param_assignment, { ",", param_assignment }
	;

parameter_declaration =
	"parameter", list_of_param_assignments, ";"
	;

parameter_override =
	"defparam", list_of_param_assignments, ";"
	;

module_item_declaration =
	parameter_declaration |
	input_declaration |
	output_declaration |
	inout_declaration |
	net_declaration |
	reg_declaration |
	integer_declaration |
	real_declaration |
	time_declaration |
	realtime_declaration |
	event_declaration |
	task_declaration |
	function_declaration
	;

module_item =
	module_item_declaration |
	parameter_override |
	continuous_assign |
	gate_instantiation |
	udp_instantiation |
	module_instantiation |
	specify_block |
	initial_construct |
	always_construct
	;

port_reference =
	port_identifier |
	port_identifier, "[", constant_expression, "]" |
	port_identifier, "[", msb_constant_expression, ":", lsb_constant_expression, "]"
	;

port_expression =
	port_reference |
	"{", port_reference, { ",", port_reference }, "}"
	;

port =
	[ port_expression ] |
	".", port_identifier, "(", [ port_expression ], ")"
	;

list_of_ports =
	"(", port, { ",", port }, ")"
	;

module_keyword =
	"module" | "macromodule"
	;

module_declaration =
	module_keyword, module_identifier, [ list_of_ports ], ";", { module_item }, "endmodule"
	;

description =
	module_declaration |
	udp_declaration
	;

source_text =
	{ description }
	;

(*
	Keywords:
		always
		and
		assign
		begin
		buf
		bufif0
		bufif1
		case
		casex
		casez
		cmos
		deassign
		default
		defparam
		disable
		edge
		else
		end
		endcase
		endfunction
		endmodule
		endprimitive
		endspecify
		endtable
		endtask
		event
		for
		force
		forever
		fork
		function
		highz0
		highz1
		if
		ifnone
		initial
		inout
		input
		integer
		join
		large
		macromodule
		medium
		module
		nand
		negedge
		nmos
		nor
		not
		notif0
		notif1
		or
		output
		parameter
		pmos
		posedge
		primitive
		pull0
		pull1
		pulldown
		pullup
		rcmos
		real
		realtime
		reg
		release
		repeat
		rnmos
		rpmos
		rtran
		rtranif0
		rtranif1
		scalared
		small
		specify
		specparam
		strong0
		strong1
		supply0
		supply1
		table
		task
		time
		tran
		tranif0
		tranif1
		tri
		tri0
		tri1
		triand
		trior
		trireg
		vectored
		wait
		wand
		weak0
		weak1
		while
		wire
		wor
		xnor
		xor
*)
