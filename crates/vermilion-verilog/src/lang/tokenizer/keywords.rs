// SPDX-License-Identifier: BSD-3-Clause

use phf::{phf_map, phf_set};

use crate::{
	SystemVerilogStd, VerilogAmsStd, VerilogStd, VerilogVariant, lang::tokenizer::token::Keyword,
};

/// IEEE 1364-1995 (Verilog 1995) Keyword to [`Keyword`] token map
pub static VERILOG_95_KEYWORD_MAP: phf::Map<&'static str, Keyword> = phf_map! {
	"always" => Keyword::Always,
	"and" => Keyword::And,
	"assign" => Keyword::Assign,
	"begin" => Keyword::Begin,
	"buf" => Keyword::Buf,
	"bufif0" => Keyword::BufIf0,
	"bufif1" => Keyword::BufIf1,
	"case" => Keyword::Case,
	"casex" => Keyword::CaseX,
	"casez" => Keyword::CaseZ,
	"cmos" => Keyword::Cmos,
	"deassign" => Keyword::Deassign,
	"default" => Keyword::Default,
	"defparam" => Keyword::DefParam,
	"disable" => Keyword::Disable,
	"edge" => Keyword::Edge,
	"else" => Keyword::Else,
	"end" => Keyword::End,
	"endcase" => Keyword::EndCase,
	"endfunction" => Keyword::EndFunction,
	"endmodule" => Keyword::EndModule,
	"endprimitive" => Keyword::EndPrimitive,
	"endspecify" => Keyword::EndSpecify,
	"endtable" => Keyword::EndTable,
	"endtask" => Keyword::EndTask,
	"event" => Keyword::Event,
	"for" => Keyword::For,
	"force" => Keyword::Force,
	"forever" => Keyword::Forever,
	"fork" => Keyword::Fork,
	"function" => Keyword::Function,
	"highz0" => Keyword::HighZ0,
	"highz1" => Keyword::HighZ1,
	"if" => Keyword::If,
	"ifnone" => Keyword::IfNone,
	"initial" => Keyword::Initial,
	"inout" => Keyword::InOut,
	"input" => Keyword::Input,
	"integer" => Keyword::Integer,
	"join" => Keyword::Join,
	"large" => Keyword::Large,
	"macromodule" => Keyword::MacroModule,
	"medium" => Keyword::Medium,
	"module" => Keyword::Module,
	"nand" => Keyword::Nand,
	"negedge" => Keyword::NegEdge,
	"nmos" => Keyword::Nmos,
	"nor" => Keyword::Nor,
	"not" => Keyword::Not,
	"notif0" => Keyword::NotIf0,
	"notif1" => Keyword::NotIf1,
	"or" => Keyword::Or,
	"output" => Keyword::Output,
	"parameter" => Keyword::Parameter,
	"pmos" => Keyword::Pmos,
	"posedge" => Keyword::PosEdge,
	"primitive" => Keyword::Primitive,
	"pull0" => Keyword::Pull0,
	"pull1" => Keyword::Pull1,
	"pulldown" => Keyword::Pulldown,
	"pullup" => Keyword::Pullup,
	"rcmos" => Keyword::Rcmos,
	"real" => Keyword::Real,
	"realtime" => Keyword::Realtime,
	"reg" => Keyword::Reg,
	"release" => Keyword::Release,
	"repeat" => Keyword::Repeat,
	"rnmos" => Keyword::Rnmos,
	"rpmos" => Keyword::Rpmos,
	"rtran" => Keyword::Rtran,
	"rtranif0" => Keyword::RtranIf0,
	"rtranif1" => Keyword::RtranIf1,
	"scalared" => Keyword::Scalared,
	"small" => Keyword::Small,
	"specify" => Keyword::Specify,
	"specparam" => Keyword::SpecParam,
	"strong0" => Keyword::Strong0,
	"strong1" => Keyword::Strong1,
	"supply0" => Keyword::Supply0,
	"supply1" => Keyword::Supply1,
	"table" => Keyword::Table,
	"task" => Keyword::Task,
	"time" => Keyword::Time,
	"tran" => Keyword::Tran,
	"tranif0" => Keyword::TranIf0,
	"tranif1" => Keyword::TranIf1,
	"tri" => Keyword::Tri,
	"tri0" => Keyword::Tri0,
	"tri1" => Keyword::Tri1,
	"triand" => Keyword::Triand,
	"trior" => Keyword::Trior,
	"trireg" => Keyword::Trireg,
	"vectored" => Keyword::Vectored,
	"wait" => Keyword::Wait,
	"wand" => Keyword::Wand,
	"weak0" => Keyword::Weak0,
	"weak1" => Keyword::Weak1,
	"while" => Keyword::While,
	"wire" => Keyword::Wire,
	"wor" => Keyword::Wor,
	"xnor" => Keyword::Xnor,
	"xor" => Keyword::Xor,
};

/// IEEE 1364-1995 (Verilog 1995) Keyword set
pub static VERILOG_95_KEYWORD_SET: phf::Set<&'static str> = phf_set! {
	"always",   "edge",         "function",    "negedge",   "pullup",   "specparam", "trior",
	"and",      "else",         "highz0",      "nmos",      "rcmos",    "strong0",   "trireg",
	"assign",   "end",          "highz1",      "nor",       "real",     "strong1",   "vectored",
	"begin",    "endcase",      "if",          "not",       "realtime", "supply0",   "wait",
	"buf",      "endfunction",  "ifnone",      "notif0",    "reg",      "supply1",   "wand",
	"bufif0",   "endmodule",    "initial",     "notif1",    "release",  "table",     "weak0",
	"bufif1",   "endprimitive", "inout",       "or",        "repeat",   "task",      "weak1",
	"case",     "endspecify",   "input",       "output",    "rnmos",    "time",      "while",
	"casex",    "endtable",     "integer",     "parameter", "rpmos",    "tran",      "wire",
	"casez",    "endtask",      "join",        "pmos",      "rtran",    "tranif0",   "wor",
	"cmos",     "event",        "large",       "posedge",   "rtranif0", "tranif1",   "xnor",
	"deassign", "for",          "macromodule", "primitive", "rtranif1", "tri",       "xor",
	"default",  "force",        "medium",      "pull0",     "scalared", "tri0",
	"defparam", "forever",      "module",      "pull1",     "small",    "tri1",
	"disable",  "fork",         "nand",        "pulldown",  "specify",  "triand",
};

/// IEEE 1364-2001 (Verilog 2001) Keyword to [`Keyword`] token map
pub static VERILOG_01_KEYWORD_MAP: phf::Map<&'static str, Keyword> = phf_map! {
	"always" => Keyword::Always,
	"and" => Keyword::And,
	"assign" => Keyword::Assign,
	"automatic" => Keyword::Automatic,
	"begin" => Keyword::Begin,
	"buf" => Keyword::Buf,
	"bufif0" => Keyword::BufIf0,
	"bufif1" => Keyword::BufIf1,
	"case" => Keyword::Case,
	"casex" => Keyword::CaseX,
	"casez" => Keyword::CaseZ,
	"cell" => Keyword::Cell,
	"cmos" => Keyword::Cmos,
	"config" => Keyword::Config,
	"deassign" => Keyword::Deassign,
	"default" => Keyword::Default,
	"defparam" => Keyword::DefParam,
	"design" => Keyword::Design,
	"disable" => Keyword::Disable,
	"edge" => Keyword::Edge,
	"else" => Keyword::Else,
	"end" => Keyword::End,
	"endcase" => Keyword::EndCase,
	"endconfig" => Keyword::EndConfig,
	"endfunction" => Keyword::EndFunction,
	"endgenerate" => Keyword::EndGenerate,
	"endmodule" => Keyword::EndModule,
	"endprimitive" => Keyword::EndPrimitive,
	"endspecify" => Keyword::EndSpecify,
	"endtable" => Keyword::EndTable,
	"endtask" => Keyword::EndTask,
	"event" => Keyword::Event,
	"for" => Keyword::For,
	"force" => Keyword::Force,
	"forever" => Keyword::Forever,
	"fork" => Keyword::Fork,
	"function" => Keyword::Function,
	"generate" => Keyword::Generate,
	"genvar" => Keyword::Genvar,
	"highz0" => Keyword::HighZ0,
	"highz1" => Keyword::HighZ1,
	"if" => Keyword::If,
	"ifnone" => Keyword::IfNone,
	"incdir" => Keyword::IncDir,
	"include" => Keyword::Include,
	"initial" => Keyword::Initial,
	"inout" => Keyword::InOut,
	"input" => Keyword::Input,
	"instance" => Keyword::Instance,
	"integer" => Keyword::Integer,
	"join" => Keyword::Join,
	"large" => Keyword::Large,
	"liblist" => Keyword::LibList,
	"library" => Keyword::Library,
	"localparam" => Keyword::LocalParam,
	"macromodule" => Keyword::MacroModule,
	"medium" => Keyword::Medium,
	"module" => Keyword::Module,
	"nand" => Keyword::Nand,
	"negedge" => Keyword::NegEdge,
	"nmos" => Keyword::Nmos,
	"nor" => Keyword::Nor,
	"noshowcancelled" => Keyword::NoShowCancelled,
	"not" => Keyword::Not,
	"notif0" => Keyword::NotIf0,
	"notif1" => Keyword::NotIf1,
	"or" => Keyword::Or,
	"output" => Keyword::Output,
	"parameter" => Keyword::Parameter,
	"pmos" => Keyword::Pmos,
	"posedge" => Keyword::PosEdge,
	"primitive" => Keyword::Primitive,
	"pull0" => Keyword::Pull0,
	"pull1" => Keyword::Pull1,
	"pulldown" => Keyword::Pulldown,
	"pullup" => Keyword::Pullup,
	"pulsestyle_ondetect" => Keyword::PulseStyleOnDetect,
	"pulsestyle_onevent" => Keyword::PulseStyleOnEvent,
	"rcmos" => Keyword::Rcmos,
	"real" => Keyword::Real,
	"realtime" => Keyword::Realtime,
	"reg" => Keyword::Reg,
	"release" => Keyword::Release,
	"repeat" => Keyword::Repeat,
	"rnmos" => Keyword::Rnmos,
	"rpmos" => Keyword::Rpmos,
	"rtran" => Keyword::Rtran,
	"rtranif0" => Keyword::RtranIf0,
	"rtranif1" => Keyword::RtranIf1,
	"scalared" => Keyword::Scalared,
	"showcancelled" => Keyword::ShowCancelled,
	"signed" => Keyword::Signed,
	"small" => Keyword::Small,
	"specify" => Keyword::Specify,
	"specparam" => Keyword::SpecParam,
	"strong0" => Keyword::Strong0,
	"strong1" => Keyword::Strong1,
	"supply0" => Keyword::Supply0,
	"supply1" => Keyword::Supply1,
	"table" => Keyword::Table,
	"task" => Keyword::Task,
	"time" => Keyword::Time,
	"tran" => Keyword::Tran,
	"tranif0" => Keyword::TranIf0,
	"tranif1" => Keyword::TranIf1,
	"tri" => Keyword::Tri,
	"tri0" => Keyword::Tri0,
	"tri1" => Keyword::Tri1,
	"triand" => Keyword::Triand,
	"trior" => Keyword::Trior,
	"trireg" => Keyword::Trireg,
	"unsigned" => Keyword::Unsigned,
	"use" => Keyword::Use,
	"vectored" => Keyword::Vectored,
	"wait" => Keyword::Wait,
	"wand" => Keyword::Wand,
	"weak0" => Keyword::Weak0,
	"weak1" => Keyword::Weak1,
	"while" => Keyword::While,
	"wire" => Keyword::Wire,
	"wor" => Keyword::Wor,
	"xnor" => Keyword::Xnor,
	"xor" => Keyword::Xor,
};

/// IEEE 1364-2001 (Verilog 2001) Keyword set
pub static VERILOG_01_KEYWORD_SET: phf::Set<&'static str> = phf_set! {
	"always",      "endgenerate",  "join",            "pullup",              "task",
	"and",         "endmodule",    "large",           "pulsestyle_ondetect", "time",
	"assign",      "endprimitive", "liblist",         "pulsestyle_onevent",  "tran",
	"automatic",   "endspecify",   "library",         "rcmos",               "tranif0",
	"begin",       "endtable",     "localparam",      "real",                "tranif1",
	"buf",         "endtask",      "macromodule",     "realtime",            "tri",
	"bufif0",      "event",        "medium",          "reg",                 "tri0",
	"bufif1",      "for",          "module",          "release",             "tri1",
	"case",        "force",        "nand",            "repeat",              "triand",
	"casex",       "forever",      "negedge",         "rnmos",               "trior",
	"casez",       "fork",         "nmos",            "rpmos",               "trireg",
	"cell",        "function",     "nor",             "rtran",               "unsigned",
	"cmos",        "generate",     "noshowcancelled", "rtranif0",            "use",
	"config",      "genvar",       "not",             "rtranif1",            "vectored",
	"deassign",    "highz0",       "notif0",          "scalared",            "wait",
	"default",     "highz1",       "notif1",          "showcancelled",       "wand",
	"defparam",    "if",           "or",              "signed",              "weak0",
	"design",      "ifnone",       "output",          "small",               "weak1",
	"disable",     "incdir",       "parameter",       "specify",             "while",
	"edge",        "include",      "pmos",            "specparam",           "wire",
	"else",        "initial",      "posedge",         "strong0",             "wor",
	"end",         "inout",        "primitive",       "strong1",             "xnor",
	"endcase",     "input",        "pull0",           "supply0",             "xor",
	"endconfig",   "instance",     "pull1",           "supply1",
	"endfunction", "integer",      "pulldown",        "table",
};

/// IEEE 1364-2005 (Verilog 2005) Keyword to [`Keyword`] token map
pub static VERILOG_05_KEYWORD_MAP: phf::Map<&'static str, Keyword> = phf_map! {
	"always" => Keyword::Always,
	"and" => Keyword::And,
	"assign" => Keyword::Assign,
	"automatic" => Keyword::Automatic,
	"begin" => Keyword::Begin,
	"buf" => Keyword::Buf,
	"bufif0" => Keyword::BufIf0,
	"bufif1" => Keyword::BufIf1,
	"case" => Keyword::Case,
	"casex" => Keyword::CaseX,
	"casez" => Keyword::CaseZ,
	"cell" => Keyword::Cell,
	"cmos" => Keyword::Cmos,
	"config" => Keyword::Config,
	"deassign" => Keyword::Deassign,
	"default" => Keyword::Default,
	"defparam" => Keyword::DefParam,
	"design" => Keyword::Design,
	"disable" => Keyword::Disable,
	"edge" => Keyword::Edge,
	"else" => Keyword::Else,
	"end" => Keyword::End,
	"endcase" => Keyword::EndCase,
	"endconfig" => Keyword::EndConfig,
	"endfunction" => Keyword::EndFunction,
	"endgenerate" => Keyword::EndGenerate,
	"endmodule" => Keyword::EndModule,
	"endprimitive" => Keyword::EndPrimitive,
	"endspecify" => Keyword::EndSpecify,
	"endtable" => Keyword::EndTable,
	"endtask" => Keyword::EndTask,
	"event" => Keyword::Event,
	"for" => Keyword::For,
	"force" => Keyword::Force,
	"forever" => Keyword::Forever,
	"fork" => Keyword::Fork,
	"function" => Keyword::Function,
	"generate" => Keyword::Generate,
	"genvar" => Keyword::Genvar,
	"highz0" => Keyword::HighZ0,
	"highz1" => Keyword::HighZ1,
	"if" => Keyword::If,
	"ifnone" => Keyword::IfNone,
	"incdir" => Keyword::IncDir,
	"include" => Keyword::Include,
	"initial" => Keyword::Initial,
	"inout" => Keyword::InOut,
	"input" => Keyword::Input,
	"instance" => Keyword::Instance,
	"integer" => Keyword::Integer,
	"join" => Keyword::Join,
	"large" => Keyword::Large,
	"liblist" => Keyword::LibList,
	"library" => Keyword::Library,
	"localparam" => Keyword::LocalParam,
	"macromodule" => Keyword::MacroModule,
	"medium" => Keyword::Medium,
	"module" => Keyword::Module,
	"nand" => Keyword::Nand,
	"negedge" => Keyword::NegEdge,
	"nmos" => Keyword::Nmos,
	"nor" => Keyword::Nor,
	"noshowcancelled" => Keyword::NoShowCancelled,
	"not" => Keyword::Not,
	"notif0" => Keyword::NotIf0,
	"notif1" => Keyword::NotIf1,
	"or" => Keyword::Or,
	"output" => Keyword::Output,
	"parameter" => Keyword::Parameter,
	"pmos" => Keyword::Pmos,
	"posedge" => Keyword::PosEdge,
	"primitive" => Keyword::Primitive,
	"pull0" => Keyword::Pull0,
	"pull1" => Keyword::Pull1,
	"pulldown" => Keyword::Pulldown,
	"pullup" => Keyword::Pullup,
	"pulsestyle_ondetect" => Keyword::PulseStyleOnDetect,
	"pulsestyle_onevent" => Keyword::PulseStyleOnEvent,
	"rcmos" => Keyword::Rcmos,
	"real" => Keyword::Real,
	"realtime" => Keyword::Realtime,
	"reg" => Keyword::Reg,
	"release" => Keyword::Release,
	"repeat" => Keyword::Repeat,
	"rnmos" => Keyword::Rnmos,
	"rpmos" => Keyword::Rpmos,
	"rtran" => Keyword::Rtran,
	"rtranif0" => Keyword::RtranIf0,
	"rtranif1" => Keyword::RtranIf1,
	"scalared" => Keyword::Scalared,
	"showcancelled" => Keyword::ShowCancelled,
	"signed" => Keyword::Signed,
	"small" => Keyword::Small,
	"specify" => Keyword::Specify,
	"specparam" => Keyword::SpecParam,
	"strong0" => Keyword::Strong0,
	"strong1" => Keyword::Strong1,
	"supply0" => Keyword::Supply0,
	"supply1" => Keyword::Supply1,
	"table" => Keyword::Table,
	"task" => Keyword::Task,
	"time" => Keyword::Time,
	"tran" => Keyword::Tran,
	"tranif0" => Keyword::TranIf0,
	"tranif1" => Keyword::TranIf1,
	"tri" => Keyword::Tri,
	"tri0" => Keyword::Tri0,
	"tri1" => Keyword::Tri1,
	"triand" => Keyword::Triand,
	"trior" => Keyword::Trior,
	"trireg" => Keyword::Trireg,
	"unsigned" => Keyword::Unsigned,
	"use" => Keyword::Use,
	"uwire" => Keyword::Uwire,
	"vectored" => Keyword::Vectored,
	"wait" => Keyword::Wait,
	"wand" => Keyword::Wand,
	"weak0" => Keyword::Weak0,
	"weak1" => Keyword::Weak1,
	"while" => Keyword::While,
	"wire" => Keyword::Wire,
	"wor" => Keyword::Wor,
	"xnor" => Keyword::Xnor,
	"xor" => Keyword::Xor,
};

/// IEEE 1364-2005 (Verilog 2005) Keyword set
pub static VERILOG_05_KEYWORD_SET: phf::Set<&'static str> = phf_set! {
	"always",      "endgenerate",  "join",            "pullup",              "task",
	"and",         "endmodule",    "large",           "pulsestyle_ondetect", "time",
	"assign",      "endprimitive", "liblist",         "pulsestyle_onevent",  "tran",
	"automatic",   "endspecify",   "library",         "rcmos",               "tranif0",
	"begin",       "endtable",     "localparam",      "real",                "tranif1",
	"buf",         "endtask",      "macromodule",     "realtime",            "tri",
	"bufif0",      "event",        "medium",          "reg",                 "tri0",
	"bufif1",      "for",          "module",          "release",             "tri1",
	"case",        "force",        "nand",            "repeat",              "triand",
	"casex",       "forever",      "negedge",         "rnmos",               "trior",
	"casez",       "fork",         "nmos",            "rpmos",               "trireg",
	"cell",        "function",     "nor",             "rtran",               "unsigned",
	"cmos",        "generate",     "noshowcancelled", "rtranif0",            "use",
	"config",      "genvar",       "not",             "rtranif1",            "uwire",
	"deassign",    "highz0",       "notif0",          "scalared",            "vectored",
	"default",     "highz1",       "notif1",          "showcancelled",       "wait",
	"defparam",    "if",           "or",              "signed",              "wand",
	"design",      "ifnone",       "output",          "small",               "weak0",
	"disable",     "incdir",       "parameter",       "specify",             "weak1",
	"edge",        "include",      "pmos",            "specparam",           "while",
	"else",        "initial",      "posedge",         "strong0",             "wire",
	"end",         "inout",        "primitive",       "strong1",             "wor",
	"endcase",     "input",        "pull0",           "supply0",             "xnor",
	"endconfig",   "instance",     "pull1",           "supply1",             "xor",
	"endfunction", "integer",      "pulldown",        "table",
};

/// IEEE 1800-2005 (SystemVerilog 2005) Keyword to [`Keyword`] token map
pub static SYSTEM_VERILOG_05_KEYWORD_MAP: phf::Map<&'static str, Keyword> = phf_map! {
	"alias" => Keyword::Alias,
	"always_comb" => Keyword::AlwaysComb,
	"always_ff" => Keyword::AlwaysFF,
	"always_latch" => Keyword::AlwaysLatch,
	"always" => Keyword::Always,
	"and" => Keyword::And,
	"assert" => Keyword::Assert,
	"assign" => Keyword::Assign,
	"assume" => Keyword::Assume,
	"automatic" => Keyword::Automatic,
	"before" => Keyword::Before,
	"begin" => Keyword::Begin,
	"bind" => Keyword::Bind,
	"bins" => Keyword::Bins,
	"binsof" => Keyword::BinsOf,
	"bit" => Keyword::Bit,
	"break" => Keyword::Break,
	"buf" => Keyword::Buf,
	"bufif0" => Keyword::BufIf0,
	"bufif1" => Keyword::BufIf1,
	"byte" => Keyword::Byte,
	"case" => Keyword::Case,
	"casex" => Keyword::CaseX,
	"casez" => Keyword::CaseZ,
	"cell" => Keyword::Cell,
	"chandle" => Keyword::CHandle,
	"class" => Keyword::Class,
	"clocking" => Keyword::Clocking,
	"cmos" => Keyword::Cmos,
	"config" => Keyword::Config,
	"const" => Keyword::Const,
	"constraint" => Keyword::Constraint,
	"context" => Keyword::Context,
	"continue" => Keyword::Continue,
	"cover" => Keyword::Cover,
	"covergroup" => Keyword::CoverGroup,
	"coverpoint" => Keyword::CoverPoint,
	"cross" => Keyword::Cross,
	"deassign" => Keyword::Deassign,
	"default" => Keyword::Default,
	"defparam" => Keyword::DefParam,
	"design" => Keyword::Design,
	"disable" => Keyword::Disable,
	"dist" => Keyword::Dist,
	"do" => Keyword::Do,
	"edge" => Keyword::Edge,
	"else" => Keyword::Else,
	"end" => Keyword::End,
	"endcase" => Keyword::EndCase,
	"endclass" => Keyword::EndClass,
	"endclocking" => Keyword::EndClocking,
	"endconfig" => Keyword::EndConfig,
	"endfunction" => Keyword::EndFunction,
	"endgenerate" => Keyword::EndGenerate,
	"endgroup" => Keyword::EndGroup,
	"endinterface" => Keyword::EndInterface,
	"endmodule" => Keyword::EndModule,
	"endpackage" => Keyword::EndPackage,
	"endprimitive" => Keyword::EndPrimitive,
	"endprogram" => Keyword::EndProgram,
	"endproperty" => Keyword::EndProperty,
	"endsequence" => Keyword::EndSequence,
	"endspecify" => Keyword::EndSpecify,
	"endtable" => Keyword::EndTable,
	"endtask" => Keyword::EndTask,
	"enum" => Keyword::Enum,
	"event" => Keyword::Event,
	"expect" => Keyword::Expect,
	"export" => Keyword::Export,
	"extends" => Keyword::Extends,
	"extern" => Keyword::Extern,
	"final" => Keyword::Final,
	"first_match" => Keyword::FirstMatch,
	"for" => Keyword::For,
	"force" => Keyword::Force,
	"foreach" => Keyword::ForEach,
	"forever" => Keyword::Forever,
	"fork" => Keyword::Fork,
	"forkjoin" => Keyword::ForkJoin,
	"function" => Keyword::Function,
	"generate" => Keyword::Generate,
	"genvar" => Keyword::Genvar,
	"highz0" => Keyword::HighZ0,
	"highz1" => Keyword::HighZ1,
	"if" => Keyword::If,
	"iff" => Keyword::Iff,
	"ifnone" => Keyword::IfNone,
	"ignore_bins" => Keyword::IgnoreBins,
	"illegal_bins" => Keyword::IllegalBins,
	"import" => Keyword::Import,
	"incdir" => Keyword::IncDir,
	"include" => Keyword::Include,
	"initial" => Keyword::Initial,
	"inout" => Keyword::InOut,
	"input" => Keyword::Input,
	"inside" => Keyword::Inside,
	"instance" => Keyword::Instance,
	"int" => Keyword::Int,
	"integer" => Keyword::Integer,
	"interface" => Keyword::Interface,
	"intersect" => Keyword::Intersect,
	"join_any" => Keyword::JoinAny,
	"join_none" => Keyword::JoinNone,
	"join" => Keyword::Join,
	"large" => Keyword::Large,
	"liblist" => Keyword::LibList,
	"library" => Keyword::Library,
	"local" => Keyword::Local,
	"localparam" => Keyword::LocalParam,
	"logic" => Keyword::Logic,
	"longint" => Keyword::LongInt,
	"macromodule" => Keyword::MacroModule,
	"matches" => Keyword::Matches,
	"medium" => Keyword::Medium,
	"modport" => Keyword::ModPort,
	"module" => Keyword::Module,
	"nand" => Keyword::Nand,
	"negedge" => Keyword::NegEdge,
	"new" => Keyword::New,
	"nmos" => Keyword::Nmos,
	"nor" => Keyword::Nor,
	"noshowcancelled" => Keyword::NoShowCancelled,
	"not" => Keyword::Not,
	"notif0" => Keyword::NotIf0,
	"notif1" => Keyword::NotIf1,
	"null" => Keyword::Null,
	"or" => Keyword::Or,
	"output" => Keyword::Output,
	"package" => Keyword::Package,
	"packed" => Keyword::Packed,
	"parameter" => Keyword::Parameter,
	"pmos" => Keyword::Pmos,
	"posedge" => Keyword::PosEdge,
	"primitive" => Keyword::Primitive,
	"priority" => Keyword::Priority,
	"program" => Keyword::Program,
	"property" => Keyword::Property,
	"protected" => Keyword::Protected,
	"pull0" => Keyword::Pull0,
	"pull1" => Keyword::Pull1,
	"pulldown" => Keyword::Pulldown,
	"pullup" => Keyword::Pullup,
	"pulsestyle_ondetect" => Keyword::PulseStyleOnDetect,
	"pulsestyle_onevent" => Keyword::PulseStyleOnEvent,
	"pure" => Keyword::Pure,
	"rand" => Keyword::Rand,
	"randc" => Keyword::RandC,
	"randcase" => Keyword::RandCase,
	"randsequence" => Keyword::RandSequence,
	"rcmos" => Keyword::Rcmos,
	"real" => Keyword::Real,
	"realtime" => Keyword::Realtime,
	"ref" => Keyword::Ref,
	"reg" => Keyword::Reg,
	"release" => Keyword::Release,
	"repeat" => Keyword::Repeat,
	"return" => Keyword::Return,
	"rnmos" => Keyword::Rnmos,
	"rpmos" => Keyword::Rpmos,
	"rtran" => Keyword::Rtran,
	"rtranif0" => Keyword::RtranIf0,
	"rtranif1" => Keyword::RtranIf1,
	"scalared" => Keyword::Scalared,
	"sequence" => Keyword::Sequence,
	"shortint" => Keyword::ShortInt,
	"shortreal" => Keyword::ShortReal,
	"showcancelled" => Keyword::ShowCancelled,
	"signed" => Keyword::Signed,
	"small" => Keyword::Small,
	"solve" => Keyword::Solve,
	"specify" => Keyword::Specify,
	"specparam" => Keyword::SpecParam,
	"static" => Keyword::Static,
	"string" => Keyword::String,
	"strong0" => Keyword::Strong0,
	"strong1" => Keyword::Strong1,
	"struct" => Keyword::Struct,
	"super" => Keyword::Super,
	"supply0" => Keyword::Supply0,
	"supply1" => Keyword::Supply1,
	"table" => Keyword::Table,
	"tagged" => Keyword::Tagged,
	"task" => Keyword::Task,
	"this" => Keyword::This,
	"throughout" => Keyword::Throughout,
	"time" => Keyword::Time,
	"timeprecision" => Keyword::TimePrecision,
	"timeunit" => Keyword::TimeUnit,
	"tran" => Keyword::Tran,
	"tranif0" => Keyword::TranIf0,
	"tranif1" => Keyword::TranIf1,
	"tri" => Keyword::Tri,
	"tri0" => Keyword::Tri0,
	"tri1" => Keyword::Tri1,
	"triand" => Keyword::Triand,
	"trior" => Keyword::Trior,
	"trireg" => Keyword::Trireg,
	"type" => Keyword::Type,
	"typedef" => Keyword::TypeDef,
	"union" => Keyword::Union,
	"unique" => Keyword::Unique,
	"unsigned" => Keyword::Unsigned,
	"use" => Keyword::Use,
	"uwire" => Keyword::Uwire,
	"var" => Keyword::Var,
	"vectored" => Keyword::Vectored,
	"virtual" => Keyword::Virtual,
	"void" => Keyword::Void,
	"wait_order" => Keyword::WaitOrder,
	"wait" => Keyword::Wait,
	"wand" => Keyword::Wand,
	"weak0" => Keyword::Weak0,
	"weak1" => Keyword::Weak1,
	"while" => Keyword::While,
	"wildcard" => Keyword::Wildcard,
	"wire" => Keyword::Wire,
	"with" => Keyword::With,
	"within" => Keyword::Within,
	"wor" => Keyword::Wor,
	"xnor" => Keyword::Xnor,
	"xor" => Keyword::Xor,
};

/// IEEE 1800-2005 (SystemVerilog 2005) Keyword set
pub static SYSTEM_VERILOG_05_KEYWORD_SET: phf::Set<&'static str> = phf_set! {
	"alias",        "edge",         "incdir",          "program",             "table",
	"always_comb",  "else",         "include",         "property",            "tagged",
	"always_ff",    "end",          "initial",         "protected",           "task",
	"always_latch", "endcase",      "inout",           "pull0",               "this",
	"always",       "endclass",     "input",           "pull1",               "throughout",
	"and",          "endclocking",  "inside",          "pulldown",            "time",
	"assert",       "endconfig",    "instance",        "pullup",              "timeprecision",
	"assign",       "endfunction",  "int",             "pulsestyle_ondetect", "timeunit",
	"assume",       "endgenerate",  "integer",         "pulsestyle_onevent",  "tran",
	"automatic",    "endgroup",     "interface",       "pure",                "tranif0",
	"before",       "endinterface", "intersect",       "rand",                "tranif1",
	"begin",        "endmodule",    "join_any",        "randc",               "tri",
	"bind",         "endpackage",   "join_none",       "randcase",            "tri0",
	"bins",         "endprimitive", "join",            "randsequence",        "tri1",
	"binsof",       "endprogram",   "large",           "rcmos",               "triand",
	"bit",          "endproperty",  "liblist",         "real",                "trior",
	"break",        "endsequence",  "library",         "realtime",            "trireg",
	"buf",          "endspecify",   "local",           "ref",                 "type",
	"bufif0",       "endtable",     "localparam",      "reg",                 "typedef",
	"bufif1",       "endtask",      "logic",           "release",             "union",
	"byte",         "enum",         "longint",         "repeat",              "unique",
	"case",         "event",        "macromodule",     "return",              "unsigned",
	"casex",        "expect",       "matches",         "rnmos",               "use",
	"casez",        "export",       "medium",          "rpmos",               "uwire",
	"cell",         "extends",      "modport",         "rtran",               "var",
	"chandle",      "extern",       "module",          "rtranif0",            "vectored",
	"class",        "final",        "nand",            "rtranif1",            "virtual",
	"clocking",     "first_match",  "negedge",         "scalared",            "void",
	"cmos",         "for",          "new",             "sequence",            "wait_order",
	"config",       "force",        "nmos",            "shortint",            "wait",
	"const",        "foreach",      "nor",             "shortreal",           "wand",
	"constraint",   "forever",      "noshowcancelled", "showcancelled",       "weak0",
	"context",      "fork",         "not",             "signed",              "weak1",
	"continue",     "forkjoin",     "notif0",          "small",               "while",
	"cover",        "function",     "notif1",          "solve",               "wildcard",
	"covergroup",   "generate",     "null",            "specify",             "wire",
	"coverpoint",   "genvar",       "or",              "specparam",           "with",
	"cross",        "highz0",       "output",          "static",              "within",
	"deassign",     "highz1",       "package",         "string",              "wor",
	"default",      "if",           "packed",          "strong0",             "xnor",
	"defparam",     "iff",          "parameter",       "strong1",             "xor",
	"design",       "ifnone",       "pmos",            "struct",
	"disable",      "ignore_bins",  "posedge",         "super",
	"dist",         "illegal_bins", "primitive",       "supply0",
	"do",           "import",       "priority",        "supply1",
};

/// IEEE 1800-2009 (SystemVerilog 2009) Keyword to [`Keyword`] token map
pub static SYSTEM_VERILOG_09_KEYWORD_MAP: phf::Map<&'static str, Keyword> = phf_map! {
	"accept_on" => Keyword::AcceptOn,
	"alias" => Keyword::Alias,
	"always_comb" => Keyword::AlwaysComb,
	"always_ff" => Keyword::AlwaysFF,
	"always_latch" => Keyword::AlwaysLatch,
	"always" => Keyword::Always,
	"and" => Keyword::And,
	"assert" => Keyword::Assert,
	"assign" => Keyword::Assign,
	"assume" => Keyword::Assume,
	"automatic" => Keyword::Automatic,
	"before" => Keyword::Before,
	"begin" => Keyword::Begin,
	"bind" => Keyword::Bind,
	"bins" => Keyword::Bins,
	"binsof" => Keyword::BinsOf,
	"bit" => Keyword::Bit,
	"break" => Keyword::Break,
	"buf" => Keyword::Buf,
	"bufif0" => Keyword::BufIf0,
	"bufif1" => Keyword::BufIf1,
	"byte" => Keyword::Byte,
	"case" => Keyword::Case,
	"casex" => Keyword::CaseX,
	"casez" => Keyword::CaseZ,
	"cell" => Keyword::Cell,
	"chandle" => Keyword::CHandle,
	"checker" => Keyword::Checker,
	"class" => Keyword::Class,
	"clocking" => Keyword::Clocking,
	"cmos" => Keyword::Cmos,
	"config" => Keyword::Config,
	"const" => Keyword::Const,
	"constraint" => Keyword::Constraint,
	"context" => Keyword::Context,
	"continue" => Keyword::Continue,
	"cover" => Keyword::Cover,
	"covergroup" => Keyword::CoverGroup,
	"coverpoint" => Keyword::CoverPoint,
	"cross" => Keyword::Cross,
	"deassign" => Keyword::Deassign,
	"default" => Keyword::Default,
	"defparam" => Keyword::DefParam,
	"design" => Keyword::Design,
	"disable" => Keyword::Disable,
	"dist" => Keyword::Dist,
	"do" => Keyword::Do,
	"edge" => Keyword::Edge,
	"else" => Keyword::Else,
	"end" => Keyword::End,
	"endcase" => Keyword::EndCase,
	"endchecker" => Keyword::EndChecker,
	"endclass" => Keyword::EndClass,
	"endclocking" => Keyword::EndClocking,
	"endconfig" => Keyword::EndConfig,
	"endfunction" => Keyword::EndFunction,
	"endgenerate" => Keyword::EndGenerate,
	"endgroup" => Keyword::EndGroup,
	"endinterface" => Keyword::EndInterface,
	"endmodule" => Keyword::EndModule,
	"endpackage" => Keyword::EndPackage,
	"endprimitive" => Keyword::EndPrimitive,
	"endprogram" => Keyword::EndProgram,
	"endproperty" => Keyword::EndProperty,
	"endsequence" => Keyword::EndSequence,
	"endspecify" => Keyword::EndSpecify,
	"endtable" => Keyword::EndTable,
	"endtask" => Keyword::EndTask,
	"enum" => Keyword::Enum,
	"event" => Keyword::Event,
	"eventually" => Keyword::Eventually,
	"expect" => Keyword::Expect,
	"export" => Keyword::Export,
	"extends" => Keyword::Extends,
	"extern" => Keyword::Extern,
	"final" => Keyword::Final,
	"first_match" => Keyword::FirstMatch,
	"for" => Keyword::For,
	"force" => Keyword::Force,
	"foreach" => Keyword::ForEach,
	"forever" => Keyword::Forever,
	"fork" => Keyword::Fork,
	"forkjoin" => Keyword::ForkJoin,
	"function" => Keyword::Function,
	"generate" => Keyword::Generate,
	"genvar" => Keyword::Genvar,
	"global" => Keyword::Global,
	"highz0" => Keyword::HighZ0,
	"highz1" => Keyword::HighZ1,
	"if" => Keyword::If,
	"iff" => Keyword::Iff,
	"ifnone" => Keyword::IfNone,
	"ignore_bins" => Keyword::IgnoreBins,
	"illegal_bins" => Keyword::IllegalBins,
	"implies" => Keyword::Implies,
	"import" => Keyword::Import,
	"incdir" => Keyword::IncDir,
	"include" => Keyword::Include,
	"initial" => Keyword::Initial,
	"inout" => Keyword::InOut,
	"input" => Keyword::Input,
	"inside" => Keyword::Inside,
	"instance" => Keyword::Instance,
	"int" => Keyword::Int,
	"integer" => Keyword::Integer,
	"interface" => Keyword::Interface,
	"intersect" => Keyword::Intersect,
	"join_any" => Keyword::JoinAny,
	"join_none" => Keyword::JoinNone,
	"join" => Keyword::Join,
	"large" => Keyword::Large,
	"let" => Keyword::Let,
	"liblist" => Keyword::LibList,
	"library" => Keyword::Library,
	"local" => Keyword::Local,
	"localparam" => Keyword::LocalParam,
	"logic" => Keyword::Logic,
	"longint" => Keyword::LongInt,
	"macromodule" => Keyword::MacroModule,
	"matches" => Keyword::Matches,
	"medium" => Keyword::Medium,
	"modport" => Keyword::ModPort,
	"module" => Keyword::Module,
	"nand" => Keyword::Nand,
	"negedge" => Keyword::NegEdge,
	"new" => Keyword::New,
	"nexttime" => Keyword::NextTime,
	"nmos" => Keyword::Nmos,
	"nor" => Keyword::Nor,
	"noshowcancelled" => Keyword::NoShowCancelled,
	"not" => Keyword::Not,
	"notif0" => Keyword::NotIf0,
	"notif1" => Keyword::NotIf1,
	"null" => Keyword::Null,
	"or" => Keyword::Or,
	"output" => Keyword::Output,
	"package" => Keyword::Package,
	"packed" => Keyword::Packed,
	"parameter" => Keyword::Parameter,
	"pmos" => Keyword::Pmos,
	"posedge" => Keyword::PosEdge,
	"primitive" => Keyword::Primitive,
	"priority" => Keyword::Priority,
	"program" => Keyword::Program,
	"property" => Keyword::Property,
	"protected" => Keyword::Protected,
	"pull0" => Keyword::Pull0,
	"pull1" => Keyword::Pull1,
	"pulldown" => Keyword::Pulldown,
	"pullup" => Keyword::Pullup,
	"pulsestyle_ondetect" => Keyword::PulseStyleOnDetect,
	"pulsestyle_onevent" => Keyword::PulseStyleOnEvent,
	"pure" => Keyword::Pure,
	"rand" => Keyword::Rand,
	"randc" => Keyword::RandC,
	"randcase" => Keyword::RandCase,
	"randsequence" => Keyword::RandSequence,
	"rcmos" => Keyword::Rcmos,
	"real" => Keyword::Real,
	"realtime" => Keyword::Realtime,
	"ref" => Keyword::Ref,
	"reg" => Keyword::Reg,
	"reject_on" => Keyword::RejectOn,
	"release" => Keyword::Release,
	"repeat" => Keyword::Repeat,
	"restrict" => Keyword::Restrict,
	"return" => Keyword::Return,
	"rnmos" => Keyword::Rnmos,
	"rpmos" => Keyword::Rpmos,
	"rtran" => Keyword::Rtran,
	"rtranif0" => Keyword::RtranIf0,
	"rtranif1" => Keyword::RtranIf1,
	"s_always" => Keyword::SAlways,
	"s_eventually" => Keyword::SEventually,
	"s_nexttime" => Keyword::SNextTime,
	"s_until_with" => Keyword::SUntilWith,
	"s_until" => Keyword::SUntil,
	"scalared" => Keyword::Scalared,
	"sequence" => Keyword::Sequence,
	"shortint" => Keyword::ShortInt,
	"shortreal" => Keyword::ShortReal,
	"showcancelled" => Keyword::ShowCancelled,
	"signed" => Keyword::Signed,
	"small" => Keyword::Small,
	"solve" => Keyword::Solve,
	"specify" => Keyword::Specify,
	"specparam" => Keyword::SpecParam,
	"static" => Keyword::Static,
	"string" => Keyword::String,
	"strong" => Keyword::Strong,
	"strong0" => Keyword::Strong0,
	"strong1" => Keyword::Strong1,
	"struct" => Keyword::Struct,
	"super" => Keyword::Super,
	"supply0" => Keyword::Supply0,
	"supply1" => Keyword::Supply1,
	"sync_accpet_on" => Keyword::SyncAcceptOn,
	"sync_reject_on" => Keyword::SyncRejectOn,
	"table" => Keyword::Table,
	"tagged" => Keyword::Tagged,
	"task" => Keyword::Task,
	"this" => Keyword::This,
	"throughout" => Keyword::Throughout,
	"time" => Keyword::Time,
	"timeprecision" => Keyword::TimePrecision,
	"timeunit" => Keyword::TimeUnit,
	"tran" => Keyword::Tran,
	"tranif0" => Keyword::TranIf0,
	"tranif1" => Keyword::TranIf1,
	"tri" => Keyword::Tri,
	"tri0" => Keyword::Tri0,
	"tri1" => Keyword::Tri1,
	"triand" => Keyword::Triand,
	"trior" => Keyword::Trior,
	"trireg" => Keyword::Trireg,
	"type" => Keyword::Type,
	"typedef" => Keyword::TypeDef,
	"union" => Keyword::Union,
	"unique" => Keyword::Unique,
	"unique0" => Keyword::Unique0,
	"unsigned" => Keyword::Unsigned,
	"until_with" => Keyword::UntilWith,
	"until" => Keyword::Until,
	"untyped" => Keyword::Untyped,
	"use" => Keyword::Use,
	"uwire" => Keyword::Uwire,
	"var" => Keyword::Var,
	"vectored" => Keyword::Vectored,
	"virtual" => Keyword::Virtual,
	"void" => Keyword::Void,
	"wait_order" => Keyword::WaitOrder,
	"wait" => Keyword::Wait,
	"wand" => Keyword::Wand,
	"weak" => Keyword::Weak,
	"weak0" => Keyword::Weak0,
	"weak1" => Keyword::Weak1,
	"while" => Keyword::While,
	"wildcard" => Keyword::Wildcard,
	"wire" => Keyword::Wire,
	"with" => Keyword::With,
	"within" => Keyword::Within,
	"wor" => Keyword::Wor,
	"xnor" => Keyword::Xnor,
	"xor" => Keyword::Xor,
};

/// IEEE 1800-2009 (SystemVerilog 2009) Keyword set
pub static SYSTEM_VERILOG_09_KEYWORD_SET: phf::Set<&'static str> = phf_set! {
	"accept_on",    "end",          "initial",         "pull1",               "sync_accpet_on",
	"alias",        "endcase",      "inout",           "pulldown",            "sync_reject_on",
	"always_comb",  "endchecker",   "input",           "pullup",              "table",
	"always_ff",    "endclass",     "inside",          "pulsestyle_ondetect", "tagged",
	"always_latch", "endclocking",  "instance",        "pulsestyle_onevent",  "task",
	"always",       "endconfig",    "int",             "pure",                "this",
	"and",          "endfunction",  "integer",         "rand",                "throughout",
	"assert",       "endgenerate",  "interface",       "randc",               "time",
	"assign",       "endgroup",     "intersect",       "randcase",            "timeprecision",
	"assume",       "endinterface", "join_any",        "randsequence",        "timeunit",
	"automatic",    "endmodule",    "join_none",       "rcmos",               "tran",
	"before",       "endpackage",   "join",            "real",                "tranif0",
	"begin",        "endprimitive", "large",           "realtime",            "tranif1",
	"bind",         "endprogram",   "let",             "ref",                 "tri",
	"bins",         "endproperty",  "liblist",         "reg",                 "tri0",
	"binsof",       "endsequence",  "library",         "reject_on",           "tri1",
	"bit",          "endspecify",   "local",           "release",             "triand",
	"break",        "endtable",     "localparam",      "repeat",              "trior",
	"buf",          "endtask",      "logic",           "restrict",            "trireg",
	"bufif0",       "enum",         "longint",         "return",              "type",
	"bufif1",       "event",        "macromodule",     "rnmos",               "typedef",
	"byte",         "eventually",   "matches",         "rpmos",               "union",
	"case",         "expect",       "medium",          "rtran",               "unique",
	"casex",        "export",       "modport",         "rtranif0",            "unique0",
	"casez",        "extends",      "module",          "rtranif1",            "unsigned",
	"cell",         "extern",       "nand",            "s_always",            "until_with",
	"chandle",      "final",        "negedge",         "s_eventually",        "until",
	"checker",      "first_match",  "new",             "s_nexttime",          "untyped",
	"class",        "for",          "nexttime",        "s_until_with",        "use",
	"clocking",     "force",        "nmos",            "s_until",             "uwire",
	"cmos",         "foreach",      "nor",             "scalared",            "var",
	"config",       "forever",      "noshowcancelled", "sequence",            "vectored",
	"const",        "fork",         "not",             "shortint",            "virtual",
	"constraint",   "forkjoin",     "notif0",          "shortreal",           "void",
	"context",      "function",     "notif1",          "showcancelled",       "wait_order",
	"continue",     "generate",     "null",            "signed",              "wait",
	"cover",        "genvar",       "or",              "small",               "wand",
	"covergroup",   "global",       "output",          "solve",               "weak",
	"coverpoint",   "highz0",       "package",         "specify",             "weak0",
	"cross",        "highz1",       "packed",          "specparam",           "weak1",
	"deassign",     "if",           "parameter",       "static",              "while",
	"default",      "iff",          "pmos",            "string",              "wildcard",
	"defparam",     "ifnone",       "posedge",         "strong",              "wire",
	"design",       "ignore_bins",  "primitive",       "strong0",             "with",
	"disable",      "illegal_bins", "priority",        "strong1",             "within",
	"dist",         "implies",      "program",         "struct",              "wor",
	"do",           "import",       "property",        "super",               "xnor",
	"edge",         "incdir",       "protected",       "supply0",             "xor",
	"else",         "include",      "pull0",           "supply1",
};

/// IEEE 1800-2012 (SystemVerilog 2012) Keyword to [`Keyword`] token map
pub static SYSTEM_VERILOG_12_KEYWORD_MAP: phf::Map<&'static str, Keyword> = phf_map! {
	"accept_on" => Keyword::AcceptOn,
	"alias" => Keyword::Alias,
	"always_comb" => Keyword::AlwaysComb,
	"always_ff" => Keyword::AlwaysFF,
	"always_latch" => Keyword::AlwaysLatch,
	"always" => Keyword::Always,
	"and" => Keyword::And,
	"assert" => Keyword::Assert,
	"assign" => Keyword::Assign,
	"assume" => Keyword::Assume,
	"automatic" => Keyword::Automatic,
	"before" => Keyword::Before,
	"begin" => Keyword::Begin,
	"bind" => Keyword::Bind,
	"bins" => Keyword::Bins,
	"binsof" => Keyword::BinsOf,
	"bit" => Keyword::Bit,
	"break" => Keyword::Break,
	"buf" => Keyword::Buf,
	"bufif0" => Keyword::BufIf0,
	"bufif1" => Keyword::BufIf1,
	"byte" => Keyword::Byte,
	"case" => Keyword::Case,
	"casex" => Keyword::CaseX,
	"casez" => Keyword::CaseZ,
	"cell" => Keyword::Cell,
	"chandle" => Keyword::CHandle,
	"checker" => Keyword::Checker,
	"class" => Keyword::Class,
	"clocking" => Keyword::Clocking,
	"cmos" => Keyword::Cmos,
	"config" => Keyword::Config,
	"const" => Keyword::Const,
	"constraint" => Keyword::Constraint,
	"context" => Keyword::Context,
	"continue" => Keyword::Continue,
	"cover" => Keyword::Cover,
	"covergroup" => Keyword::CoverGroup,
	"coverpoint" => Keyword::CoverPoint,
	"cross" => Keyword::Cross,
	"deassign" => Keyword::Deassign,
	"default" => Keyword::Default,
	"defparam" => Keyword::DefParam,
	"design" => Keyword::Design,
	"disable" => Keyword::Disable,
	"dist" => Keyword::Dist,
	"do" => Keyword::Do,
	"edge" => Keyword::Edge,
	"else" => Keyword::Else,
	"end" => Keyword::End,
	"endcase" => Keyword::EndCase,
	"endchecker" => Keyword::EndChecker,
	"endclass" => Keyword::EndClass,
	"endclocking" => Keyword::EndClocking,
	"endconfig" => Keyword::EndConfig,
	"endfunction" => Keyword::EndFunction,
	"endgenerate" => Keyword::EndGenerate,
	"endgroup" => Keyword::EndGroup,
	"endinterface" => Keyword::EndInterface,
	"endmodule" => Keyword::EndModule,
	"endpackage" => Keyword::EndPackage,
	"endprimitive" => Keyword::EndPrimitive,
	"endprogram" => Keyword::EndProgram,
	"endproperty" => Keyword::EndProperty,
	"endsequence" => Keyword::EndSequence,
	"endspecify" => Keyword::EndSpecify,
	"endtable" => Keyword::EndTable,
	"endtask" => Keyword::EndTask,
	"enum" => Keyword::Enum,
	"event" => Keyword::Event,
	"eventually" => Keyword::Eventually,
	"expect" => Keyword::Expect,
	"export" => Keyword::Export,
	"extends" => Keyword::Extends,
	"extern" => Keyword::Extern,
	"final" => Keyword::Final,
	"first_match" => Keyword::FirstMatch,
	"for" => Keyword::For,
	"force" => Keyword::Force,
	"foreach" => Keyword::ForEach,
	"forever" => Keyword::Forever,
	"fork" => Keyword::Fork,
	"forkjoin" => Keyword::ForkJoin,
	"function" => Keyword::Function,
	"generate" => Keyword::Generate,
	"genvar" => Keyword::Genvar,
	"global" => Keyword::Global,
	"highz0" => Keyword::HighZ0,
	"highz1" => Keyword::HighZ1,
	"if" => Keyword::If,
	"iff" => Keyword::Iff,
	"ifnone" => Keyword::IfNone,
	"ignore_bins" => Keyword::IgnoreBins,
	"illegal_bins" => Keyword::IllegalBins,
	"implements" => Keyword::Implements,
	"implies" => Keyword::Implies,
	"import" => Keyword::Import,
	"incdir" => Keyword::IncDir,
	"include" => Keyword::Include,
	"initial" => Keyword::Initial,
	"inout" => Keyword::InOut,
	"input" => Keyword::Input,
	"inside" => Keyword::Inside,
	"instance" => Keyword::Instance,
	"int" => Keyword::Int,
	"integer" => Keyword::Integer,
	"interconnect" => Keyword::Interconnect,
	"interface" => Keyword::Interface,
	"intersect" => Keyword::Intersect,
	"join_any" => Keyword::JoinAny,
	"join_none" => Keyword::JoinNone,
	"join" => Keyword::Join,
	"large" => Keyword::Large,
	"let" => Keyword::Let,
	"liblist" => Keyword::LibList,
	"library" => Keyword::Library,
	"local" => Keyword::Local,
	"localparam" => Keyword::LocalParam,
	"logic" => Keyword::Logic,
	"longint" => Keyword::LongInt,
	"macromodule" => Keyword::MacroModule,
	"matches" => Keyword::Matches,
	"medium" => Keyword::Medium,
	"modport" => Keyword::ModPort,
	"module" => Keyword::Module,
	"nand" => Keyword::Nand,
	"negedge" => Keyword::NegEdge,
	"nettype" => Keyword::NetType,
	"new" => Keyword::New,
	"nexttime" => Keyword::NextTime,
	"nmos" => Keyword::Nmos,
	"nor" => Keyword::Nor,
	"noshowcancelled" => Keyword::NoShowCancelled,
	"not" => Keyword::Not,
	"notif0" => Keyword::NotIf0,
	"notif1" => Keyword::NotIf1,
	"null" => Keyword::Null,
	"or" => Keyword::Or,
	"output" => Keyword::Output,
	"package" => Keyword::Package,
	"packed" => Keyword::Packed,
	"parameter" => Keyword::Parameter,
	"pmos" => Keyword::Pmos,
	"posedge" => Keyword::PosEdge,
	"primitive" => Keyword::Primitive,
	"priority" => Keyword::Priority,
	"program" => Keyword::Program,
	"property" => Keyword::Property,
	"protected" => Keyword::Protected,
	"pull0" => Keyword::Pull0,
	"pull1" => Keyword::Pull1,
	"pulldown" => Keyword::Pulldown,
	"pullup" => Keyword::Pullup,
	"pulsestyle_ondetect" => Keyword::PulseStyleOnDetect,
	"pulsestyle_onevent" => Keyword::PulseStyleOnEvent,
	"pure" => Keyword::Pure,
	"rand" => Keyword::Rand,
	"randc" => Keyword::RandC,
	"randcase" => Keyword::RandCase,
	"randsequence" => Keyword::RandSequence,
	"rcmos" => Keyword::Rcmos,
	"real" => Keyword::Real,
	"realtime" => Keyword::Realtime,
	"ref" => Keyword::Ref,
	"reg" => Keyword::Reg,
	"reject_on" => Keyword::RejectOn,
	"release" => Keyword::Release,
	"repeat" => Keyword::Repeat,
	"restrict" => Keyword::Restrict,
	"return" => Keyword::Return,
	"rnmos" => Keyword::Rnmos,
	"rpmos" => Keyword::Rpmos,
	"rtran" => Keyword::Rtran,
	"rtranif0" => Keyword::RtranIf0,
	"rtranif1" => Keyword::RtranIf1,
	"s_always" => Keyword::SAlways,
	"s_eventually" => Keyword::SEventually,
	"s_nexttime" => Keyword::SNextTime,
	"s_until_with" => Keyword::SUntilWith,
	"s_until" => Keyword::SUntil,
	"scalared" => Keyword::Scalared,
	"sequence" => Keyword::Sequence,
	"shortint" => Keyword::ShortInt,
	"shortreal" => Keyword::ShortReal,
	"showcancelled" => Keyword::ShowCancelled,
	"signed" => Keyword::Signed,
	"small" => Keyword::Small,
	"soft" => Keyword::Soft,
	"solve" => Keyword::Solve,
	"specify" => Keyword::Specify,
	"specparam" => Keyword::SpecParam,
	"static" => Keyword::Static,
	"string" => Keyword::String,
	"strong" => Keyword::Strong,
	"strong0" => Keyword::Strong0,
	"strong1" => Keyword::Strong1,
	"struct" => Keyword::Struct,
	"super" => Keyword::Super,
	"supply0" => Keyword::Supply0,
	"supply1" => Keyword::Supply1,
	"sync_accpet_on" => Keyword::SyncAcceptOn,
	"sync_reject_on" => Keyword::SyncRejectOn,
	"table" => Keyword::Table,
	"tagged" => Keyword::Tagged,
	"task" => Keyword::Task,
	"this" => Keyword::This,
	"throughout" => Keyword::Throughout,
	"time" => Keyword::Time,
	"timeprecision" => Keyword::TimePrecision,
	"timeunit" => Keyword::TimeUnit,
	"tran" => Keyword::Tran,
	"tranif0" => Keyword::TranIf0,
	"tranif1" => Keyword::TranIf1,
	"tri" => Keyword::Tri,
	"tri0" => Keyword::Tri0,
	"tri1" => Keyword::Tri1,
	"triand" => Keyword::Triand,
	"trior" => Keyword::Trior,
	"trireg" => Keyword::Trireg,
	"type" => Keyword::Type,
	"typedef" => Keyword::TypeDef,
	"union" => Keyword::Union,
	"unique" => Keyword::Unique,
	"unique0" => Keyword::Unique0,
	"unsigned" => Keyword::Unsigned,
	"until_with" => Keyword::UntilWith,
	"until" => Keyword::Until,
	"untyped" => Keyword::Untyped,
	"use" => Keyword::Use,
	"uwire" => Keyword::Uwire,
	"var" => Keyword::Var,
	"vectored" => Keyword::Vectored,
	"virtual" => Keyword::Virtual,
	"void" => Keyword::Void,
	"wait_order" => Keyword::WaitOrder,
	"wait" => Keyword::Wait,
	"wand" => Keyword::Wand,
	"weak" => Keyword::Weak,
	"weak0" => Keyword::Weak0,
	"weak1" => Keyword::Weak1,
	"while" => Keyword::While,
	"wildcard" => Keyword::Wildcard,
	"wire" => Keyword::Wire,
	"with" => Keyword::With,
	"within" => Keyword::Within,
	"wor" => Keyword::Wor,
	"xnor" => Keyword::Xnor,
	"xor" => Keyword::Xor,
};

/// IEEE 1800-2012 (SystemVerilog 2012) Keyword set
pub static SYSTEM_VERILOG_12_KEYWORD_SET: phf::Set<&'static str> = phf_set! {
	"accept_on",    "endcase",      "inout",           "pull1",               "sync_accpet_on",
	"alias",        "endchecker",   "input",           "pulldown",            "sync_reject_on",
	"always_comb",  "endclass",     "inside",          "pullup",              "table",
	"always_ff",    "endclocking",  "instance",        "pulsestyle_ondetect", "tagged",
	"always_latch", "endconfig",    "int",             "pulsestyle_onevent",  "task",
	"always",       "endfunction",  "integer",         "pure",                "this",
	"and",          "endgenerate",  "interconnect",    "rand",                "throughout",
	"assert",       "endgroup",     "interface",       "randc",               "time",
	"assign",       "endinterface", "intersect",       "randcase",            "timeprecision",
	"assume",       "endmodule",    "join_any",        "randsequence",        "timeunit",
	"automatic",    "endpackage",   "join_none",       "rcmos",               "tran",
	"before",       "endprimitive", "join",            "real",                "tranif0",
	"begin",        "endprogram",   "large",           "realtime",            "tranif1",
	"bind",         "endproperty",  "let",             "ref",                 "tri",
	"bins",         "endsequence",  "liblist",         "reg",                 "tri0",
	"binsof",       "endspecify",   "library",         "reject_on",           "tri1",
	"bit",          "endtable",     "local",           "release",             "triand",
	"break",        "endtask",      "localparam",      "repeat",              "trior",
	"buf",          "enum",         "logic",           "restrict",            "trireg",
	"bufif0",       "event",        "longint",         "return",              "type",
	"bufif1",       "eventually",   "macromodule",     "rnmos",               "typedef",
	"byte",         "expect",       "matches",         "rpmos",               "union",
	"case",         "export",       "medium",          "rtran",               "unique",
	"casex",        "extends",      "modport",         "rtranif0",            "unique0",
	"casez",        "extern",       "module",          "rtranif1",            "unsigned",
	"cell",         "final",        "nand",            "s_always",            "until_with",
	"chandle",      "first_match",  "negedge",         "s_eventually",        "until",
	"checker",      "for",          "nettype",         "s_nexttime",          "untyped",
	"class",        "force",        "new",             "s_until_with",        "use",
	"clocking",     "foreach",      "nexttime",        "s_until",             "uwire",
	"cmos",         "forever",      "nmos",            "scalared",            "var",
	"config",       "fork",         "nor",             "sequence",            "vectored",
	"const",        "forkjoin",     "noshowcancelled", "shortint",            "virtual",
	"constraint",   "function",     "not",             "shortreal",           "void",
	"context",      "generate",     "notif0",          "showcancelled",       "wait_order",
	"continue",     "genvar",       "notif1",          "signed",              "wait",
	"cover",        "global",       "null",            "small",               "wand",
	"covergroup",   "highz0",       "or",              "soft",                "weak",
	"coverpoint",   "highz1",       "output",          "solve",               "weak0",
	"cross",        "if",           "package",         "specify",             "weak1",
	"deassign",     "iff",          "packed",          "specparam",           "while",
	"default",      "ifnone",       "parameter",       "static",              "wildcard",
	"defparam",     "ignore_bins",  "pmos",            "string",              "wire",
	"design",       "illegal_bins", "posedge",         "strong",              "with",
	"disable",      "implements",   "primitive",       "strong0",             "within",
	"dist",         "implies",      "priority",        "strong1",             "wor",
	"do",           "import",       "program",         "struct",              "xnor",
	"edge",         "incdir",       "property",        "super",               "xor",
	"else",         "include",      "protected",       "supply0",
	"end",          "initial",      "pull0",           "supply1",
};

// NOTE(aki): Identical to `SYSTEM_VERILOG_12_KEYWORD_MAP`
/// IEEE 1800-2017 (SystemVerilog 2017) Keyword to [`Keyword`] token map
pub static SYSTEM_VERILOG_17_KEYWORD_MAP: phf::Map<&'static str, Keyword> = phf_map! {
	"accept_on" => Keyword::AcceptOn,
	"alias" => Keyword::Alias,
	"always_comb" => Keyword::AlwaysComb,
	"always_ff" => Keyword::AlwaysFF,
	"always_latch" => Keyword::AlwaysLatch,
	"always" => Keyword::Always,
	"and" => Keyword::And,
	"assert" => Keyword::Assert,
	"assign" => Keyword::Assign,
	"assume" => Keyword::Assume,
	"automatic" => Keyword::Automatic,
	"before" => Keyword::Before,
	"begin" => Keyword::Begin,
	"bind" => Keyword::Bind,
	"bins" => Keyword::Bins,
	"binsof" => Keyword::BinsOf,
	"bit" => Keyword::Bit,
	"break" => Keyword::Break,
	"buf" => Keyword::Buf,
	"bufif0" => Keyword::BufIf0,
	"bufif1" => Keyword::BufIf1,
	"byte" => Keyword::Byte,
	"case" => Keyword::Case,
	"casex" => Keyword::CaseX,
	"casez" => Keyword::CaseZ,
	"cell" => Keyword::Cell,
	"chandle" => Keyword::CHandle,
	"checker" => Keyword::Checker,
	"class" => Keyword::Class,
	"clocking" => Keyword::Clocking,
	"cmos" => Keyword::Cmos,
	"config" => Keyword::Config,
	"const" => Keyword::Const,
	"constraint" => Keyword::Constraint,
	"context" => Keyword::Context,
	"continue" => Keyword::Continue,
	"cover" => Keyword::Cover,
	"covergroup" => Keyword::CoverGroup,
	"coverpoint" => Keyword::CoverPoint,
	"cross" => Keyword::Cross,
	"deassign" => Keyword::Deassign,
	"default" => Keyword::Default,
	"defparam" => Keyword::DefParam,
	"design" => Keyword::Design,
	"disable" => Keyword::Disable,
	"dist" => Keyword::Dist,
	"do" => Keyword::Do,
	"edge" => Keyword::Edge,
	"else" => Keyword::Else,
	"end" => Keyword::End,
	"endcase" => Keyword::EndCase,
	"endchecker" => Keyword::EndChecker,
	"endclass" => Keyword::EndClass,
	"endclocking" => Keyword::EndClocking,
	"endconfig" => Keyword::EndConfig,
	"endfunction" => Keyword::EndFunction,
	"endgenerate" => Keyword::EndGenerate,
	"endgroup" => Keyword::EndGroup,
	"endinterface" => Keyword::EndInterface,
	"endmodule" => Keyword::EndModule,
	"endpackage" => Keyword::EndPackage,
	"endprimitive" => Keyword::EndPrimitive,
	"endprogram" => Keyword::EndProgram,
	"endproperty" => Keyword::EndProperty,
	"endsequence" => Keyword::EndSequence,
	"endspecify" => Keyword::EndSpecify,
	"endtable" => Keyword::EndTable,
	"endtask" => Keyword::EndTask,
	"enum" => Keyword::Enum,
	"event" => Keyword::Event,
	"eventually" => Keyword::Eventually,
	"expect" => Keyword::Expect,
	"export" => Keyword::Export,
	"extends" => Keyword::Extends,
	"extern" => Keyword::Extern,
	"final" => Keyword::Final,
	"first_match" => Keyword::FirstMatch,
	"for" => Keyword::For,
	"force" => Keyword::Force,
	"foreach" => Keyword::ForEach,
	"forever" => Keyword::Forever,
	"fork" => Keyword::Fork,
	"forkjoin" => Keyword::ForkJoin,
	"function" => Keyword::Function,
	"generate" => Keyword::Generate,
	"genvar" => Keyword::Genvar,
	"global" => Keyword::Global,
	"highz0" => Keyword::HighZ0,
	"highz1" => Keyword::HighZ1,
	"if" => Keyword::If,
	"iff" => Keyword::Iff,
	"ifnone" => Keyword::IfNone,
	"ignore_bins" => Keyword::IgnoreBins,
	"illegal_bins" => Keyword::IllegalBins,
	"implements" => Keyword::Implements,
	"implies" => Keyword::Implies,
	"import" => Keyword::Import,
	"incdir" => Keyword::IncDir,
	"include" => Keyword::Include,
	"initial" => Keyword::Initial,
	"inout" => Keyword::InOut,
	"input" => Keyword::Input,
	"inside" => Keyword::Inside,
	"instance" => Keyword::Instance,
	"int" => Keyword::Int,
	"integer" => Keyword::Integer,
	"interconnect" => Keyword::Interconnect,
	"interface" => Keyword::Interface,
	"intersect" => Keyword::Intersect,
	"join_any" => Keyword::JoinAny,
	"join_none" => Keyword::JoinNone,
	"join" => Keyword::Join,
	"large" => Keyword::Large,
	"let" => Keyword::Let,
	"liblist" => Keyword::LibList,
	"library" => Keyword::Library,
	"local" => Keyword::Local,
	"localparam" => Keyword::LocalParam,
	"logic" => Keyword::Logic,
	"longint" => Keyword::LongInt,
	"macromodule" => Keyword::MacroModule,
	"matches" => Keyword::Matches,
	"medium" => Keyword::Medium,
	"modport" => Keyword::ModPort,
	"module" => Keyword::Module,
	"nand" => Keyword::Nand,
	"negedge" => Keyword::NegEdge,
	"nettype" => Keyword::NetType,
	"new" => Keyword::New,
	"nexttime" => Keyword::NextTime,
	"nmos" => Keyword::Nmos,
	"nor" => Keyword::Nor,
	"noshowcancelled" => Keyword::NoShowCancelled,
	"not" => Keyword::Not,
	"notif0" => Keyword::NotIf0,
	"notif1" => Keyword::NotIf1,
	"null" => Keyword::Null,
	"or" => Keyword::Or,
	"output" => Keyword::Output,
	"package" => Keyword::Package,
	"packed" => Keyword::Packed,
	"parameter" => Keyword::Parameter,
	"pmos" => Keyword::Pmos,
	"posedge" => Keyword::PosEdge,
	"primitive" => Keyword::Primitive,
	"priority" => Keyword::Priority,
	"program" => Keyword::Program,
	"property" => Keyword::Property,
	"protected" => Keyword::Protected,
	"pull0" => Keyword::Pull0,
	"pull1" => Keyword::Pull1,
	"pulldown" => Keyword::Pulldown,
	"pullup" => Keyword::Pullup,
	"pulsestyle_ondetect" => Keyword::PulseStyleOnDetect,
	"pulsestyle_onevent" => Keyword::PulseStyleOnEvent,
	"pure" => Keyword::Pure,
	"rand" => Keyword::Rand,
	"randc" => Keyword::RandC,
	"randcase" => Keyword::RandCase,
	"randsequence" => Keyword::RandSequence,
	"rcmos" => Keyword::Rcmos,
	"real" => Keyword::Real,
	"realtime" => Keyword::Realtime,
	"ref" => Keyword::Ref,
	"reg" => Keyword::Reg,
	"reject_on" => Keyword::RejectOn,
	"release" => Keyword::Release,
	"repeat" => Keyword::Repeat,
	"restrict" => Keyword::Restrict,
	"return" => Keyword::Return,
	"rnmos" => Keyword::Rnmos,
	"rpmos" => Keyword::Rpmos,
	"rtran" => Keyword::Rtran,
	"rtranif0" => Keyword::RtranIf0,
	"rtranif1" => Keyword::RtranIf1,
	"s_always" => Keyword::SAlways,
	"s_eventually" => Keyword::SEventually,
	"s_nexttime" => Keyword::SNextTime,
	"s_until_with" => Keyword::SUntilWith,
	"s_until" => Keyword::SUntil,
	"scalared" => Keyword::Scalared,
	"sequence" => Keyword::Sequence,
	"shortint" => Keyword::ShortInt,
	"shortreal" => Keyword::ShortReal,
	"showcancelled" => Keyword::ShowCancelled,
	"signed" => Keyword::Signed,
	"small" => Keyword::Small,
	"soft" => Keyword::Soft,
	"solve" => Keyword::Solve,
	"specify" => Keyword::Specify,
	"specparam" => Keyword::SpecParam,
	"static" => Keyword::Static,
	"string" => Keyword::String,
	"strong" => Keyword::Strong,
	"strong0" => Keyword::Strong0,
	"strong1" => Keyword::Strong1,
	"struct" => Keyword::Struct,
	"super" => Keyword::Super,
	"supply0" => Keyword::Supply0,
	"supply1" => Keyword::Supply1,
	"sync_accpet_on" => Keyword::SyncAcceptOn,
	"sync_reject_on" => Keyword::SyncRejectOn,
	"table" => Keyword::Table,
	"tagged" => Keyword::Tagged,
	"task" => Keyword::Task,
	"this" => Keyword::This,
	"throughout" => Keyword::Throughout,
	"time" => Keyword::Time,
	"timeprecision" => Keyword::TimePrecision,
	"timeunit" => Keyword::TimeUnit,
	"tran" => Keyword::Tran,
	"tranif0" => Keyword::TranIf0,
	"tranif1" => Keyword::TranIf1,
	"tri" => Keyword::Tri,
	"tri0" => Keyword::Tri0,
	"tri1" => Keyword::Tri1,
	"triand" => Keyword::Triand,
	"trior" => Keyword::Trior,
	"trireg" => Keyword::Trireg,
	"type" => Keyword::Type,
	"typedef" => Keyword::TypeDef,
	"union" => Keyword::Union,
	"unique" => Keyword::Unique,
	"unique0" => Keyword::Unique0,
	"unsigned" => Keyword::Unsigned,
	"until_with" => Keyword::UntilWith,
	"until" => Keyword::Until,
	"untyped" => Keyword::Untyped,
	"use" => Keyword::Use,
	"uwire" => Keyword::Uwire,
	"var" => Keyword::Var,
	"vectored" => Keyword::Vectored,
	"virtual" => Keyword::Virtual,
	"void" => Keyword::Void,
	"wait_order" => Keyword::WaitOrder,
	"wait" => Keyword::Wait,
	"wand" => Keyword::Wand,
	"weak" => Keyword::Weak,
	"weak0" => Keyword::Weak0,
	"weak1" => Keyword::Weak1,
	"while" => Keyword::While,
	"wildcard" => Keyword::Wildcard,
	"wire" => Keyword::Wire,
	"with" => Keyword::With,
	"within" => Keyword::Within,
	"wor" => Keyword::Wor,
	"xnor" => Keyword::Xnor,
	"xor" => Keyword::Xor,
};

// NOTE(aki): Identical to `SYSTEM_VERILOG_12_KEYWORD_SET`
/// IEEE 1800-2017 (SystemVerilog 2017) Keyword set
pub static SYSTEM_VERILOG_17_KEYWORD_SET: phf::Set<&'static str> = phf_set! {
	"accept_on",    "endcase",      "inout",           "pull1",               "sync_accpet_on",
	"alias",        "endchecker",   "input",           "pulldown",            "sync_reject_on",
	"always_comb",  "endclass",     "inside",          "pullup",              "table",
	"always_ff",    "endclocking",  "instance",        "pulsestyle_ondetect", "tagged",
	"always_latch", "endconfig",    "int",             "pulsestyle_onevent",  "task",
	"always",       "endfunction",  "integer",         "pure",                "this",
	"and",          "endgenerate",  "interconnect",    "rand",                "throughout",
	"assert",       "endgroup",     "interface",       "randc",               "time",
	"assign",       "endinterface", "intersect",       "randcase",            "timeprecision",
	"assume",       "endmodule",    "join_any",        "randsequence",        "timeunit",
	"automatic",    "endpackage",   "join_none",       "rcmos",               "tran",
	"before",       "endprimitive", "join",            "real",                "tranif0",
	"begin",        "endprogram",   "large",           "realtime",            "tranif1",
	"bind",         "endproperty",  "let",             "ref",                 "tri",
	"bins",         "endsequence",  "liblist",         "reg",                 "tri0",
	"binsof",       "endspecify",   "library",         "reject_on",           "tri1",
	"bit",          "endtable",     "local",           "release",             "triand",
	"break",        "endtask",      "localparam",      "repeat",              "trior",
	"buf",          "enum",         "logic",           "restrict",            "trireg",
	"bufif0",       "event",        "longint",         "return",              "type",
	"bufif1",       "eventually",   "macromodule",     "rnmos",               "typedef",
	"byte",         "expect",       "matches",         "rpmos",               "union",
	"case",         "export",       "medium",          "rtran",               "unique",
	"casex",        "extends",      "modport",         "rtranif0",            "unique0",
	"casez",        "extern",       "module",          "rtranif1",            "unsigned",
	"cell",         "final",        "nand",            "s_always",            "until_with",
	"chandle",      "first_match",  "negedge",         "s_eventually",        "until",
	"checker",      "for",          "nettype",         "s_nexttime",          "untyped",
	"class",        "force",        "new",             "s_until_with",        "use",
	"clocking",     "foreach",      "nexttime",        "s_until",             "uwire",
	"cmos",         "forever",      "nmos",            "scalared",            "var",
	"config",       "fork",         "nor",             "sequence",            "vectored",
	"const",        "forkjoin",     "noshowcancelled", "shortint",            "virtual",
	"constraint",   "function",     "not",             "shortreal",           "void",
	"context",      "generate",     "notif0",          "showcancelled",       "wait_order",
	"continue",     "genvar",       "notif1",          "signed",              "wait",
	"cover",        "global",       "null",            "small",               "wand",
	"covergroup",   "highz0",       "or",              "soft",                "weak",
	"coverpoint",   "highz1",       "output",          "solve",               "weak0",
	"cross",        "if",           "package",         "specify",             "weak1",
	"deassign",     "iff",          "packed",          "specparam",           "while",
	"default",      "ifnone",       "parameter",       "static",              "wildcard",
	"defparam",     "ignore_bins",  "pmos",            "string",              "wire",
	"design",       "illegal_bins", "posedge",         "strong",              "with",
	"disable",      "implements",   "primitive",       "strong0",             "within",
	"dist",         "implies",      "priority",        "strong1",             "wor",
	"do",           "import",       "program",         "struct",              "xnor",
	"edge",         "incdir",       "property",        "super",               "xor",
	"else",         "include",      "protected",       "supply0",
	"end",          "initial",      "pull0",           "supply1",
};

// NOTE(aki): Identical to `SYSTEM_VERILOG_12_KEYWORD_MAP`
/// IEEE 1800-2023 (SystemVerilog 2023) Keyword to [`Keyword`] token map
pub static SYSTEM_VERILOG_23_KEYWORD_MAP: phf::Map<&'static str, Keyword> = phf_map! {
	"accept_on" => Keyword::AcceptOn,
	"alias" => Keyword::Alias,
	"always_comb" => Keyword::AlwaysComb,
	"always_ff" => Keyword::AlwaysFF,
	"always_latch" => Keyword::AlwaysLatch,
	"always" => Keyword::Always,
	"and" => Keyword::And,
	"assert" => Keyword::Assert,
	"assign" => Keyword::Assign,
	"assume" => Keyword::Assume,
	"automatic" => Keyword::Automatic,
	"before" => Keyword::Before,
	"begin" => Keyword::Begin,
	"bind" => Keyword::Bind,
	"bins" => Keyword::Bins,
	"binsof" => Keyword::BinsOf,
	"bit" => Keyword::Bit,
	"break" => Keyword::Break,
	"buf" => Keyword::Buf,
	"bufif0" => Keyword::BufIf0,
	"bufif1" => Keyword::BufIf1,
	"byte" => Keyword::Byte,
	"case" => Keyword::Case,
	"casex" => Keyword::CaseX,
	"casez" => Keyword::CaseZ,
	"cell" => Keyword::Cell,
	"chandle" => Keyword::CHandle,
	"checker" => Keyword::Checker,
	"class" => Keyword::Class,
	"clocking" => Keyword::Clocking,
	"cmos" => Keyword::Cmos,
	"config" => Keyword::Config,
	"const" => Keyword::Const,
	"constraint" => Keyword::Constraint,
	"context" => Keyword::Context,
	"continue" => Keyword::Continue,
	"cover" => Keyword::Cover,
	"covergroup" => Keyword::CoverGroup,
	"coverpoint" => Keyword::CoverPoint,
	"cross" => Keyword::Cross,
	"deassign" => Keyword::Deassign,
	"default" => Keyword::Default,
	"defparam" => Keyword::DefParam,
	"design" => Keyword::Design,
	"disable" => Keyword::Disable,
	"dist" => Keyword::Dist,
	"do" => Keyword::Do,
	"edge" => Keyword::Edge,
	"else" => Keyword::Else,
	"end" => Keyword::End,
	"endcase" => Keyword::EndCase,
	"endchecker" => Keyword::EndChecker,
	"endclass" => Keyword::EndClass,
	"endclocking" => Keyword::EndClocking,
	"endconfig" => Keyword::EndConfig,
	"endfunction" => Keyword::EndFunction,
	"endgenerate" => Keyword::EndGenerate,
	"endgroup" => Keyword::EndGroup,
	"endinterface" => Keyword::EndInterface,
	"endmodule" => Keyword::EndModule,
	"endpackage" => Keyword::EndPackage,
	"endprimitive" => Keyword::EndPrimitive,
	"endprogram" => Keyword::EndProgram,
	"endproperty" => Keyword::EndProperty,
	"endsequence" => Keyword::EndSequence,
	"endspecify" => Keyword::EndSpecify,
	"endtable" => Keyword::EndTable,
	"endtask" => Keyword::EndTask,
	"enum" => Keyword::Enum,
	"event" => Keyword::Event,
	"eventually" => Keyword::Eventually,
	"expect" => Keyword::Expect,
	"export" => Keyword::Export,
	"extends" => Keyword::Extends,
	"extern" => Keyword::Extern,
	"final" => Keyword::Final,
	"first_match" => Keyword::FirstMatch,
	"for" => Keyword::For,
	"force" => Keyword::Force,
	"foreach" => Keyword::ForEach,
	"forever" => Keyword::Forever,
	"fork" => Keyword::Fork,
	"forkjoin" => Keyword::ForkJoin,
	"function" => Keyword::Function,
	"generate" => Keyword::Generate,
	"genvar" => Keyword::Genvar,
	"global" => Keyword::Global,
	"highz0" => Keyword::HighZ0,
	"highz1" => Keyword::HighZ1,
	"if" => Keyword::If,
	"iff" => Keyword::Iff,
	"ifnone" => Keyword::IfNone,
	"ignore_bins" => Keyword::IgnoreBins,
	"illegal_bins" => Keyword::IllegalBins,
	"implements" => Keyword::Implements,
	"implies" => Keyword::Implies,
	"import" => Keyword::Import,
	"incdir" => Keyword::IncDir,
	"include" => Keyword::Include,
	"initial" => Keyword::Initial,
	"inout" => Keyword::InOut,
	"input" => Keyword::Input,
	"inside" => Keyword::Inside,
	"instance" => Keyword::Instance,
	"int" => Keyword::Int,
	"integer" => Keyword::Integer,
	"interconnect" => Keyword::Interconnect,
	"interface" => Keyword::Interface,
	"intersect" => Keyword::Intersect,
	"join_any" => Keyword::JoinAny,
	"join_none" => Keyword::JoinNone,
	"join" => Keyword::Join,
	"large" => Keyword::Large,
	"let" => Keyword::Let,
	"liblist" => Keyword::LibList,
	"library" => Keyword::Library,
	"local" => Keyword::Local,
	"localparam" => Keyword::LocalParam,
	"logic" => Keyword::Logic,
	"longint" => Keyword::LongInt,
	"macromodule" => Keyword::MacroModule,
	"matches" => Keyword::Matches,
	"medium" => Keyword::Medium,
	"modport" => Keyword::ModPort,
	"module" => Keyword::Module,
	"nand" => Keyword::Nand,
	"negedge" => Keyword::NegEdge,
	"nettype" => Keyword::NetType,
	"new" => Keyword::New,
	"nexttime" => Keyword::NextTime,
	"nmos" => Keyword::Nmos,
	"nor" => Keyword::Nor,
	"noshowcancelled" => Keyword::NoShowCancelled,
	"not" => Keyword::Not,
	"notif0" => Keyword::NotIf0,
	"notif1" => Keyword::NotIf1,
	"null" => Keyword::Null,
	"or" => Keyword::Or,
	"output" => Keyword::Output,
	"package" => Keyword::Package,
	"packed" => Keyword::Packed,
	"parameter" => Keyword::Parameter,
	"pmos" => Keyword::Pmos,
	"posedge" => Keyword::PosEdge,
	"primitive" => Keyword::Primitive,
	"priority" => Keyword::Priority,
	"program" => Keyword::Program,
	"property" => Keyword::Property,
	"protected" => Keyword::Protected,
	"pull0" => Keyword::Pull0,
	"pull1" => Keyword::Pull1,
	"pulldown" => Keyword::Pulldown,
	"pullup" => Keyword::Pullup,
	"pulsestyle_ondetect" => Keyword::PulseStyleOnDetect,
	"pulsestyle_onevent" => Keyword::PulseStyleOnEvent,
	"pure" => Keyword::Pure,
	"rand" => Keyword::Rand,
	"randc" => Keyword::RandC,
	"randcase" => Keyword::RandCase,
	"randsequence" => Keyword::RandSequence,
	"rcmos" => Keyword::Rcmos,
	"real" => Keyword::Real,
	"realtime" => Keyword::Realtime,
	"ref" => Keyword::Ref,
	"reg" => Keyword::Reg,
	"reject_on" => Keyword::RejectOn,
	"release" => Keyword::Release,
	"repeat" => Keyword::Repeat,
	"restrict" => Keyword::Restrict,
	"return" => Keyword::Return,
	"rnmos" => Keyword::Rnmos,
	"rpmos" => Keyword::Rpmos,
	"rtran" => Keyword::Rtran,
	"rtranif0" => Keyword::RtranIf0,
	"rtranif1" => Keyword::RtranIf1,
	"s_always" => Keyword::SAlways,
	"s_eventually" => Keyword::SEventually,
	"s_nexttime" => Keyword::SNextTime,
	"s_until_with" => Keyword::SUntilWith,
	"s_until" => Keyword::SUntil,
	"scalared" => Keyword::Scalared,
	"sequence" => Keyword::Sequence,
	"shortint" => Keyword::ShortInt,
	"shortreal" => Keyword::ShortReal,
	"showcancelled" => Keyword::ShowCancelled,
	"signed" => Keyword::Signed,
	"small" => Keyword::Small,
	"soft" => Keyword::Soft,
	"solve" => Keyword::Solve,
	"specify" => Keyword::Specify,
	"specparam" => Keyword::SpecParam,
	"static" => Keyword::Static,
	"string" => Keyword::String,
	"strong" => Keyword::Strong,
	"strong0" => Keyword::Strong0,
	"strong1" => Keyword::Strong1,
	"struct" => Keyword::Struct,
	"super" => Keyword::Super,
	"supply0" => Keyword::Supply0,
	"supply1" => Keyword::Supply1,
	"sync_accpet_on" => Keyword::SyncAcceptOn,
	"sync_reject_on" => Keyword::SyncRejectOn,
	"table" => Keyword::Table,
	"tagged" => Keyword::Tagged,
	"task" => Keyword::Task,
	"this" => Keyword::This,
	"throughout" => Keyword::Throughout,
	"time" => Keyword::Time,
	"timeprecision" => Keyword::TimePrecision,
	"timeunit" => Keyword::TimeUnit,
	"tran" => Keyword::Tran,
	"tranif0" => Keyword::TranIf0,
	"tranif1" => Keyword::TranIf1,
	"tri" => Keyword::Tri,
	"tri0" => Keyword::Tri0,
	"tri1" => Keyword::Tri1,
	"triand" => Keyword::Triand,
	"trior" => Keyword::Trior,
	"trireg" => Keyword::Trireg,
	"type" => Keyword::Type,
	"typedef" => Keyword::TypeDef,
	"union" => Keyword::Union,
	"unique" => Keyword::Unique,
	"unique0" => Keyword::Unique0,
	"unsigned" => Keyword::Unsigned,
	"until_with" => Keyword::UntilWith,
	"until" => Keyword::Until,
	"untyped" => Keyword::Untyped,
	"use" => Keyword::Use,
	"uwire" => Keyword::Uwire,
	"var" => Keyword::Var,
	"vectored" => Keyword::Vectored,
	"virtual" => Keyword::Virtual,
	"void" => Keyword::Void,
	"wait_order" => Keyword::WaitOrder,
	"wait" => Keyword::Wait,
	"wand" => Keyword::Wand,
	"weak" => Keyword::Weak,
	"weak0" => Keyword::Weak0,
	"weak1" => Keyword::Weak1,
	"while" => Keyword::While,
	"wildcard" => Keyword::Wildcard,
	"wire" => Keyword::Wire,
	"with" => Keyword::With,
	"within" => Keyword::Within,
	"wor" => Keyword::Wor,
	"xnor" => Keyword::Xnor,
	"xor" => Keyword::Xor,
};

// NOTE(aki): Identical to `SYSTEM_VERILOG_12_KEYWORD_SET`
/// IEEE 1800-2023 (SystemVerilog 2023) Keyword set
pub static SYSTEM_VERILOG_23_KEYWORD_SET: phf::Set<&'static str> = phf_set! {
	"accept_on",    "endcase",      "inout",           "pull1",               "sync_accpet_on",
	"alias",        "endchecker",   "input",           "pulldown",            "sync_reject_on",
	"always_comb",  "endclass",     "inside",          "pullup",              "table",
	"always_ff",    "endclocking",  "instance",        "pulsestyle_ondetect", "tagged",
	"always_latch", "endconfig",    "int",             "pulsestyle_onevent",  "task",
	"always",       "endfunction",  "integer",         "pure",                "this",
	"and",          "endgenerate",  "interconnect",    "rand",                "throughout",
	"assert",       "endgroup",     "interface",       "randc",               "time",
	"assign",       "endinterface", "intersect",       "randcase",            "timeprecision",
	"assume",       "endmodule",    "join_any",        "randsequence",        "timeunit",
	"automatic",    "endpackage",   "join_none",       "rcmos",               "tran",
	"before",       "endprimitive", "join",            "real",                "tranif0",
	"begin",        "endprogram",   "large",           "realtime",            "tranif1",
	"bind",         "endproperty",  "let",             "ref",                 "tri",
	"bins",         "endsequence",  "liblist",         "reg",                 "tri0",
	"binsof",       "endspecify",   "library",         "reject_on",           "tri1",
	"bit",          "endtable",     "local",           "release",             "triand",
	"break",        "endtask",      "localparam",      "repeat",              "trior",
	"buf",          "enum",         "logic",           "restrict",            "trireg",
	"bufif0",       "event",        "longint",         "return",              "type",
	"bufif1",       "eventually",   "macromodule",     "rnmos",               "typedef",
	"byte",         "expect",       "matches",         "rpmos",               "union",
	"case",         "export",       "medium",          "rtran",               "unique",
	"casex",        "extends",      "modport",         "rtranif0",            "unique0",
	"casez",        "extern",       "module",          "rtranif1",            "unsigned",
	"cell",         "final",        "nand",            "s_always",            "until_with",
	"chandle",      "first_match",  "negedge",         "s_eventually",        "until",
	"checker",      "for",          "nettype",         "s_nexttime",          "untyped",
	"class",        "force",        "new",             "s_until_with",        "use",
	"clocking",     "foreach",      "nexttime",        "s_until",             "uwire",
	"cmos",         "forever",      "nmos",            "scalared",            "var",
	"config",       "fork",         "nor",             "sequence",            "vectored",
	"const",        "forkjoin",     "noshowcancelled", "shortint",            "virtual",
	"constraint",   "function",     "not",             "shortreal",           "void",
	"context",      "generate",     "notif0",          "showcancelled",       "wait_order",
	"continue",     "genvar",       "notif1",          "signed",              "wait",
	"cover",        "global",       "null",            "small",               "wand",
	"covergroup",   "highz0",       "or",              "soft",                "weak",
	"coverpoint",   "highz1",       "output",          "solve",               "weak0",
	"cross",        "if",           "package",         "specify",             "weak1",
	"deassign",     "iff",          "packed",          "specparam",           "while",
	"default",      "ifnone",       "parameter",       "static",              "wildcard",
	"defparam",     "ignore_bins",  "pmos",            "string",              "wire",
	"design",       "illegal_bins", "posedge",         "strong",              "with",
	"disable",      "implements",   "primitive",       "strong0",             "within",
	"dist",         "implies",      "priority",        "strong1",             "wor",
	"do",           "import",       "program",         "struct",              "xnor",
	"edge",         "incdir",       "property",        "super",               "xor",
	"else",         "include",      "protected",       "supply0",
	"end",          "initial",      "pull0",           "supply1",
};

/// Verilog-AMS 2.3.1 (Verilog-AMS 2009) Keyword to [`Keyword`] token map
pub static VERILOG_AMS_09_KEYWORD_MAP: phf::Map<&'static str, Keyword> = phf_map! {
	"above" => Keyword::Above,
	"abs" => Keyword::Abs,
	"absdelay" => Keyword::AbsDelay,
	"abstol" => Keyword::AbsTol,
	"ac_stim" => Keyword::AcStim,
	"access" => Keyword::Access,
	"acos" => Keyword::Acos,
	"acosh" => Keyword::Acosh,
	"aliasparam" => Keyword::Aliasparam,
	"always" => Keyword::Always,
	"analog" => Keyword::Analog,
	"analysis" => Keyword::Analysis,
	"and" => Keyword::And,
	"asin" => Keyword::Asin,
	"asinh" => Keyword::Asinh,
	"assert" => Keyword::Assert,
	"assign" => Keyword::Assign,
	"atan" => Keyword::Atan,
	"atan2" => Keyword::Atan2,
	"atanh" => Keyword::Atanh,
	"automatic" => Keyword::Automatic,
	"begin" => Keyword::Begin,
	"branch" => Keyword::Branch,
	"buf" => Keyword::Buf,
	"bufif0" => Keyword::BufIf0,
	"bufif1" => Keyword::BufIf1,
	"case" => Keyword::Case,
	"casex" => Keyword::CaseX,
	"casez" => Keyword::CaseZ,
	"ceil" => Keyword::Ceil,
	"cell" => Keyword::Cell,
	"cmos" => Keyword::Cmos,
	"config" => Keyword::Config,
	"connect" => Keyword::Connect,
	"connectmodule" => Keyword::ConnectModule,
	"connectrules" => Keyword::ConnectRules,
	"continuous" => Keyword::Continuous,
	"cos" => Keyword::Cos,
	"cosh" => Keyword::Cosh,
	"cross" => Keyword::Cross,
	"ddt_nature" => Keyword::DdtNature,
	"ddt" => Keyword::Ddt,
	"ddx" => Keyword::Ddx,
	"deassign" => Keyword::Deassign,
	"default" => Keyword::Default,
	"defparam" => Keyword::DefParam,
	"design" => Keyword::Design,
	"disable" => Keyword::Disable,
	"discipline" => Keyword::Discipline,
	"discrete" => Keyword::Discrete,
	"domain" => Keyword::Domain,
	"driver_update" => Keyword::DriverUpdate,
	"edge" => Keyword::Edge,
	"else" => Keyword::Else,
	"end" => Keyword::End,
	"endcase" => Keyword::EndCase,
	"endconfig" => Keyword::EndConfig,
	"endconnectrules" => Keyword::EndConnectRules,
	"enddiscipline" => Keyword::EndDiscipline,
	"endfunction" => Keyword::EndFunction,
	"endgenerate" => Keyword::EndGenerate,
	"endmodule" => Keyword::EndModule,
	"endnature" => Keyword::EndNature,
	"endparamset" => Keyword::EndParamSet,
	"endprimitive" => Keyword::EndPrimitive,
	"endspecify" => Keyword::EndSpecify,
	"endtable" => Keyword::EndTable,
	"endtask" => Keyword::EndTask,
	"event" => Keyword::Event,
	"exclude" => Keyword::Exclude,
	"exp" => Keyword::Exp,
	"final_step" => Keyword::FinalStep,
	"flicker_noise" => Keyword::FlickerNoise,
	"floor" => Keyword::Floor,
	"flow" => Keyword::Flow,
	"for" => Keyword::For,
	"force" => Keyword::Force,
	"forever" => Keyword::Forever,
	"fork" => Keyword::Fork,
	"from" => Keyword::From,
	"function" => Keyword::Function,
	"generate" => Keyword::Generate,
	"genvar" => Keyword::Genvar,
	"ground" => Keyword::Ground,
	"highz0" => Keyword::HighZ0,
	"highz1" => Keyword::HighZ1,
	"hypot" => Keyword::Hypot,
	"idt_nature" => Keyword::IdtNature,
	"idt" => Keyword::Idt,
	"idtmod" => Keyword::IdtMod,
	"if" => Keyword::If,
	"ifnone" => Keyword::IfNone,
	"incdir" => Keyword::IncDir,
	"include" => Keyword::Include,
	"inf" => Keyword::Inf,
	"initial_step" => Keyword::InitialStep,
	"initial" => Keyword::Initial,
	"inout" => Keyword::InOut,
	"input" => Keyword::Input,
	"instance" => Keyword::Instance,
	"integer" => Keyword::Integer,
	"join" => Keyword::Join,
	"laplace_nd" => Keyword::LaplaceNd,
	"laplace_np" => Keyword::LaplaceNp,
	"laplace_zd" => Keyword::LaplaceZd,
	"laplace_zp" => Keyword::LaplaceZp,
	"large" => Keyword::Large,
	"last_crossing" => Keyword::LastCrossing,
	"liblist" => Keyword::LibList,
	"library" => Keyword::Library,
	"limexp" => Keyword::LimExp,
	"ln" => Keyword::Ln,
	"localparam" => Keyword::LocalParam,
	"log" => Keyword::Log,
	"macromodule" => Keyword::MacroModule,
	"max" => Keyword::Max,
	"medium" => Keyword::Medium,
	"merged" => Keyword::Merged,
	"min" => Keyword::Min,
	"module" => Keyword::Module,
	"nand" => Keyword::Nand,
	"negedge" => Keyword::NegEdge,
	"net_resolution" => Keyword::NetResolution,
	"nmos" => Keyword::Nmos,
	"noise_table" => Keyword::NoiseTable,
	"nor" => Keyword::Nor,
	"noshowcancelled" => Keyword::NoShowCancelled,
	"not" => Keyword::Not,
	"notif0" => Keyword::NotIf0,
	"notif1" => Keyword::NotIf1,
	"or" => Keyword::Or,
	"output" => Keyword::Output,
	"parameter" => Keyword::Parameter,
	"paramset" => Keyword::ParamSet,
	"pmos" => Keyword::Pmos,
	"posedge" => Keyword::PosEdge,
	"potential" => Keyword::Potential,
	"pow" => Keyword::Pow,
	"primitive" => Keyword::Primitive,
	"pull0" => Keyword::Pull0,
	"pull1" => Keyword::Pull1,
	"pulldown" => Keyword::Pulldown,
	"pullup" => Keyword::Pullup,
	"pulsestyle_ondetect" => Keyword::PulseStyleOnDetect,
	"pulsestyle_onevent" => Keyword::PulseStyleOnEvent,
	"rcmos" => Keyword::Rcmos,
	"real" => Keyword::Real,
	"realtime" => Keyword::Realtime,
	"reg" => Keyword::Reg,
	"release" => Keyword::Release,
	"repeat" => Keyword::Repeat,
	"resolveto" => Keyword::ResolveTo,
	"rnmos" => Keyword::Rnmos,
	"rpmos" => Keyword::Rpmos,
	"rtran" => Keyword::Rtran,
	"rtranif0" => Keyword::RtranIf0,
	"rtranif1" => Keyword::RtranIf1,
	"scalared" => Keyword::Scalared,
	"showcancelled" => Keyword::ShowCancelled,
	"signed" => Keyword::Signed,
	"sin" => Keyword::Sin,
	"sinh" => Keyword::Sinh,
	"slew" => Keyword::Slew,
	"small" => Keyword::Small,
	"specify" => Keyword::Specify,
	"specparam" => Keyword::SpecParam,
	"split" => Keyword::Split,
	"sqrt" => Keyword::Sqrt,
	"string" => Keyword::String,
	"strong0" => Keyword::Strong0,
	"strong1" => Keyword::Strong1,
	"supply0" => Keyword::Supply0,
	"supply1" => Keyword::Supply1,
	"table" => Keyword::Table,
	"tan" => Keyword::Tan,
	"tanh" => Keyword::Tanh,
	"task" => Keyword::Task,
	"time" => Keyword::Time,
	"timer" => Keyword::Timer,
	"tran" => Keyword::Tran,
	"tranif0" => Keyword::TranIf0,
	"tranif1" => Keyword::TranIf1,
	"transition" => Keyword::Transition,
	"tri" => Keyword::Tri,
	"tri0" => Keyword::Tri0,
	"tri1" => Keyword::Tri1,
	"triand" => Keyword::Triand,
	"trior" => Keyword::Trior,
	"trireg" => Keyword::Trireg,
	"units" => Keyword::Units,
	"unsigned" => Keyword::Unsigned,
	"use" => Keyword::Use,
	"uwire" => Keyword::Uwire,
	"vectored" => Keyword::Vectored,
	"wait" => Keyword::Wait,
	"wand" => Keyword::Wand,
	"weak0" => Keyword::Weak0,
	"weak1" => Keyword::Weak1,
	"while" => Keyword::While,
	"white_noise" => Keyword::WhiteNoise,
	"wire" => Keyword::Wire,
	"wor" => Keyword::Wor,
	"wreal" => Keyword::Wreal,
	"xnor" => Keyword::Xnor,
	"xor" => Keyword::Xor,
	"zi_nd" => Keyword::ZiNd,
	"zi_np" => Keyword::ZiNp,
	"zi_zd" => Keyword::ZiZd,
	"zi_zp" => Keyword::ZiZp,
};

/// Verilog-AMS 2.3.1 (Verilog-AMS 2009) Keyword set
pub static VERILOG_AMS_09_KEYWORD_SET: phf::Set<&'static str> = phf_set! {
	"above",         "ddx",             "highz0",         "noshowcancelled",     "string",
	"abs",           "deassign",        "highz1",         "not",                 "strong0",
	"absdelay",      "default",         "hypot",          "notif0",              "strong1",
	"abstol",        "defparam",        "idt_nature",     "notif1",              "supply0",
	"ac_stim",       "design",          "idt",            "or",                  "supply1",
	"access",        "disable",         "idtmod",         "output",              "table",
	"acos",          "discipline",      "if",             "parameter",           "tan",
	"acosh",         "discrete",        "ifnone",         "paramset",            "tanh",
	"aliasparam",    "domain",          "incdir",         "pmos",                "task",
	"always",        "driver_update",   "include",        "posedge",             "time",
	"analog",        "edge",            "inf",            "potential",           "timer",
	"analysis",      "else",            "initial_step",   "pow",                 "tran",
	"and",           "end",             "initial",        "primitive",           "tranif0",
	"asin",          "endcase",         "inout",          "pull0",               "tranif1",
	"asinh",         "endconfig",       "input",          "pull1",               "transition",
	"assert",        "endconnectrules", "instance",       "pulldown",            "tri",
	"assign",        "enddiscipline",   "integer",        "pullup",              "tri0",
	"atan",          "endfunction",     "join",           "pulsestyle_ondetect", "tri1",
	"atan2",         "endgenerate",     "laplace_nd",     "pulsestyle_onevent",  "triand",
	"atanh",         "endmodule",       "laplace_np",     "rcmos",               "trior",
	"automatic",     "endnature",       "laplace_zd",     "real",                "trireg",
	"begin",         "endparamset",     "laplace_zp",     "realtime",            "units",
	"branch",        "endprimitive",    "large",          "reg",                 "unsigned",
	"buf",           "endspecify",      "last_crossing",  "release",             "use",
	"bufif0",        "endtable",        "liblist",        "repeat",              "uwire",
	"bufif1",        "endtask",         "library",        "resolveto",           "vectored",
	"case",          "event",           "limexp",         "rnmos",               "wait",
	"casex",         "exclude",         "ln",             "rpmos",               "wand",
	"casez",         "exp",             "localparam",     "rtran",               "weak0",
	"ceil",          "final_step",      "log",            "rtranif0",            "weak1",
	"cell",          "flicker_noise",   "macromodule",    "rtranif1",            "while",
	"cmos",          "floor",           "max",            "scalared",            "white_noise",
	"config",        "flow",            "medium",         "showcancelled",       "wire",
	"connect",       "for",             "merged",         "signed",              "wor",
	"connectmodule", "force",           "min",            "sin",                 "wreal",
	"connectrules",  "forever",         "module",         "sinh",                "xnor",
	"continuous",    "fork",            "nand",           "slew",                "xor",
	"cos",           "from",            "negedge",        "small",               "zi_nd",
	"cosh",          "function",        "net_resolution", "specify",             "zi_np",
	"cross",         "generate",        "nmos",           "specparam",           "zi_zd",
	"ddt_nature",    "genvar",          "noise_table",    "split",               "zi_zp",
	"ddt",           "ground",          "nor",            "sqrt",
};

/// Verilog-AMS 2.4.0 (Verilog-AMS 2014) Keyword to [`Keyword`] token map
pub static VERILOG_AMS_14_KEYWORD_MAP: phf::Map<&'static str, Keyword> = phf_map! {
	"above" => Keyword::Above,
	"abs" => Keyword::Abs,
	"absdelay" => Keyword::AbsDelay,
	"absdelta" => Keyword::AbsDelta,
	"abstol" => Keyword::AbsTol,
	"ac_stim" => Keyword::AcStim,
	"access" => Keyword::Access,
	"acos" => Keyword::Acos,
	"acosh" => Keyword::Acosh,
	"aliasparam" => Keyword::Aliasparam,
	"always" => Keyword::Always,
	"analog" => Keyword::Analog,
	"analysis" => Keyword::Analysis,
	"and" => Keyword::And,
	"asin" => Keyword::Asin,
	"asinh" => Keyword::Asinh,
	"assert" => Keyword::Assert,
	"assign" => Keyword::Assign,
	"atan" => Keyword::Atan,
	"atan2" => Keyword::Atan2,
	"atanh" => Keyword::Atanh,
	"automatic" => Keyword::Automatic,
	"begin" => Keyword::Begin,
	"branch" => Keyword::Branch,
	"buf" => Keyword::Buf,
	"bufif0" => Keyword::BufIf0,
	"bufif1" => Keyword::BufIf1,
	"case" => Keyword::Case,
	"casex" => Keyword::CaseX,
	"casez" => Keyword::CaseZ,
	"ceil" => Keyword::Ceil,
	"cell" => Keyword::Cell,
	"cmos" => Keyword::Cmos,
	"config" => Keyword::Config,
	"connect" => Keyword::Connect,
	"connectmodule" => Keyword::ConnectModule,
	"connectrules" => Keyword::ConnectRules,
	"continuous" => Keyword::Continuous,
	"cos" => Keyword::Cos,
	"cosh" => Keyword::Cosh,
	"cross" => Keyword::Cross,
	"ddt_nature" => Keyword::DdtNature,
	"ddt" => Keyword::Ddt,
	"ddx" => Keyword::Ddx,
	"deassign" => Keyword::Deassign,
	"default" => Keyword::Default,
	"defparam" => Keyword::DefParam,
	"design" => Keyword::Design,
	"disable" => Keyword::Disable,
	"discipline" => Keyword::Discipline,
	"discrete" => Keyword::Discrete,
	"domain" => Keyword::Domain,
	"driver_update" => Keyword::DriverUpdate,
	"edge" => Keyword::Edge,
	"else" => Keyword::Else,
	"end" => Keyword::End,
	"endcase" => Keyword::EndCase,
	"endconfig" => Keyword::EndConfig,
	"endconnectrules" => Keyword::EndConnectRules,
	"enddiscipline" => Keyword::EndDiscipline,
	"endfunction" => Keyword::EndFunction,
	"endgenerate" => Keyword::EndGenerate,
	"endmodule" => Keyword::EndModule,
	"endnature" => Keyword::EndNature,
	"endparamset" => Keyword::EndParamSet,
	"endprimitive" => Keyword::EndPrimitive,
	"endspecify" => Keyword::EndSpecify,
	"endtable" => Keyword::EndTable,
	"endtask" => Keyword::EndTask,
	"event" => Keyword::Event,
	"exclude" => Keyword::Exclude,
	"exp" => Keyword::Exp,
	"final_step" => Keyword::FinalStep,
	"flicker_noise" => Keyword::FlickerNoise,
	"floor" => Keyword::Floor,
	"flow" => Keyword::Flow,
	"for" => Keyword::For,
	"force" => Keyword::Force,
	"forever" => Keyword::Forever,
	"fork" => Keyword::Fork,
	"from" => Keyword::From,
	"function" => Keyword::Function,
	"generate" => Keyword::Generate,
	"genvar" => Keyword::Genvar,
	"ground" => Keyword::Ground,
	"highz0" => Keyword::HighZ0,
	"highz1" => Keyword::HighZ1,
	"hypot" => Keyword::Hypot,
	"idt_nature" => Keyword::IdtNature,
	"idt" => Keyword::Idt,
	"idtmod" => Keyword::IdtMod,
	"if" => Keyword::If,
	"ifnone" => Keyword::IfNone,
	"incdir" => Keyword::IncDir,
	"include" => Keyword::Include,
	"inf" => Keyword::Inf,
	"initial_step" => Keyword::InitialStep,
	"initial" => Keyword::Initial,
	"inout" => Keyword::InOut,
	"input" => Keyword::Input,
	"instance" => Keyword::Instance,
	"integer" => Keyword::Integer,
	"join" => Keyword::Join,
	"laplace_nd" => Keyword::LaplaceNd,
	"laplace_np" => Keyword::LaplaceNp,
	"laplace_zd" => Keyword::LaplaceZd,
	"laplace_zp" => Keyword::LaplaceZp,
	"large" => Keyword::Large,
	"last_crossing" => Keyword::LastCrossing,
	"liblist" => Keyword::LibList,
	"library" => Keyword::Library,
	"limexp" => Keyword::LimExp,
	"ln" => Keyword::Ln,
	"localparam" => Keyword::LocalParam,
	"log" => Keyword::Log,
	"macromodule" => Keyword::MacroModule,
	"max" => Keyword::Max,
	"medium" => Keyword::Medium,
	"merged" => Keyword::Merged,
	"min" => Keyword::Min,
	"module" => Keyword::Module,
	"nand" => Keyword::Nand,
	"negedge" => Keyword::NegEdge,
	"net_resolution" => Keyword::NetResolution,
	"nmos" => Keyword::Nmos,
	"noise_table_log" => Keyword::NoiseTableLog,
	"noise_table" => Keyword::NoiseTable,
	"nor" => Keyword::Nor,
	"noshowcancelled" => Keyword::NoShowCancelled,
	"not" => Keyword::Not,
	"notif0" => Keyword::NotIf0,
	"notif1" => Keyword::NotIf1,
	"or" => Keyword::Or,
	"output" => Keyword::Output,
	"parameter" => Keyword::Parameter,
	"paramset" => Keyword::ParamSet,
	"pmos" => Keyword::Pmos,
	"posedge" => Keyword::PosEdge,
	"potential" => Keyword::Potential,
	"pow" => Keyword::Pow,
	"primitive" => Keyword::Primitive,
	"pull0" => Keyword::Pull0,
	"pull1" => Keyword::Pull1,
	"pulldown" => Keyword::Pulldown,
	"pullup" => Keyword::Pullup,
	"pulsestyle_ondetect" => Keyword::PulseStyleOnDetect,
	"pulsestyle_onevent" => Keyword::PulseStyleOnEvent,
	"rcmos" => Keyword::Rcmos,
	"real" => Keyword::Real,
	"realtime" => Keyword::Realtime,
	"reg" => Keyword::Reg,
	"release" => Keyword::Release,
	"repeat" => Keyword::Repeat,
	"resolveto" => Keyword::ResolveTo,
	"rnmos" => Keyword::Rnmos,
	"rpmos" => Keyword::Rpmos,
	"rtran" => Keyword::Rtran,
	"rtranif0" => Keyword::RtranIf0,
	"rtranif1" => Keyword::RtranIf1,
	"scalared" => Keyword::Scalared,
	"showcancelled" => Keyword::ShowCancelled,
	"signed" => Keyword::Signed,
	"sin" => Keyword::Sin,
	"sinh" => Keyword::Sinh,
	"slew" => Keyword::Slew,
	"small" => Keyword::Small,
	"specify" => Keyword::Specify,
	"specparam" => Keyword::SpecParam,
	"split" => Keyword::Split,
	"sqrt" => Keyword::Sqrt,
	"string" => Keyword::String,
	"strong0" => Keyword::Strong0,
	"strong1" => Keyword::Strong1,
	"supply0" => Keyword::Supply0,
	"supply1" => Keyword::Supply1,
	"table" => Keyword::Table,
	"tan" => Keyword::Tan,
	"tanh" => Keyword::Tanh,
	"task" => Keyword::Task,
	"time" => Keyword::Time,
	"timer" => Keyword::Timer,
	"tran" => Keyword::Tran,
	"tranif0" => Keyword::TranIf0,
	"tranif1" => Keyword::TranIf1,
	"transition" => Keyword::Transition,
	"tri" => Keyword::Tri,
	"tri0" => Keyword::Tri0,
	"tri1" => Keyword::Tri1,
	"triand" => Keyword::Triand,
	"trior" => Keyword::Trior,
	"trireg" => Keyword::Trireg,
	"units" => Keyword::Units,
	"unsigned" => Keyword::Unsigned,
	"use" => Keyword::Use,
	"uwire" => Keyword::Uwire,
	"vectored" => Keyword::Vectored,
	"wait" => Keyword::Wait,
	"wand" => Keyword::Wand,
	"weak0" => Keyword::Weak0,
	"weak1" => Keyword::Weak1,
	"while" => Keyword::While,
	"white_noise" => Keyword::WhiteNoise,
	"wire" => Keyword::Wire,
	"wor" => Keyword::Wor,
	"wreal" => Keyword::Wreal,
	"xnor" => Keyword::Xnor,
	"xor" => Keyword::Xor,
	"zi_nd" => Keyword::ZiNd,
	"zi_np" => Keyword::ZiNp,
	"zi_zd" => Keyword::ZiZd,
	"zi_zp" => Keyword::ZiZp,
};

/// Verilog-AMS 2.4.0 (Verilog-AMS 2014) Keyword set
pub static VERILOG_AMS_14_KEYWORD_SET: phf::Set<&'static str> = phf_set! {
	"above",         "ddx",             "highz1",          "not",                 "strong1",
	"abs",           "deassign",        "hypot",           "notif0",              "supply0",
	"absdelay",      "default",         "idt_nature",      "notif1",              "supply1",
	"absdelta",      "defparam",        "idt",             "or",                  "table",
	"abstol",        "design",          "idtmod",          "output",              "tan",
	"ac_stim",       "disable",         "if",              "parameter",           "tanh",
	"access",        "discipline",      "ifnone",          "paramset",            "task",
	"acos",          "discrete",        "incdir",          "pmos",                "time",
	"acosh",         "domain",          "include",         "posedge",             "timer",
	"aliasparam",    "driver_update",   "inf",             "potential",           "tran",
	"always",        "edge",            "initial_step",    "pow",                 "tranif0",
	"analog",        "else",            "initial",         "primitive",           "tranif1",
	"analysis",      "end",             "inout",           "pull0",               "transition",
	"and",           "endcase",         "input",           "pull1",               "tri",
	"asin",          "endconfig",       "instance",        "pulldown",            "tri0",
	"asinh",         "endconnectrules", "integer",         "pullup",              "tri1",
	"assert",        "enddiscipline",   "join",            "pulsestyle_ondetect", "triand",
	"assign",        "endfunction",     "laplace_nd",      "pulsestyle_onevent",  "trior",
	"atan",          "endgenerate",     "laplace_np",      "rcmos",               "trireg",
	"atan2",         "endmodule",       "laplace_zd",      "real",                "units",
	"atanh",         "endnature",       "laplace_zp",      "realtime",            "unsigned",
	"automatic",     "endparamset",     "large",           "reg",                 "use",
	"begin",         "endprimitive",    "last_crossing",   "release",             "uwire",
	"branch",        "endspecify",      "liblist",         "repeat",              "vectored",
	"buf",           "endtable",        "library",         "resolveto",           "wait",
	"bufif0",        "endtask",         "limexp",          "rnmos",               "wand",
	"bufif1",        "event",           "ln",              "rpmos",               "weak0",
	"case",          "exclude",         "localparam",      "rtran",               "weak1",
	"casex",         "exp",             "log",             "rtranif0",            "while",
	"casez",         "final_step",      "macromodule",     "rtranif1",            "white_noise",
	"ceil",          "flicker_noise",   "max",             "scalared",            "wire",
	"cell",          "floor",           "medium",          "showcancelled",       "wor",
	"cmos",          "flow",            "merged",          "signed",              "wreal",
	"config",        "for",             "min",             "sin",                 "xnor",
	"connect",       "force",           "module",          "sinh",                "xor",
	"connectmodule", "forever",         "nand",            "slew",                "zi_nd",
	"connectrules",  "fork",            "negedge",         "small",               "zi_np",
	"continuous",    "from",            "net_resolution",  "specify",             "zi_zd",
	"cos",           "function",        "nmos",            "specparam",           "zi_zp",
	"cosh",          "generate",        "noise_table_log", "split",
	"cross",         "genvar",          "noise_table",     "sqrt",
	"ddt_nature",    "ground",          "nor",             "string",
	"ddt",           "highz0",          "noshowcancelled", "strong0",
};

/// Verilog-AMS 2023 Keyword to [`Keyword`] token map
pub static VERILOG_AMS_23_KEYWORD_MAP: phf::Map<&'static str, Keyword> = phf_map! {
	"above" => Keyword::Above,
	"abs" => Keyword::Abs,
	"absdelay" => Keyword::AbsDelay,
	"absdelta" => Keyword::AbsDelta,
	"abstol" => Keyword::AbsTol,
	"ac_stim" => Keyword::AcStim,
	"access" => Keyword::Access,
	"acos" => Keyword::Acos,
	"acosh" => Keyword::Acosh,
	"aliasparam" => Keyword::Aliasparam,
	"always" => Keyword::Always,
	"analog" => Keyword::Analog,
	"analysis" => Keyword::Analysis,
	"and" => Keyword::And,
	"asin" => Keyword::Asin,
	"asinh" => Keyword::Asinh,
	"assign" => Keyword::Assign,
	"atan" => Keyword::Atan,
	"atan2" => Keyword::Atan2,
	"atanh" => Keyword::Atanh,
	"automatic" => Keyword::Automatic,
	"begin" => Keyword::Begin,
	"branch" => Keyword::Branch,
	"break" => Keyword::Break,
	"buf" => Keyword::Buf,
	"bufif0" => Keyword::BufIf0,
	"bufif1" => Keyword::BufIf1,
	"case" => Keyword::Case,
	"casex" => Keyword::CaseX,
	"casez" => Keyword::CaseZ,
	"ceil" => Keyword::Ceil,
	"cell" => Keyword::Cell,
	"cmos" => Keyword::Cmos,
	"config" => Keyword::Config,
	"connect" => Keyword::Connect,
	"connectmodule" => Keyword::ConnectModule,
	"connectrules" => Keyword::ConnectRules,
	"continue" => Keyword::Continue,
	"continuous" => Keyword::Continuous,
	"cos" => Keyword::Cos,
	"cosh" => Keyword::Cosh,
	"cross" => Keyword::Cross,
	"ddt_nature" => Keyword::DdtNature,
	"ddt" => Keyword::Ddt,
	"ddx" => Keyword::Ddx,
	"deassign" => Keyword::Deassign,
	"default" => Keyword::Default,
	"defparam" => Keyword::DefParam,
	"design" => Keyword::Design,
	"disable" => Keyword::Disable,
	"discipline" => Keyword::Discipline,
	"discrete" => Keyword::Discrete,
	"domain" => Keyword::Domain,
	"driver_update" => Keyword::DriverUpdate,
	"edge" => Keyword::Edge,
	"else" => Keyword::Else,
	"end" => Keyword::End,
	"endcase" => Keyword::EndCase,
	"endconfig" => Keyword::EndConfig,
	"endconnectrules" => Keyword::EndConnectRules,
	"enddiscipline" => Keyword::EndDiscipline,
	"endfunction" => Keyword::EndFunction,
	"endgenerate" => Keyword::EndGenerate,
	"endmodule" => Keyword::EndModule,
	"endnature" => Keyword::EndNature,
	"endparamset" => Keyword::EndParamSet,
	"endprimitive" => Keyword::EndPrimitive,
	"endspecify" => Keyword::EndSpecify,
	"endtable" => Keyword::EndTable,
	"endtask" => Keyword::EndTask,
	"event" => Keyword::Event,
	"exclude" => Keyword::Exclude,
	"exp" => Keyword::Exp,
	"expm1" => Keyword::Expm1,
	"final_step" => Keyword::FinalStep,
	"flicker_noise" => Keyword::FlickerNoise,
	"floor" => Keyword::Floor,
	"flow" => Keyword::Flow,
	"for" => Keyword::For,
	"force" => Keyword::Force,
	"forever" => Keyword::Forever,
	"fork" => Keyword::Fork,
	"from" => Keyword::From,
	"function" => Keyword::Function,
	"generate" => Keyword::Generate,
	"genvar" => Keyword::Genvar,
	"ground" => Keyword::Ground,
	"highz0" => Keyword::HighZ0,
	"highz1" => Keyword::HighZ1,
	"hypot" => Keyword::Hypot,
	"idt_nature" => Keyword::IdtNature,
	"idt" => Keyword::Idt,
	"idtmod" => Keyword::IdtMod,
	"if" => Keyword::If,
	"ifnone" => Keyword::IfNone,
	"incdir" => Keyword::IncDir,
	"include" => Keyword::Include,
	"inf" => Keyword::Inf,
	"initial_step" => Keyword::InitialStep,
	"initial" => Keyword::Initial,
	"inout" => Keyword::InOut,
	"input" => Keyword::Input,
	"instance" => Keyword::Instance,
	"integer" => Keyword::Integer,
	"join" => Keyword::Join,
	"laplace_nd" => Keyword::LaplaceNd,
	"laplace_np" => Keyword::LaplaceNp,
	"laplace_zd" => Keyword::LaplaceZd,
	"laplace_zp" => Keyword::LaplaceZp,
	"large" => Keyword::Large,
	"last_crossing" => Keyword::LastCrossing,
	"liblist" => Keyword::LibList,
	"library" => Keyword::Library,
	"limexp" => Keyword::LimExp,
	"ln" => Keyword::Ln,
	"ln1p" => Keyword::Ln1p,
	"localparam" => Keyword::LocalParam,
	"log" => Keyword::Log,
	"macromodule" => Keyword::MacroModule,
	"max" => Keyword::Max,
	"medium" => Keyword::Medium,
	"merged" => Keyword::Merged,
	"min" => Keyword::Min,
	"module" => Keyword::Module,
	"nand" => Keyword::Nand,
	"negedge" => Keyword::NegEdge,
	"nmos" => Keyword::Nmos,
	"noise_table_log" => Keyword::NoiseTableLog,
	"noise_table" => Keyword::NoiseTable,
	"nor" => Keyword::Nor,
	"noshowcancelled" => Keyword::NoShowCancelled,
	"not" => Keyword::Not,
	"notif0" => Keyword::NotIf0,
	"notif1" => Keyword::NotIf1,
	"or" => Keyword::Or,
	"output" => Keyword::Output,
	"parameter" => Keyword::Parameter,
	"paramset" => Keyword::ParamSet,
	"pmos" => Keyword::Pmos,
	"posedge" => Keyword::PosEdge,
	"potential" => Keyword::Potential,
	"pow" => Keyword::Pow,
	"primitive" => Keyword::Primitive,
	"pull0" => Keyword::Pull0,
	"pull1" => Keyword::Pull1,
	"pulldown" => Keyword::Pulldown,
	"pullup" => Keyword::Pullup,
	"pulsestyle_ondetect" => Keyword::PulseStyleOnDetect,
	"pulsestyle_onevent" => Keyword::PulseStyleOnEvent,
	"rcmos" => Keyword::Rcmos,
	"real" => Keyword::Real,
	"realtime" => Keyword::Realtime,
	"reg" => Keyword::Reg,
	"release" => Keyword::Release,
	"repeat" => Keyword::Repeat,
	"resolveto" => Keyword::ResolveTo,
	"return" => Keyword::Return,
	"rnmos" => Keyword::Rnmos,
	"rpmos" => Keyword::Rpmos,
	"rtran" => Keyword::Rtran,
	"rtranif0" => Keyword::RtranIf0,
	"rtranif1" => Keyword::RtranIf1,
	"scalared" => Keyword::Scalared,
	"showcancelled" => Keyword::ShowCancelled,
	"signed" => Keyword::Signed,
	"sin" => Keyword::Sin,
	"sinh" => Keyword::Sinh,
	"slew" => Keyword::Slew,
	"small" => Keyword::Small,
	"specify" => Keyword::Specify,
	"specparam" => Keyword::SpecParam,
	"split" => Keyword::Split,
	"sqrt" => Keyword::Sqrt,
	"string" => Keyword::String,
	"strong0" => Keyword::Strong0,
	"strong1" => Keyword::Strong1,
	"supply0" => Keyword::Supply0,
	"supply1" => Keyword::Supply1,
	"table" => Keyword::Table,
	"tan" => Keyword::Tan,
	"tanh" => Keyword::Tanh,
	"task" => Keyword::Task,
	"time" => Keyword::Time,
	"timer" => Keyword::Timer,
	"tran" => Keyword::Tran,
	"tranif0" => Keyword::TranIf0,
	"tranif1" => Keyword::TranIf1,
	"transition" => Keyword::Transition,
	"tri" => Keyword::Tri,
	"tri0" => Keyword::Tri0,
	"tri1" => Keyword::Tri1,
	"triand" => Keyword::Triand,
	"trior" => Keyword::Trior,
	"trireg" => Keyword::Trireg,
	"units" => Keyword::Units,
	"unsigned" => Keyword::Unsigned,
	"use" => Keyword::Use,
	"uwire" => Keyword::Uwire,
	"vectored" => Keyword::Vectored,
	"wait" => Keyword::Wait,
	"wand" => Keyword::Wand,
	"weak0" => Keyword::Weak0,
	"weak1" => Keyword::Weak1,
	"while" => Keyword::While,
	"white_noise" => Keyword::WhiteNoise,
	"wire" => Keyword::Wire,
	"wor" => Keyword::Wor,
	"wreal" => Keyword::Wreal,
	"xnor" => Keyword::Xnor,
	"xor" => Keyword::Xor,
	"zi_nd" => Keyword::ZiNd,
	"zi_np" => Keyword::ZiNp,
	"zi_zd" => Keyword::ZiZd,
	"zi_zp" => Keyword::ZiZp,
};

/// Verilog-AMS 2023 Keyword set
pub static VERILOG_AMS_23_KEYWORD_SET: phf::Set<&'static str> = phf_set! {
	"above",         "ddt",             "ground",          "nor",                 "sqrt",
	"abs",           "ddx",             "highz0",          "noshowcancelled",     "string",
	"absdelay",      "deassign",        "highz1",          "not",                 "strong0",
	"absdelta",      "default",         "hypot",           "notif0",              "strong1",
	"abstol",        "defparam",        "idt_nature",      "notif1",              "supply0",
	"ac_stim",       "design",          "idt",             "or",                  "supply1",
	"access",        "disable",         "idtmod",          "output",              "table",
	"acos",          "discipline",      "if",              "parameter",           "tan",
	"acosh",         "discrete",        "ifnone",          "paramset",            "tanh",
	"aliasparam",    "domain",          "incdir",          "pmos",                "task",
	"always",        "driver_update",   "include",         "posedge",             "time",
	"analog",        "edge",            "inf",             "potential",           "timer",
	"analysis",      "else",            "initial_step",    "pow",                 "tran",
	"and",           "end",             "initial",         "primitive",           "tranif0",
	"asin",          "endcase",         "inout",           "pull0",               "tranif1",
	"asinh",         "endconfig",       "input",           "pull1",               "transition",
	"assign",        "endconnectrules", "instance",        "pulldown",            "tri",
	"atan",          "enddiscipline",   "integer",         "pullup",              "tri0",
	"atan2",         "endfunction",     "join",            "pulsestyle_ondetect", "tri1",
	"atanh",         "endgenerate",     "laplace_nd",      "pulsestyle_onevent",  "triand",
	"automatic",     "endmodule",       "laplace_np",      "rcmos",               "trior",
	"begin",         "endnature",       "laplace_zd",      "real",                "trireg",
	"branch",        "endparamset",     "laplace_zp",      "realtime",            "units",
	"break",         "endprimitive",    "large",           "reg",                 "unsigned",
	"buf",           "endspecify",      "last_crossing",   "release",             "use",
	"bufif0",        "endtable",        "liblist",         "repeat",              "uwire",
	"bufif1",        "endtask",         "library",         "resolveto",           "vectored",
	"case",          "event",           "limexp",          "return",              "wait",
	"casex",         "exclude",         "ln",              "rnmos",               "wand",
	"casez",         "exp",             "ln1p",            "rpmos",               "weak0",
	"ceil",          "expm1",           "localparam",      "rtran",               "weak1",
	"cell",          "final_step",      "log",             "rtranif0",            "while",
	"cmos",          "flicker_noise",   "macromodule",     "rtranif1",            "white_noise",
	"config",        "floor",           "max",             "scalared",            "wire",
	"connect",       "flow",            "medium",          "showcancelled",       "wor",
	"connectmodule", "for",             "merged",          "signed",              "wreal",
	"connectrules",  "force",           "min",             "sin",                 "xnor",
	"continue",      "forever",         "module",          "sinh",                "xor",
	"continuous",    "fork",            "nand",            "slew",                "zi_nd",
	"cos",           "from",            "negedge",         "small",               "zi_np",
	"cosh",          "function",        "nmos",            "specify",             "zi_zd",
	"cross",         "generate",        "noise_table_log", "specparam",           "zi_zp",
	"ddt_nature",    "genvar",          "noise_table",     "split",
};

/// Get the Verilog 1995 keyword for the given identifier if it exists
#[allow(unused)]
#[inline]
pub fn get_verilog_95_keyword(ident: &str) -> Option<Keyword> {
	VERILOG_95_KEYWORD_MAP.get(ident).copied()
}

/// Check to see if the given identifier is a Verilog 1995 keyword
///
/// This is used rather than [`verilog_95_keyword`] to test if the
/// found identifier for a lower Verilog standard is a keyword in this
/// standard.
///
/// It prevents the copy into an [`Option`] if it is a keyword.
#[allow(unused)]
#[inline]
pub fn is_verilog_95_keyword(ident: &str) -> bool {
	VERILOG_95_KEYWORD_SET.contains(ident)
}

/// Get the Verilog 2001 keyword for the given identifier if it exists
#[allow(unused)]
#[inline]
pub fn get_verilog_01_keyword(ident: &str) -> Option<Keyword> {
	VERILOG_01_KEYWORD_MAP.get(ident).copied()
}

/// Check to see if the given identifier is a Verilog 2001 keyword
///
/// This is used rather than [`verilog_01_keyword`] to test if the
/// found identifier for a lower Verilog standard is a keyword in this
/// standard.
///
/// It prevents the copy into an [`Option`] if it is a keyword.
#[allow(unused)]
#[inline]
pub fn is_verilog_01_keyword(ident: &str) -> bool {
	VERILOG_01_KEYWORD_SET.contains(ident)
}

/// Get the Verilog 2005 keyword for the given identifier if it exists
#[allow(unused)]
#[inline]
pub fn get_verilog_05_keyword(ident: &str) -> Option<Keyword> {
	VERILOG_05_KEYWORD_MAP.get(ident).copied()
}

/// Check to see if the given identifier is a Verilog 2005 keyword
///
/// This is used rather than [`verilog_05_keyword`] to test if the
/// found identifier for a lower Verilog standard is a keyword in this
/// standard.
///
/// It prevents the copy into an [`Option`] if it is a keyword.
#[allow(unused)]
#[inline]
pub fn is_verilog_05_keyword(ident: &str) -> bool {
	VERILOG_05_KEYWORD_SET.contains(ident)
}

/// Get the Verilog keyword for the given standard if it exists
#[allow(unused)]
#[inline]
pub fn get_verilog_keyword(ident: &str, std: VerilogStd) -> Option<Keyword> {
	match std {
		VerilogStd::Vl95 => get_verilog_95_keyword(ident),
		VerilogStd::Vl01 => get_verilog_01_keyword(ident),
		VerilogStd::Vl05 => get_verilog_05_keyword(ident),
	}
}

/// Get the SystemVerilog 2005 keyword for the given identifier if it exists
#[allow(unused)]
#[inline]
pub fn get_system_verilog_05_keyword(ident: &str) -> Option<Keyword> {
	SYSTEM_VERILOG_05_KEYWORD_MAP.get(ident).copied()
}

/// Check to see if the given identifier is a SystemVerilog 2005 keyword
///
/// This is used rather than [`system_verilog_05_keyword`] to test if the
/// found identifier for a lower Verilog standard is a keyword in this
/// standard.
///
/// It prevents the copy into an [`Option`] if it is a keyword.
#[allow(unused)]
#[inline]
pub fn is_system_verilog_05_keyword(ident: &str) -> bool {
	SYSTEM_VERILOG_05_KEYWORD_SET.contains(ident)
}

/// Get the SystemVerilog 2009 keyword for the given identifier if it exists
#[allow(unused)]
#[inline]
pub fn get_system_verilog_09_keyword(ident: &str) -> Option<Keyword> {
	SYSTEM_VERILOG_09_KEYWORD_MAP.get(ident).copied()
}

/// Check to see if the given identifier is a SystemVerilog 2009 keyword
///
/// This is used rather than [`system_verilog_09_keyword`] to test if the
/// found identifier for a lower Verilog standard is a keyword in this
/// standard.
///
/// It prevents the copy into an [`Option`] if it is a keyword.
#[allow(unused)]
#[inline]
pub fn is_system_verilog_09_keyword(ident: &str) -> bool {
	SYSTEM_VERILOG_09_KEYWORD_SET.contains(ident)
}

/// Get the SystemVerilog 2012 keyword for the given identifier if it exists
#[allow(unused)]
#[inline]
pub fn get_system_verilog_12_keyword(ident: &str) -> Option<Keyword> {
	SYSTEM_VERILOG_12_KEYWORD_MAP.get(ident).copied()
}

/// Check to see if the given identifier is a SystemVerilog 2012 keyword
///
/// This is used rather than [`system_verilog_12_keyword`] to test if the
/// found identifier for a lower Verilog standard is a keyword in this
/// standard.
///
/// It prevents the copy into an [`Option`] if it is a keyword.
#[allow(unused)]
#[inline]
pub fn is_system_verilog_12_keyword(ident: &str) -> bool {
	SYSTEM_VERILOG_12_KEYWORD_SET.contains(ident)
}

/// Get the SystemVerilog 2017 keyword for the given identifier if it exists
#[allow(unused)]
#[inline]
pub fn get_system_verilog_17_keyword(ident: &str) -> Option<Keyword> {
	SYSTEM_VERILOG_17_KEYWORD_MAP.get(ident).copied()
}

/// Check to see if the given identifier is a SystemVerilog 2017 keyword
///
/// This is used rather than [`system_verilog_17_keyword`] to test if the
/// found identifier for a lower Verilog standard is a keyword in this
/// standard.
///
/// It prevents the copy into an [`Option`] if it is a keyword.
#[allow(unused)]
#[inline]
pub fn is_system_verilog_17_keyword(ident: &str) -> bool {
	SYSTEM_VERILOG_17_KEYWORD_SET.contains(ident)
}

/// Get the SystemVerilog 2023 keyword for the given identifier if it exists
#[allow(unused)]
#[inline]
pub fn get_system_verilog_23_keyword(ident: &str) -> Option<Keyword> {
	SYSTEM_VERILOG_23_KEYWORD_MAP.get(ident).copied()
}

/// Check to see if the given identifier is a SystemVerilog 2023 keyword
///
/// This is used rather than [`system_verilog_23_keyword`] to test if the
/// found identifier for a lower Verilog standard is a keyword in this
/// standard.
///
/// It prevents the copy into an [`Option`] if it is a keyword.
#[allow(unused)]
#[inline]
pub fn is_system_verilog_23_keyword(ident: &str) -> bool {
	SYSTEM_VERILOG_23_KEYWORD_SET.contains(ident)
}

/// Get the SystemVerilog keyword for the given standard if it exists
#[allow(unused)]
#[inline]
pub fn get_system_verilog_keyword(ident: &str, std: SystemVerilogStd) -> Option<Keyword> {
	match std {
		SystemVerilogStd::Sv05 => get_system_verilog_05_keyword(ident),
		SystemVerilogStd::Sv09 => get_system_verilog_09_keyword(ident),
		SystemVerilogStd::Sv12 => get_system_verilog_12_keyword(ident),
		SystemVerilogStd::Sv17 => get_system_verilog_17_keyword(ident),
		SystemVerilogStd::Sv23 => get_system_verilog_23_keyword(ident),
	}
}

/// Get the Verilog-AMS 2009 keyword for the given identifier if it exists
#[allow(unused)]
#[inline]
pub fn get_verilog_ams_09_keyword(ident: &str) -> Option<Keyword> {
	VERILOG_AMS_09_KEYWORD_MAP.get(ident).copied()
}

/// Check to see if the given identifier is a Verilog-AMS 2009 keyword
///
/// This is used rather than [`verilog_ams_09_keyword`] to test if the
/// found identifier for a lower Verilog standard is a keyword in this
/// standard.
///
/// It prevents the copy into an [`Option`] if it is a keyword.
#[allow(unused)]
#[inline]
pub fn is_verilog_ams_09_keyword(ident: &str) -> bool {
	VERILOG_AMS_09_KEYWORD_SET.contains(ident)
}

/// Get the Verilog-AMS 2014 keyword for the given identifier if it exists
#[allow(unused)]
#[inline]
pub fn get_verilog_ams_14_keyword(ident: &str) -> Option<Keyword> {
	VERILOG_AMS_14_KEYWORD_MAP.get(ident).copied()
}

/// Check to see if the given identifier is a Verilog-AMS 2014 keyword
///
/// This is used rather than [`verilog_ams_14_keyword`] to test if the
/// found identifier for a lower Verilog standard is a keyword in this
/// standard.
///
/// It prevents the copy into an [`Option`] if it is a keyword.
#[allow(unused)]
#[inline]
pub fn is_verilog_ams_14_keyword(ident: &str) -> bool {
	VERILOG_AMS_14_KEYWORD_SET.contains(ident)
}

/// Get the Verilog-AMS 2023 keyword for the given identifier if it exists
#[allow(unused)]
#[inline]
pub fn get_verilog_ams_23_keyword(ident: &str) -> Option<Keyword> {
	VERILOG_AMS_23_KEYWORD_MAP.get(ident).copied()
}

/// Check to see if the given identifier is a Verilog-AMS 2023 keyword
///
/// This is used rather than [`verilog_ams_23_keyword`] to test if the
/// found identifier for a lower Verilog standard is a keyword in this
/// standard.
///
/// It prevents the copy into an [`Option`] if it is a keyword.
#[allow(unused)]
#[inline]
pub fn is_verilog_ams_23_keyword(ident: &str) -> bool {
	VERILOG_AMS_23_KEYWORD_SET.contains(ident)
}

/// Get the Verilog-AMS keyword for the given standard if it exists
#[allow(unused)]
#[inline]
pub fn get_verilog_ams_keyword(ident: &str, std: VerilogAmsStd) -> Option<Keyword> {
	match std {
		VerilogAmsStd::Vams09 => get_verilog_ams_09_keyword(ident),
		VerilogAmsStd::Vams14 => get_verilog_ams_14_keyword(ident),
		VerilogAmsStd::Vams23 => get_verilog_ams_23_keyword(ident),
	}
}

/// Get the given Verilog/Verilog-AMS/SystemVerilog keyword for the given standard if it exists
#[allow(unused)]
#[inline]
pub fn get_keyword(ident: &str, variant: VerilogVariant) -> Option<Keyword> {
	match variant {
		VerilogVariant::Verilog(std) => get_verilog_keyword(ident, std),
		VerilogVariant::SystemVerilog(std) => get_system_verilog_keyword(ident, std),
		VerilogVariant::VerilogAms(std) => get_verilog_ams_keyword(ident, std),
	}
}

// XXX(aki):  This is very likely less than ideal, and stupidly expensive, but I cant think of a
// better way
/// Check to see if the given identifier is a keyword in a future Verilog standard, returning
/// the standard version if so.
#[allow(unused)]
#[inline]
pub fn is_future_verilog_keyword(ident: &str, variant: VerilogVariant) -> Option<VerilogVariant> {
	match variant {
		VerilogVariant::Verilog(std) => match std {
			VerilogStd::Vl95 => {
				if is_verilog_95_keyword(ident) {
					Some(VerilogVariant::Verilog(VerilogStd::Vl95))
				} else if is_verilog_01_keyword(ident) {
					Some(VerilogVariant::Verilog(VerilogStd::Vl01))
				} else if is_verilog_05_keyword(ident) {
					Some(VerilogVariant::Verilog(VerilogStd::Vl05))
				} else if is_system_verilog_05_keyword(ident) {
					Some(VerilogVariant::SystemVerilog(SystemVerilogStd::Sv05))
				} else if is_system_verilog_09_keyword(ident) {
					Some(VerilogVariant::SystemVerilog(SystemVerilogStd::Sv09))
				} else if is_system_verilog_12_keyword(ident) {
					Some(VerilogVariant::SystemVerilog(SystemVerilogStd::Sv12))
				} else if is_system_verilog_17_keyword(ident) {
					Some(VerilogVariant::SystemVerilog(SystemVerilogStd::Sv17))
				} else if is_system_verilog_23_keyword(ident) {
					Some(VerilogVariant::SystemVerilog(SystemVerilogStd::Sv23))
				} else {
					None
				}
			},
			VerilogStd::Vl01 => {
				if is_verilog_01_keyword(ident) {
					Some(VerilogVariant::Verilog(VerilogStd::Vl01))
				} else if is_verilog_05_keyword(ident) {
					Some(VerilogVariant::Verilog(VerilogStd::Vl05))
				} else if is_system_verilog_05_keyword(ident) {
					Some(VerilogVariant::SystemVerilog(SystemVerilogStd::Sv05))
				} else if is_system_verilog_09_keyword(ident) {
					Some(VerilogVariant::SystemVerilog(SystemVerilogStd::Sv09))
				} else if is_system_verilog_12_keyword(ident) {
					Some(VerilogVariant::SystemVerilog(SystemVerilogStd::Sv12))
				} else if is_system_verilog_17_keyword(ident) {
					Some(VerilogVariant::SystemVerilog(SystemVerilogStd::Sv17))
				} else if is_system_verilog_23_keyword(ident) {
					Some(VerilogVariant::SystemVerilog(SystemVerilogStd::Sv23))
				} else {
					None
				}
			},
			VerilogStd::Vl05 => {
				if is_verilog_05_keyword(ident) {
					Some(VerilogVariant::Verilog(VerilogStd::Vl05))
				} else if is_system_verilog_05_keyword(ident) {
					Some(VerilogVariant::SystemVerilog(SystemVerilogStd::Sv05))
				} else if is_system_verilog_09_keyword(ident) {
					Some(VerilogVariant::SystemVerilog(SystemVerilogStd::Sv09))
				} else if is_system_verilog_12_keyword(ident) {
					Some(VerilogVariant::SystemVerilog(SystemVerilogStd::Sv12))
				} else if is_system_verilog_17_keyword(ident) {
					Some(VerilogVariant::SystemVerilog(SystemVerilogStd::Sv17))
				} else if is_system_verilog_23_keyword(ident) {
					Some(VerilogVariant::SystemVerilog(SystemVerilogStd::Sv23))
				} else {
					None
				}
			},
		},
		VerilogVariant::SystemVerilog(std) => match std {
			SystemVerilogStd::Sv05 => {
				if is_system_verilog_05_keyword(ident) {
					Some(VerilogVariant::SystemVerilog(SystemVerilogStd::Sv05))
				} else if is_system_verilog_09_keyword(ident) {
					Some(VerilogVariant::SystemVerilog(SystemVerilogStd::Sv09))
				} else if is_system_verilog_12_keyword(ident) {
					Some(VerilogVariant::SystemVerilog(SystemVerilogStd::Sv12))
				} else if is_system_verilog_17_keyword(ident) {
					Some(VerilogVariant::SystemVerilog(SystemVerilogStd::Sv17))
				} else if is_system_verilog_23_keyword(ident) {
					Some(VerilogVariant::SystemVerilog(SystemVerilogStd::Sv23))
				} else {
					None
				}
			},
			SystemVerilogStd::Sv09 => {
				if is_system_verilog_09_keyword(ident) {
					Some(VerilogVariant::SystemVerilog(SystemVerilogStd::Sv09))
				} else if is_system_verilog_12_keyword(ident) {
					Some(VerilogVariant::SystemVerilog(SystemVerilogStd::Sv12))
				} else if is_system_verilog_17_keyword(ident) {
					Some(VerilogVariant::SystemVerilog(SystemVerilogStd::Sv17))
				} else if is_system_verilog_23_keyword(ident) {
					Some(VerilogVariant::SystemVerilog(SystemVerilogStd::Sv23))
				} else {
					None
				}
			},
			SystemVerilogStd::Sv12 => {
				if is_system_verilog_12_keyword(ident) {
					Some(VerilogVariant::SystemVerilog(SystemVerilogStd::Sv12))
				} else if is_system_verilog_17_keyword(ident) {
					Some(VerilogVariant::SystemVerilog(SystemVerilogStd::Sv17))
				} else if is_system_verilog_23_keyword(ident) {
					Some(VerilogVariant::SystemVerilog(SystemVerilogStd::Sv23))
				} else {
					None
				}
			},
			SystemVerilogStd::Sv17 => {
				if is_system_verilog_17_keyword(ident) {
					Some(VerilogVariant::SystemVerilog(SystemVerilogStd::Sv17))
				} else if is_system_verilog_23_keyword(ident) {
					Some(VerilogVariant::SystemVerilog(SystemVerilogStd::Sv23))
				} else {
					None
				}
			},
			SystemVerilogStd::Sv23 => {
				if is_system_verilog_23_keyword(ident) {
					Some(VerilogVariant::SystemVerilog(SystemVerilogStd::Sv23))
				} else {
					None
				}
			},
		},
		VerilogVariant::VerilogAms(std) => match std {
			VerilogAmsStd::Vams09 => {
				if is_verilog_ams_09_keyword(ident) {
					Some(VerilogVariant::VerilogAms(VerilogAmsStd::Vams09))
				} else if is_verilog_ams_14_keyword(ident) {
					Some(VerilogVariant::VerilogAms(VerilogAmsStd::Vams14))
				} else if is_verilog_ams_23_keyword(ident) {
					Some(VerilogVariant::VerilogAms(VerilogAmsStd::Vams23))
				} else {
					None
				}
			},
			VerilogAmsStd::Vams14 => {
				if is_verilog_ams_14_keyword(ident) {
					Some(VerilogVariant::VerilogAms(VerilogAmsStd::Vams14))
				} else if is_verilog_ams_23_keyword(ident) {
					Some(VerilogVariant::VerilogAms(VerilogAmsStd::Vams23))
				} else {
					None
				}
			},
			VerilogAmsStd::Vams23 => {
				if is_verilog_ams_23_keyword(ident) {
					Some(VerilogVariant::VerilogAms(VerilogAmsStd::Vams23))
				} else {
					None
				}
			},
		},
	}
}
